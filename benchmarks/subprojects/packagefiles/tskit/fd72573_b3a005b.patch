diff --git a/tests/test_core.c b/tests/test_core.c
index 97f1d4c..801e5aa 100644
--- a/tests/test_core.c
+++ b/tests/test_core.c
@@ -526,6 +526,84 @@ test_avl_random(void)
     validate_avl(sizeof(keys) / sizeof(*keys), keys);
 }
 
+static void
+test_bit_arrays(void)
+{
+    // NB: This test is only valid for the 32 bit implementation of bit arrays. If we
+    //     were to change the chunk size of a bit array, we'd need to update these tests
+    tsk_bit_array_t arr;
+    tsk_bit_array_init(&arr, 90, 1);
+    for (tsk_bit_array_value_t i = 0; i < 20; i++) {
+        tsk_bit_array_add_bit(&arr, i);
+    }
+    tsk_bit_array_add_bit(&arr, 63);
+    tsk_bit_array_add_bit(&arr, 65);
+
+    // these assertions are only valid for 32-bit values
+    CU_ASSERT_EQUAL_FATAL(arr.data[0], 1048575);
+    CU_ASSERT_EQUAL_FATAL(arr.data[1], 2147483648);
+    CU_ASSERT_EQUAL_FATAL(arr.data[2], 2);
+
+    // verify our assumptions about bit array counting
+    CU_ASSERT_EQUAL_FATAL(tsk_bit_array_count(&arr), 22);
+
+    tsk_bit_array_free(&arr);
+
+    // create a length-2 array with 64 bit capacity
+    tsk_bit_array_init(&arr, 64, 2);
+    tsk_bit_array_t arr_row1, arr_row2;
+
+    // select the first and second row
+    tsk_bit_array_get_row(&arr, 0, &arr_row1);
+    tsk_bit_array_get_row(&arr, 1, &arr_row2);
+
+    // fill the first 50 bits of the first row
+    for (tsk_bit_array_value_t i = 0; i < 50; i++) {
+        tsk_bit_array_add_bit(&arr_row1, i);
+    }
+    // fill bits 20-40 of the second row
+    for (tsk_bit_array_value_t i = 20; i < 40; i++) {
+        tsk_bit_array_add_bit(&arr_row2, i);
+    }
+
+    // verify our assumptions about row selection
+    CU_ASSERT_EQUAL_FATAL(arr.data[0], 4294967295);
+    CU_ASSERT_EQUAL_FATAL(arr.data[1], 262143);
+    CU_ASSERT_EQUAL_FATAL(arr_row1.data[0], 4294967295);
+    CU_ASSERT_EQUAL_FATAL(arr_row1.data[1], 262143);
+
+    CU_ASSERT_EQUAL_FATAL(arr.data[2], 4293918720);
+    CU_ASSERT_EQUAL_FATAL(arr.data[3], 255);
+    CU_ASSERT_EQUAL_FATAL(arr_row2.data[0], 4293918720);
+    CU_ASSERT_EQUAL_FATAL(arr_row2.data[1], 255);
+
+    // subtract the second from the first row, store in first
+    tsk_bit_array_subtract(&arr_row1, &arr_row2);
+
+    // verify our assumptions about subtraction
+    CU_ASSERT_EQUAL_FATAL(arr_row1.data[0], 1048575);
+    CU_ASSERT_EQUAL_FATAL(arr_row1.data[1], 261888);
+
+    tsk_bit_array_t int_result;
+    tsk_bit_array_init(&int_result, 64, 1);
+
+    // their intersection should be zero
+    tsk_bit_array_intersect(&arr_row1, &arr_row2, &int_result);
+    CU_ASSERT_EQUAL_FATAL(int_result.data[0], 0);
+    CU_ASSERT_EQUAL_FATAL(int_result.data[1], 0);
+
+    // now, add them back together, storing back in a
+    tsk_bit_array_add(&arr_row1, &arr_row2);
+
+    // now, their intersection should be the subtracted chunk (20-40)
+    tsk_bit_array_intersect(&arr_row1, &arr_row2, &int_result);
+    CU_ASSERT_EQUAL_FATAL(int_result.data[0], 4293918720);
+    CU_ASSERT_EQUAL_FATAL(int_result.data[1], 255);
+
+    tsk_bit_array_free(&int_result);
+    tsk_bit_array_free(&arr);
+}
+
 static void
 test_meson_version(void)
 {
@@ -554,6 +632,7 @@ main(int argc, char **argv)
         { "test_avl_sequential", test_avl_sequential },
         { "test_avl_interleaved", test_avl_interleaved },
         { "test_avl_random", test_avl_random },
+        { "test_bit_arrays", test_bit_arrays },
         { "test_meson_version", test_meson_version },
         { NULL, NULL },
     };
diff --git a/tests/test_stats.c b/tests/test_stats.c
index 3599128..4886533 100644
--- a/tests/test_stats.c
+++ b/tests/test_stats.c
@@ -1,7 +1,7 @@
 /*
  * MIT License
  *
- * Copyright (c) 2019-2022 Tskit Developers
+ * Copyright (c) 2019-2023 Tskit Developers
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -262,6 +262,48 @@ verify_mean_descendants(tsk_treeseq_t *ts)
     free(C);
 }
 
+/* Check the divergence matrix by running against the stats API equivalent
+ * code. NOTE: this will not always be equal in site mode, because of a slightly
+ * different definition wrt to multiple mutations at a site.
+ */
+static void
+verify_divergence_matrix(tsk_treeseq_t *ts, tsk_flags_t mode)
+{
+    int ret;
+    const tsk_size_t n = tsk_treeseq_get_num_samples(ts);
+    const tsk_id_t *samples = tsk_treeseq_get_samples(ts);
+    tsk_size_t sample_set_sizes[n];
+    tsk_id_t index_tuples[2 * n * n];
+    double D1[n * n], D2[n * n];
+    tsk_size_t i, j, k;
+
+    for (j = 0; j < n; j++) {
+        sample_set_sizes[j] = 1;
+        for (k = 0; k < n; k++) {
+            index_tuples[2 * (j * n + k)] = (tsk_id_t) j;
+            index_tuples[2 * (j * n + k) + 1] = (tsk_id_t) k;
+        }
+    }
+    ret = tsk_treeseq_divergence(
+        ts, n, sample_set_sizes, samples, n * n, index_tuples, 0, NULL, mode, D1);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+
+    ret = tsk_treeseq_divergence_matrix(ts, 0, NULL, 0, NULL, mode, D2);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+
+    for (j = 0; j < n; j++) {
+        for (k = 0; k < n; k++) {
+            i = j * n + k;
+            /* printf("%d\t%d\t%f\t%f\n", (int) j, (int) k, D1[i], D2[i]); */
+            if (j == k) {
+                CU_ASSERT_EQUAL(D2[i], 0);
+            } else {
+                CU_ASSERT_DOUBLE_EQUAL(D1[i], D2[i], 1E-6);
+            }
+        }
+    }
+}
+
 typedef struct {
     int call_count;
     int error_on;
@@ -303,6 +345,16 @@ verify_window_errors(tsk_treeseq_t *ts, tsk_flags_t mode)
         ts, 1, W, 1, general_stat_error, NULL, 2, windows, options, sigma);
     CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_WINDOWS);
 
+    windows[0] = -1;
+    ret = tsk_treeseq_general_stat(
+        ts, 1, W, 1, general_stat_error, NULL, 2, windows, options, sigma);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_WINDOWS);
+
+    windows[1] = -1;
+    ret = tsk_treeseq_general_stat(
+        ts, 1, W, 1, general_stat_error, NULL, 1, windows, options, sigma);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_WINDOWS);
+
     windows[0] = 10;
     ret = tsk_treeseq_general_stat(
         ts, 1, W, 1, general_stat_error, NULL, 2, windows, options, sigma);
@@ -396,11 +448,10 @@ verify_node_general_stat_errors(tsk_treeseq_t *ts)
 static void
 verify_one_way_weighted_func_errors(tsk_treeseq_t *ts, one_way_weighted_method *method)
 {
-    // we don't have any specific errors for this function
-    // but we might add some in the future
     int ret;
     tsk_size_t num_samples = tsk_treeseq_get_num_samples(ts);
     double *weights = tsk_malloc(num_samples * sizeof(double));
+    double bad_windows[] = { 0, -1 };
     double result;
     tsk_size_t j;
 
@@ -409,7 +460,10 @@ verify_one_way_weighted_func_errors(tsk_treeseq_t *ts, one_way_weighted_method *
     }
 
     ret = method(ts, 0, weights, 0, NULL, 0, &result);
-    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_STATE_DIMS);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_INSUFFICIENT_WEIGHTS);
+
+    ret = method(ts, 1, weights, 1, bad_windows, 0, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_WINDOWS);
 
     free(weights);
 }
@@ -418,12 +472,11 @@ static void
 verify_one_way_weighted_covariate_func_errors(
     tsk_treeseq_t *ts, one_way_covariates_method *method)
 {
-    // we don't have any specific errors for this function
-    // but we might add some in the future
     int ret;
     tsk_size_t num_samples = tsk_treeseq_get_num_samples(ts);
     double *weights = tsk_malloc(num_samples * sizeof(double));
     double *covariates = NULL;
+    double bad_windows[] = { 0, -1 };
     double result;
     tsk_size_t j;
 
@@ -432,7 +485,10 @@ verify_one_way_weighted_covariate_func_errors(
     }
 
     ret = method(ts, 0, weights, 0, covariates, 0, NULL, 0, &result);
-    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_STATE_DIMS);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_INSUFFICIENT_WEIGHTS);
+
+    ret = method(ts, 1, weights, 0, covariates, 1, bad_windows, 0, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_WINDOWS);
 
     free(weights);
 }
@@ -516,6 +572,28 @@ verify_two_way_stat_func_errors(tsk_treeseq_t *ts, general_sample_stat_method *m
     CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_SAMPLE_SET_INDEX);
 }
 
+static void
+verify_two_way_weighted_stat_func_errors(
+    tsk_treeseq_t *ts, two_way_weighted_method *method)
+{
+    int ret;
+    tsk_id_t indexes[] = { 0, 0, 0, 1 };
+    double bad_windows[] = { -1, -1 };
+    double weights[10];
+    double result[10];
+
+    memset(weights, 0, sizeof(weights));
+
+    ret = method(ts, 2, weights, 2, indexes, 0, NULL, result, 0);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+
+    ret = method(ts, 0, weights, 2, indexes, 0, NULL, result, 0);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_INSUFFICIENT_WEIGHTS);
+
+    ret = method(ts, 2, weights, 2, indexes, 1, bad_windows, result, 0);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_WINDOWS);
+}
+
 static void
 verify_three_way_stat_func_errors(tsk_treeseq_t *ts, general_sample_stat_method *method)
 {
@@ -973,6 +1051,128 @@ test_single_tree_general_stat_errors(void)
     tsk_treeseq_free(&ts);
 }
 
+static void
+test_single_tree_divergence_matrix(void)
+{
+    tsk_treeseq_t ts;
+    int ret;
+    double result[16];
+    double D_branch[16] = { 0, 2, 6, 6, 2, 0, 6, 6, 6, 6, 0, 4, 6, 6, 4, 0 };
+    double D_site[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+    tsk_treeseq_from_text(&ts, 1, single_tree_ex_nodes, single_tree_ex_edges, NULL, NULL,
+        NULL, NULL, NULL, 0);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 0, NULL, 0, NULL, TSK_STAT_BRANCH, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(16, result, D_branch);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 0, NULL, 0, NULL, TSK_STAT_SITE, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(16, result, D_site);
+
+    verify_divergence_matrix(&ts, TSK_STAT_BRANCH);
+    verify_divergence_matrix(&ts, TSK_STAT_SITE);
+
+    tsk_treeseq_free(&ts);
+}
+
+static void
+test_single_tree_divergence_matrix_internal_samples(void)
+{
+    tsk_treeseq_t ts;
+    int ret;
+    double result[16];
+    double D[16] = { 0, 2, 4, 3, 2, 0, 4, 3, 4, 4, 0, 1, 3, 3, 1, 0 };
+
+    const char *nodes = "1  0   -1   -1\n" /* 2.00┊    6    ┊ */
+                        "1  0   -1   -1\n" /*     ┊  ┏━┻━┓  ┊ */
+                        "1  0   -1   -1\n" /* 1.00┊  4   5* ┊ */
+                        "0  0   -1   -1\n" /*     ┊ ┏┻┓ ┏┻┓ ┊ */
+                        "0  1   -1   -1\n" /* 0.00┊ 0 1 2 3 ┊ */
+                        "1  1   -1   -1\n" /*     0 * * *   1 */
+                        "0  2   -1   -1\n";
+    const char *edges = "0  1   4   0,1\n"
+                        "0  1   5   2,3\n"
+                        "0  1   6   4,5\n";
+    /* One mutations per branch so we get the same as the branch length value */
+    const char *sites = "0.1  A\n"
+                        "0.2  A\n"
+                        "0.3  A\n"
+                        "0.4  A\n"
+                        "0.5  A\n"
+                        "0.6  A\n";
+    const char *mutations = "0  0  T  -1\n"
+                            "1  1  T  -1\n"
+                            "2  2  T  -1\n"
+                            "3  3  T  -1\n"
+                            "4  4  T  -1\n"
+                            "5  5  T  -1\n";
+
+    tsk_treeseq_from_text(&ts, 1, nodes, edges, NULL, sites, mutations, NULL, NULL, 0);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 0, NULL, 0, NULL, TSK_STAT_BRANCH, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(16, result, D);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 0, NULL, 0, NULL, TSK_STAT_SITE, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(16, result, D);
+
+    verify_divergence_matrix(&ts, TSK_STAT_BRANCH);
+    verify_divergence_matrix(&ts, TSK_STAT_SITE);
+
+    tsk_treeseq_free(&ts);
+}
+
+static void
+test_single_tree_divergence_matrix_multi_root(void)
+{
+    tsk_treeseq_t ts;
+    int ret;
+    double result[16];
+    double D_branch[16] = { 0, 2, 3, 3, 2, 0, 3, 3, 3, 3, 0, 4, 3, 3, 4, 0 };
+    double D_site[16] = { 0, 4, 6, 6, 4, 0, 6, 6, 6, 6, 0, 8, 6, 6, 8, 0 };
+
+    const char *nodes = "1  0   -1   -1\n"
+                        "1  0   -1   -1\n"  /* 2.00┊      5  ┊ */
+                        "1  0   -1   -1\n"  /* 1.00┊  4      ┊ */
+                        "1  0   -1   -1\n"  /*     ┊ ┏┻┓ ┏┻┓ ┊ */
+                        "0  1   -1   -1\n"  /* 0.00┊ 0 1 2 3 ┊ */
+                        "0  2   -1   -1\n"; /*     0 * * * * 1 */
+    const char *edges = "0  1   4   0,1\n"
+                        "0  1   5   2,3\n";
+    /* Two mutations per branch unit so we get twice branch length value */
+    const char *sites = "0.1  A\n"
+                        "0.2  A\n"
+                        "0.3  A\n"
+                        "0.4  A\n";
+    const char *mutations = "0  0  B  -1\n"
+                            "0  0  C  0\n"
+                            "1  1  B  -1\n"
+                            "1  1  C  2\n"
+                            "2  2  B  -1\n"
+                            "2  2  C  4\n"
+                            "2  2  D  5\n"
+                            "2  2  E  6\n"
+                            "3  3  B  -1\n"
+                            "3  3  C  8\n"
+                            "3  3  D  9\n"
+                            "3  3  E  10\n";
+
+    tsk_treeseq_from_text(&ts, 1, nodes, edges, NULL, sites, mutations, NULL, NULL, 0);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 0, NULL, 0, NULL, TSK_STAT_BRANCH, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(16, result, D_branch);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 0, NULL, 0, NULL, TSK_STAT_SITE, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(16, result, D_site);
+
+    tsk_treeseq_free(&ts);
+}
+
 static void
 test_paper_ex_ld(void)
 {
@@ -1351,6 +1551,46 @@ test_paper_ex_genetic_relatedness_errors(void)
     tsk_treeseq_free(&ts);
 }
 
+static void
+test_paper_ex_genetic_relatedness_weighted(void)
+{
+    tsk_treeseq_t ts;
+    double weights[] = { 1.2, 0.1, 0.0, 0.0, 3.4, 5.0, 1.0, -1.0 };
+    tsk_id_t indexes[] = { 0, 0, 0, 1 };
+    double result[100];
+    tsk_size_t num_weights;
+    int ret;
+
+    tsk_treeseq_from_text(&ts, 10, paper_ex_nodes, paper_ex_edges, NULL, paper_ex_sites,
+        paper_ex_mutations, paper_ex_individuals, NULL, 0);
+
+    for (num_weights = 1; num_weights < 3; num_weights++) {
+        ret = tsk_treeseq_genetic_relatedness_weighted(
+            &ts, num_weights, weights, 2, indexes, 0, NULL, result, TSK_STAT_SITE);
+        CU_ASSERT_EQUAL_FATAL(ret, 0);
+        ret = tsk_treeseq_genetic_relatedness_weighted(
+            &ts, num_weights, weights, 2, indexes, 0, NULL, result, TSK_STAT_BRANCH);
+        CU_ASSERT_EQUAL_FATAL(ret, 0);
+        ret = tsk_treeseq_genetic_relatedness_weighted(
+            &ts, num_weights, weights, 2, indexes, 0, NULL, result, TSK_STAT_NODE);
+        CU_ASSERT_EQUAL_FATAL(ret, 0);
+    }
+
+    tsk_treeseq_free(&ts);
+}
+
+static void
+test_paper_ex_genetic_relatedness_weighted_errors(void)
+{
+    tsk_treeseq_t ts;
+
+    tsk_treeseq_from_text(&ts, 10, paper_ex_nodes, paper_ex_edges, NULL, paper_ex_sites,
+        paper_ex_mutations, paper_ex_individuals, NULL, 0);
+    verify_two_way_weighted_stat_func_errors(
+        &ts, tsk_treeseq_genetic_relatedness_weighted);
+    tsk_treeseq_free(&ts);
+}
+
 static void
 test_paper_ex_Y2_errors(void)
 {
@@ -1592,6 +1832,20 @@ test_paper_ex_afs(void)
     tsk_treeseq_free(&ts);
 }
 
+static void
+test_paper_ex_divergence_matrix(void)
+{
+    tsk_treeseq_t ts;
+
+    tsk_treeseq_from_text(&ts, 10, paper_ex_nodes, paper_ex_edges, NULL, paper_ex_sites,
+        paper_ex_mutations, paper_ex_individuals, NULL, 0);
+
+    verify_divergence_matrix(&ts, TSK_STAT_BRANCH);
+    verify_divergence_matrix(&ts, TSK_STAT_SITE);
+
+    tsk_treeseq_free(&ts);
+}
+
 static void
 test_nonbinary_ex_ld(void)
 {
@@ -1726,6 +1980,478 @@ test_ld_silent_mutations(void)
     free(base_ts);
 }
 
+static void
+test_paper_ex_two_site(void)
+{
+    tsk_treeseq_t ts;
+    double *result;
+    tsk_size_t s, result_size;
+    int ret;
+
+    double truth_one_set[6] = { 1, 0.1111111111111111, 0.1111111111111111, 1, 1, 1 };
+    double truth_two_sets[12] = { 1, 1, 0.1111111111111111, 0.1111111111111111,
+        0.1111111111111111, 0.1111111111111111, 1, 1, 1, 1, 1, 1 };
+    double truth_three_sets[18] = { 1, 1, 0, 0.1111111111111111, 0.1111111111111111, 0,
+        0.1111111111111111, 0.1111111111111111, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
+
+    tsk_treeseq_from_text(&ts, 10, paper_ex_nodes, paper_ex_edges, NULL, paper_ex_sites,
+        paper_ex_mutations, paper_ex_individuals, NULL, 0);
+
+    tsk_size_t sample_set_sizes[3];
+    tsk_size_t num_sample_sets;
+    tsk_id_t sample_sets[ts.num_samples * 3];
+
+    // First sample set contains all of the samples
+    sample_set_sizes[0] = ts.num_samples;
+    num_sample_sets = 1;
+    for (s = 0; s < ts.num_samples; s++) {
+        sample_sets[s] = (tsk_id_t) s;
+    }
+
+    ret = tsk_treeseq_r2(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 6);
+    assert_arrays_almost_equal(result_size * num_sample_sets, result, truth_one_set);
+    tsk_safe_free(result);
+
+    // Second sample set contains all of the samples
+    sample_set_sizes[1] = ts.num_samples;
+    num_sample_sets = 2;
+    for (s = ts.num_samples; s < ts.num_samples * 2; s++) {
+        sample_sets[s] = (tsk_id_t) s - (tsk_id_t) ts.num_samples;
+    }
+
+    ret = tsk_treeseq_r2(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 6);
+    assert_arrays_almost_equal(result_size * num_sample_sets, result, truth_two_sets);
+    tsk_safe_free(result);
+
+    // Third sample set contains the first two samples
+    sample_set_sizes[2] = 2;
+    num_sample_sets = 3;
+    for (s = ts.num_samples * 2; s < (ts.num_samples * 3) - 2; s++) {
+        sample_sets[s] = (tsk_id_t) s - (tsk_id_t) ts.num_samples * 2;
+    }
+
+    ret = tsk_treeseq_r2(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 6);
+    assert_arrays_almost_equal(result_size * num_sample_sets, result, truth_three_sets);
+    tsk_safe_free(result);
+
+    tsk_treeseq_free(&ts);
+}
+
+static void
+test_two_site_correlated_multiallelic(void)
+{
+    const char *nodes = "1   0   -1\n"
+                        "1   0   -1\n"
+                        "1   0   -1\n"
+                        "1   0   -1\n"
+                        "1   0   -1\n"
+                        "1   0   -1\n"
+                        "1   0   -1\n"
+                        "1   0   -1\n"
+                        "1   0   -1\n"
+                        "0   2   -1\n"
+                        "0   4   -1\n"
+                        "0   6   -1\n"
+                        "0   8   -1\n"
+                        "0   10  -1\n"
+                        "0   12  -1\n"
+                        "0   14  -1\n"
+                        "0   16  -1\n";
+    const char *edges = "0   20   9    0,1\n"
+                        "0   20   10   2,9\n"
+                        "0   20   11   4,5\n"
+                        "0   20   12   6,11\n"
+                        "0   20   13   7,8\n"
+                        "0   20   14   3,10\n"
+                        "0   10   15   12\n"
+                        "10  20   15   13\n"
+                        "0   10   15   14\n"
+                        "10  20   15   14\n"
+                        "10  20   16   12\n"
+                        "0   10   16   13\n"
+                        "0   10   16   15\n"
+                        "10  20   16   15\n";
+    const char *sites = "7   A\n"
+                        "13  G\n";
+    const char *mutations = "0   15  T  -1\n"
+                            "0   14  G   0\n"
+                            "1   15  T  -1\n"
+                            "1   13  C   2\n";
+
+    int ret;
+
+    tsk_treeseq_t ts;
+    double *result;
+    tsk_size_t s, result_size;
+
+    double truth_D[3]
+        = { 0.043209876543209874, -0.018518518518518517, 0.05555555555555555 };
+    double truth_D2[3]
+        = { 0.023844603634269844, 0.02384460363426984, 0.02384460363426984 };
+    double truth_r2[3] = { 1, 1, 1 };
+    double truth_D_prime[3]
+        = { 0.7777777777777777, 0.4444444444444444, 0.6666666666666666 };
+    double truth_r[3]
+        = { 0.18377223398316206, -0.12212786219416509, 0.2609542781331212 };
+    double truth_Dz[3]
+        = { 0.0033870175616860566, 0.003387017561686057, 0.003387017561686057 };
+    double truth_pi2[3]
+        = { 0.04579247743399549, 0.04579247743399549, 0.0457924774339955 };
+
+    tsk_treeseq_from_text(&ts, 20, nodes, edges, NULL, sites, mutations, NULL, NULL, 0);
+
+    tsk_size_t sample_set_sizes[1] = { ts.num_samples };
+    tsk_size_t num_sample_sets = 1;
+    tsk_id_t sample_sets[ts.num_samples];
+
+    for (s = 0; s < ts.num_samples; s++) {
+        sample_sets[s] = (tsk_id_t) s;
+    }
+
+    ret = tsk_treeseq_D(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_D);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_D2(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_D2);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_r2(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_r2);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_D_prime(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0,
+        NULL, 0, NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_D_prime);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_r(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_r);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_Dz(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_Dz);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_pi2(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL,
+        0, NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_pi2);
+    tsk_safe_free(result);
+
+    tsk_treeseq_free(&ts);
+}
+
+static void
+test_two_site_uncorrelated_multiallelic(void)
+{
+    const char *nodes = "1   0  -1\n"
+                        "1   0  -1\n"
+                        "1   0  -1\n"
+                        "1   0  -1\n"
+                        "1   0  -1\n"
+                        "1   0  -1\n"
+                        "1   0  -1\n"
+                        "1   0  -1\n"
+                        "1   0  -1\n"
+                        "0   2  -1\n"
+                        "0   4  -1\n"
+                        "0   6  -1\n"
+                        "0   8  -1\n"
+                        "0   10 -1\n"
+                        "0   12 -1\n"
+                        "0   14 -1\n"
+                        "0   16 -1\n"
+                        "0   2  -1\n"
+                        "0   4  -1\n"
+                        "0   6  -1\n"
+                        "0   8  -1\n"
+                        "0   10 -1\n"
+                        "0   12 -1\n"
+                        "0   14 -1\n"
+                        "0   16 -1\n";
+    const char *edges = "0     10    9      0,1\n"
+                        "10    20    17     0,3\n"
+                        "0     10    10     2,9\n"
+                        "10    20    18     6,17\n"
+                        "0     10    11     3,4\n"
+                        "10    20    19     1,4\n"
+                        "0     10    12     5,11\n"
+                        "10    20    20     7,19\n"
+                        "0     10    13     6,7\n"
+                        "10    20    21     2,5\n"
+                        "0     10    14     8,13\n"
+                        "10    20    22     8,21\n"
+                        "0     10    15     10,12\n"
+                        "10    20    23     18,20\n"
+                        "0     10    16     14,15\n"
+                        "10    20    24     22,23\n";
+    const char *sites = "7   A\n"
+                        "13  G\n";
+    const char *mutations = "0   15  T  -1\n"
+                            "0   12  G   0\n"
+                            "1   23  T  -1\n"
+                            "1   20  A   2\n";
+
+    tsk_treeseq_t ts;
+
+    int ret;
+    double *result;
+    tsk_size_t result_size;
+
+    double truth_D[3] = { 0.05555555555555555, 0.0, 0.05555555555555555 };
+    double truth_D2[3] = { 0.024691358024691357, 0.0, 0.024691358024691357 };
+    double truth_r2[3] = { 1, 0, 1 };
+    double truth_D_prime[3] = { 0.6666666666666665, 0.0, 0.6666666666666665 };
+    double truth_r[3] = { 0.24999999999999997, 0.0, 0.24999999999999997 };
+    double truth_Dz[3] = { 0.0, 0.0, 0.0 };
+    double truth_pi2[3]
+        = { 0.04938271604938272, 0.04938271604938272, 0.04938271604938272 };
+
+    tsk_treeseq_from_text(&ts, 20, nodes, edges, NULL, sites, mutations, NULL, NULL, 0);
+
+    tsk_size_t sample_set_sizes[1] = { ts.num_samples };
+    tsk_size_t num_sample_sets = 1;
+    tsk_id_t sample_sets[ts.num_samples];
+
+    for (tsk_size_t s = 0; s < ts.num_samples; s++) {
+        sample_sets[s] = (tsk_id_t) s;
+    }
+
+    ret = tsk_treeseq_D(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_D);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_D2(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_D2);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_r2(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_r2);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_D_prime(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0,
+        NULL, 0, NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_D_prime);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_r(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_r);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_Dz(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL, 0,
+        NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_Dz);
+    tsk_safe_free(result);
+
+    ret = tsk_treeseq_pi2(&ts, num_sample_sets, sample_set_sizes, sample_sets, 0, NULL,
+        0, NULL, 0, &result_size, &result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    CU_ASSERT_EQUAL(result_size, 3);
+    assert_arrays_almost_equal(result_size, result, truth_pi2);
+    tsk_safe_free(result);
+
+    tsk_treeseq_free(&ts);
+}
+
+static void
+test_simplest_divergence_matrix(void)
+{
+    const char *nodes = "1  0   0\n"
+                        "1  0   0\n"
+                        "0  1   0\n";
+    const char *edges = "0  1   2   0,1\n";
+    tsk_treeseq_t ts;
+    tsk_id_t sample_ids[] = { 0, 1 };
+    double D_branch[4] = { 0, 2, 2, 0 };
+    double D_site[4] = { 0, 0, 0, 0 };
+    double result[4];
+    int ret;
+
+    tsk_treeseq_from_text(&ts, 1, nodes, edges, NULL, NULL, NULL, NULL, NULL, 0);
+
+    ret = tsk_treeseq_divergence_matrix(
+        &ts, 2, sample_ids, 0, NULL, TSK_STAT_BRANCH, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(4, D_branch, result);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 2, sample_ids, 0, NULL, 0, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(4, D_site, result);
+
+    ret = tsk_treeseq_divergence_matrix(
+        &ts, 2, sample_ids, 0, NULL, TSK_STAT_SITE, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(4, D_site, result);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 0, NULL, 0, NULL, TSK_STAT_BRANCH, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(4, D_branch, result);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 0, NULL, 0, NULL, TSK_STAT_SITE, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(4, D_site, result);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 0, NULL, 0, NULL, TSK_STAT_NODE, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_UNSUPPORTED_STAT_MODE);
+
+    ret = tsk_treeseq_divergence_matrix(
+        &ts, 0, NULL, 0, NULL, TSK_STAT_SPAN_NORMALISE, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_STAT_SPAN_NORMALISE_UNSUPPORTED);
+
+    ret = tsk_treeseq_divergence_matrix(
+        &ts, 0, NULL, 0, NULL, TSK_STAT_POLARISED, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_STAT_POLARISED_UNSUPPORTED);
+
+    ret = tsk_treeseq_divergence_matrix(
+        &ts, 0, NULL, 0, NULL, TSK_STAT_SITE | TSK_STAT_BRANCH, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_MULTIPLE_STAT_MODES);
+
+    sample_ids[0] = -1;
+    ret = tsk_treeseq_divergence_matrix(&ts, 2, sample_ids, 0, NULL, 0, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_NODE_OUT_OF_BOUNDS);
+
+    sample_ids[0] = 3;
+    ret = tsk_treeseq_divergence_matrix(&ts, 2, sample_ids, 0, NULL, 0, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_NODE_OUT_OF_BOUNDS);
+
+    tsk_treeseq_free(&ts);
+}
+
+static void
+test_simplest_divergence_matrix_windows(void)
+{
+    const char *nodes = "1  0   0\n"
+                        "1  0   0\n"
+                        "0  1   0\n";
+    const char *edges = "0  1   2   0,1\n";
+    tsk_treeseq_t ts;
+    tsk_id_t sample_ids[] = { 0, 1 };
+    double D_branch[8] = { 0, 1, 1, 0, 0, 1, 1, 0 };
+    double D_site[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+    double result[8];
+    double windows[] = { 0, 0.5, 1 };
+    int ret;
+
+    tsk_treeseq_from_text(&ts, 1, nodes, edges, NULL, NULL, NULL, NULL, NULL, 0);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 2, sample_ids, 2, windows, 0, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(8, D_site, result);
+    ret = tsk_treeseq_divergence_matrix(
+        &ts, 2, sample_ids, 2, windows, TSK_STAT_BRANCH, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(8, D_branch, result);
+
+    ret = tsk_treeseq_divergence_matrix(&ts, 2, sample_ids, 0, windows, 0, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_NUM_WINDOWS);
+
+    windows[0] = -1;
+    ret = tsk_treeseq_divergence_matrix(&ts, 2, sample_ids, 2, windows, 0, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_WINDOWS);
+
+    windows[0] = 0.45;
+    windows[2] = 1.5;
+    ret = tsk_treeseq_divergence_matrix(&ts, 2, sample_ids, 2, windows, 0, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_WINDOWS);
+
+    windows[0] = 0.55;
+    windows[2] = 1.0;
+    ret = tsk_treeseq_divergence_matrix(&ts, 2, sample_ids, 2, windows, 0, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_BAD_WINDOWS);
+
+    tsk_treeseq_free(&ts);
+}
+
+static void
+test_simplest_divergence_matrix_internal_sample(void)
+{
+    const char *nodes = "1  0   0\n"
+                        "1  0   0\n"
+                        "0  1   0\n";
+    const char *edges = "0  1   2   0,1\n";
+    tsk_treeseq_t ts;
+    tsk_id_t sample_ids[] = { 0, 1, 2 };
+    double result[9];
+    double D_branch[9] = { 0, 2, 1, 2, 0, 1, 1, 1, 0 };
+    double D_site[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+    int ret;
+
+    tsk_treeseq_from_text(&ts, 1, nodes, edges, NULL, NULL, NULL, NULL, NULL, 0);
+
+    ret = tsk_treeseq_divergence_matrix(
+        &ts, 3, sample_ids, 0, NULL, TSK_STAT_BRANCH, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(9, D_branch, result);
+
+    ret = tsk_treeseq_divergence_matrix(
+        &ts, 3, sample_ids, 0, NULL, TSK_STAT_SITE, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    assert_arrays_almost_equal(9, D_site, result);
+
+    tsk_treeseq_free(&ts);
+}
+
+static void
+test_multiroot_divergence_matrix(void)
+{
+    tsk_treeseq_t ts;
+
+    tsk_treeseq_from_text(&ts, 10, multiroot_ex_nodes, multiroot_ex_edges, NULL,
+        multiroot_ex_sites, multiroot_ex_mutations, NULL, NULL, 0);
+
+    verify_divergence_matrix(&ts, TSK_STAT_BRANCH);
+    verify_divergence_matrix(&ts, TSK_STAT_SITE);
+
+    tsk_treeseq_free(&ts);
+}
+
 int
 main(int argc, char **argv)
 {
@@ -1745,6 +2471,11 @@ main(int argc, char **argv)
             test_single_tree_genealogical_nearest_neighbours },
         { "test_single_tree_general_stat", test_single_tree_general_stat },
         { "test_single_tree_general_stat_errors", test_single_tree_general_stat_errors },
+        { "test_single_tree_divergence_matrix", test_single_tree_divergence_matrix },
+        { "test_single_tree_divergence_matrix_internal_samples",
+            test_single_tree_divergence_matrix_internal_samples },
+        { "test_single_tree_divergence_matrix_multi_root",
+            test_single_tree_divergence_matrix_multi_root },
 
         { "test_paper_ex_ld", test_paper_ex_ld },
         { "test_paper_ex_mean_descendants", test_paper_ex_mean_descendants },
@@ -1773,6 +2504,10 @@ main(int argc, char **argv)
         { "test_paper_ex_genetic_relatedness_errors",
             test_paper_ex_genetic_relatedness_errors },
         { "test_paper_ex_genetic_relatedness", test_paper_ex_genetic_relatedness },
+        { "test_paper_ex_genetic_relatedness_weighted",
+            test_paper_ex_genetic_relatedness_weighted },
+        { "test_paper_ex_genetic_relatedness_weighted_errors",
+            test_paper_ex_genetic_relatedness_weighted_errors },
         { "test_paper_ex_Y2_errors", test_paper_ex_Y2_errors },
         { "test_paper_ex_Y2", test_paper_ex_Y2 },
         { "test_paper_ex_f2_errors", test_paper_ex_f2_errors },
@@ -1785,6 +2520,7 @@ main(int argc, char **argv)
         { "test_paper_ex_f4", test_paper_ex_f4 },
         { "test_paper_ex_afs_errors", test_paper_ex_afs_errors },
         { "test_paper_ex_afs", test_paper_ex_afs },
+        { "test_paper_ex_divergence_matrix", test_paper_ex_divergence_matrix },
 
         { "test_nonbinary_ex_ld", test_nonbinary_ex_ld },
         { "test_nonbinary_ex_mean_descendants", test_nonbinary_ex_mean_descendants },
@@ -1798,6 +2534,19 @@ main(int argc, char **argv)
         { "test_ld_multi_mutations", test_ld_multi_mutations },
         { "test_ld_silent_mutations", test_ld_silent_mutations },
 
+        { "test_paper_ex_two_site", test_paper_ex_two_site },
+        { "test_two_site_correlated_multiallelic",
+            test_two_site_correlated_multiallelic },
+        { "test_two_site_uncorrelated_multiallelic",
+            test_two_site_uncorrelated_multiallelic },
+
+        { "test_simplest_divergence_matrix", test_simplest_divergence_matrix },
+        { "test_simplest_divergence_matrix_windows",
+            test_simplest_divergence_matrix_windows },
+        { "test_simplest_divergence_matrix_internal_sample",
+            test_simplest_divergence_matrix_internal_sample },
+        { "test_multiroot_divergence_matrix", test_multiroot_divergence_matrix },
+
         { NULL, NULL },
     };
     return test_main(tests, argc, argv);
diff --git a/tests/test_trees.c b/tests/test_trees.c
index 94e33ee..63b7292 100644
--- a/tests/test_trees.c
+++ b/tests/test_trees.c
@@ -175,6 +175,97 @@ verify_individual_nodes(tsk_treeseq_t *ts)
     }
 }
 
+static void
+verify_tree_pos(const tsk_treeseq_t *ts, tsk_size_t num_trees, tsk_id_t *tree_parents)
+{
+    int ret;
+    const tsk_size_t N = tsk_treeseq_get_num_nodes(ts);
+    const tsk_id_t *edges_parent = ts->tables->edges.parent;
+    const tsk_id_t *edges_child = ts->tables->edges.child;
+    tsk_tree_position_t tree_pos;
+    tsk_id_t *known_parent;
+    tsk_id_t *parent = tsk_malloc(N * sizeof(*parent));
+    tsk_id_t u, index, j, e;
+    bool valid;
+
+    CU_ASSERT_FATAL(parent != NULL);
+
+    ret = tsk_tree_position_init(&tree_pos, ts, 0);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+
+    for (u = 0; u < (tsk_id_t) N; u++) {
+        parent[u] = TSK_NULL;
+    }
+
+    for (index = 0; index < (tsk_id_t) num_trees; index++) {
+        known_parent = tree_parents + N * (tsk_size_t) index;
+
+        valid = tsk_tree_position_next(&tree_pos);
+        CU_ASSERT_TRUE(valid);
+        CU_ASSERT_EQUAL(index, tree_pos.index);
+
+        for (j = tree_pos.out.start; j < tree_pos.out.stop; j++) {
+            e = tree_pos.out.order[j];
+            parent[edges_child[e]] = TSK_NULL;
+        }
+
+        for (j = tree_pos.in.start; j < tree_pos.in.stop; j++) {
+            e = tree_pos.in.order[j];
+            parent[edges_child[e]] = edges_parent[e];
+        }
+
+        for (u = 0; u < (tsk_id_t) N; u++) {
+            CU_ASSERT_EQUAL(parent[u], known_parent[u]);
+        }
+    }
+
+    valid = tsk_tree_position_next(&tree_pos);
+    CU_ASSERT_FALSE(valid);
+    for (j = tree_pos.out.start; j < tree_pos.out.stop; j++) {
+        e = tree_pos.out.order[j];
+        parent[edges_child[e]] = TSK_NULL;
+    }
+    for (u = 0; u < (tsk_id_t) N; u++) {
+        CU_ASSERT_EQUAL(parent[u], TSK_NULL);
+    }
+
+    for (index = (tsk_id_t) num_trees - 1; index >= 0; index--) {
+        known_parent = tree_parents + N * (tsk_size_t) index;
+
+        valid = tsk_tree_position_prev(&tree_pos);
+        CU_ASSERT_TRUE(valid);
+        CU_ASSERT_EQUAL(index, tree_pos.index);
+
+        for (j = tree_pos.out.start; j > tree_pos.out.stop; j--) {
+            e = tree_pos.out.order[j];
+            parent[edges_child[e]] = TSK_NULL;
+        }
+
+        for (j = tree_pos.in.start; j > tree_pos.in.stop; j--) {
+            CU_ASSERT_FATAL(j >= 0);
+            e = tree_pos.in.order[j];
+            parent[edges_child[e]] = edges_parent[e];
+        }
+
+        for (u = 0; u < (tsk_id_t) N; u++) {
+            CU_ASSERT_EQUAL(parent[u], known_parent[u]);
+        }
+    }
+
+    valid = tsk_tree_position_prev(&tree_pos);
+    CU_ASSERT_FALSE(valid);
+    for (j = tree_pos.out.start; j > tree_pos.out.stop; j--) {
+        e = tree_pos.out.order[j];
+        parent[edges_child[e]] = TSK_NULL;
+    }
+    for (u = 0; u < (tsk_id_t) N; u++) {
+        CU_ASSERT_EQUAL(parent[u], TSK_NULL);
+    }
+
+    tsk_tree_position_free(&tree_pos);
+    tsk_safe_free(parent);
+}
+
 static void
 verify_trees(tsk_treeseq_t *ts, tsk_size_t num_trees, tsk_id_t *parents)
 {
@@ -233,6 +324,8 @@ verify_trees(tsk_treeseq_t *ts, tsk_size_t num_trees, tsk_id_t *parents)
     CU_ASSERT_EQUAL(tsk_treeseq_get_sequence_length(ts), breakpoints[j]);
 
     tsk_tree_free(&tree);
+
+    verify_tree_pos(ts, num_trees, parents);
 }
 
 static tsk_tree_t *
@@ -5233,6 +5326,65 @@ test_single_tree_tracked_samples(void)
     tsk_tree_free(&tree);
 }
 
+static void
+test_single_tree_tree_pos(void)
+{
+    tsk_treeseq_t ts;
+    tsk_tree_position_t tree_pos;
+    bool valid;
+    int ret;
+
+    tsk_treeseq_from_text(&ts, 1, single_tree_ex_nodes, single_tree_ex_edges, NULL, NULL,
+        NULL, NULL, NULL, 0);
+
+    ret = tsk_tree_position_init(&tree_pos, &ts, 0);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+    valid = tsk_tree_position_next(&tree_pos);
+    CU_ASSERT_FATAL(valid);
+
+    CU_ASSERT_EQUAL_FATAL(tree_pos.interval.left, 0);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.interval.right, 1);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.in.start, 0);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.in.stop, 6);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.in.order, ts.tables->indexes.edge_insertion_order);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.start, 0);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.stop, 0);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.order, ts.tables->indexes.edge_removal_order);
+
+    valid = tsk_tree_position_next(&tree_pos);
+    CU_ASSERT_FATAL(!valid);
+
+    tsk_tree_position_print_state(&tree_pos, _devnull);
+
+    CU_ASSERT_EQUAL_FATAL(tree_pos.index, -1);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.start, 0);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.stop, 6);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.order, ts.tables->indexes.edge_removal_order);
+
+    valid = tsk_tree_position_prev(&tree_pos);
+    CU_ASSERT_FATAL(valid);
+
+    CU_ASSERT_EQUAL_FATAL(tree_pos.interval.left, 0);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.interval.right, 1);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.in.start, 5);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.in.stop, -1);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.in.order, ts.tables->indexes.edge_removal_order);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.start, 5);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.stop, 5);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.order, ts.tables->indexes.edge_insertion_order);
+
+    valid = tsk_tree_position_prev(&tree_pos);
+    CU_ASSERT_FATAL(!valid);
+
+    CU_ASSERT_EQUAL_FATAL(tree_pos.index, -1);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.start, 5);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.stop, -1);
+    CU_ASSERT_EQUAL_FATAL(tree_pos.out.order, ts.tables->indexes.edge_insertion_order);
+
+    tsk_tree_position_free(&tree_pos);
+    tsk_treeseq_free(&ts);
+}
+
 /*=======================================================
  * Multi tree tests.
  *======================================================*/
@@ -5395,7 +5547,6 @@ test_simplify_keep_input_roots_multi_tree(void)
 
     tsk_treeseq_from_text(&ts, 10, paper_ex_nodes, paper_ex_edges, NULL, paper_ex_sites,
         paper_ex_mutations, paper_ex_individuals, NULL, 0);
-    tsk_treeseq_dump(&ts, "tmp.trees", 0);
     ret = tsk_treeseq_simplify(
         &ts, samples, 2, TSK_SIMPLIFY_KEEP_INPUT_ROOTS, &simplified, NULL);
     CU_ASSERT_EQUAL_FATAL(ret, 0);
@@ -7801,7 +7952,7 @@ test_time_uncalibrated(void)
     tsk_size_t sample_set_sizes[] = { 2, 2 };
     tsk_id_t samples[] = { 0, 1, 2, 3 };
     tsk_size_t num_samples;
-    double result[10];
+    double result[100];
     double *W;
     double *sigma;
 
@@ -7857,6 +8008,12 @@ test_time_uncalibrated(void)
         TSK_STAT_BRANCH | TSK_STAT_ALLOW_TIME_UNCALIBRATED, sigma);
     CU_ASSERT_EQUAL_FATAL(ret, 0);
 
+    ret = tsk_treeseq_divergence_matrix(&ts2, 0, NULL, 0, NULL, TSK_STAT_BRANCH, result);
+    CU_ASSERT_EQUAL_FATAL(ret, TSK_ERR_TIME_UNCALIBRATED);
+    ret = tsk_treeseq_divergence_matrix(&ts2, 0, NULL, 0, NULL,
+        TSK_STAT_BRANCH | TSK_STAT_ALLOW_TIME_UNCALIBRATED, result);
+    CU_ASSERT_EQUAL_FATAL(ret, 0);
+
     tsk_safe_free(W);
     tsk_safe_free(sigma);
     tsk_treeseq_free(&ts);
@@ -8180,6 +8337,7 @@ main(int argc, char **argv)
         { "test_single_tree_map_mutations_internal_samples",
             test_single_tree_map_mutations_internal_samples },
         { "test_single_tree_tracked_samples", test_single_tree_tracked_samples },
+        { "test_single_tree_tree_pos", test_single_tree_tree_pos },
 
         /* Multi tree tests */
         { "test_simple_multi_tree", test_simple_multi_tree },
diff --git a/tests/testlib.c b/tests/testlib.c
index 823068d..043ae5c 100644
--- a/tests/testlib.c
+++ b/tests/testlib.c
@@ -1,7 +1,7 @@
 /*
  * MIT License
  *
- * Copyright (c) 2019-2022 Tskit Developers
+ * Copyright (c) 2019-2023 Tskit Developers
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -966,6 +966,16 @@ tskit_suite_init(void)
     return CUE_SUCCESS;
 }
 
+void
+assert_arrays_almost_equal(tsk_size_t len, double *a, double *b)
+{
+    tsk_size_t j;
+
+    for (j = 0; j < len; j++) {
+        CU_ASSERT_DOUBLE_EQUAL(a[j], b[j], 1e-9);
+    }
+}
+
 static int
 tskit_suite_cleanup(void)
 {
diff --git a/tests/testlib.h b/tests/testlib.h
index d042d60..69efb14 100644
--- a/tests/testlib.h
+++ b/tests/testlib.h
@@ -1,7 +1,7 @@
 /*
  * MIT License
  *
- * Copyright (c) 2019-2021 Tskit Developers
+ * Copyright (c) 2019-2023 Tskit Developers
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -54,6 +54,8 @@ void parse_individuals(const char *text, tsk_individual_table_t *individual_tabl
 
 void unsort_edges(tsk_edge_table_t *edges, size_t start);
 
+void assert_arrays_almost_equal(tsk_size_t len, double *a, double *b);
+
 extern const char *single_tree_ex_nodes;
 extern const char *single_tree_ex_edges;
 extern const char *single_tree_ex_sites;
diff --git a/tskit/core.c b/tskit/core.c
index b1ea25b..44be974 100644
--- a/tskit/core.c
+++ b/tskit/core.c
@@ -466,6 +466,19 @@ tsk_strerror_internal(int err)
             ret = "Statistics using branch lengths cannot be calculated when time_units "
                   "is 'uncalibrated'. (TSK_ERR_TIME_UNCALIBRATED)";
             break;
+        case TSK_ERR_STAT_POLARISED_UNSUPPORTED:
+            ret = "The TSK_STAT_POLARISED option is not supported by this statistic. "
+                  "(TSK_ERR_STAT_POLARISED_UNSUPPORTED)";
+            break;
+        case TSK_ERR_STAT_SPAN_NORMALISE_UNSUPPORTED:
+            ret = "The TSK_STAT_SPAN_NORMALISE option is not supported by this "
+                  "statistic. "
+                  "(TSK_ERR_STAT_SPAN_NORMALISE_UNSUPPORTED)";
+            break;
+        case TSK_ERR_INSUFFICIENT_WEIGHTS:
+            ret = "Insufficient weights provided (at least 1 required). "
+                  "(TSK_ERR_INSUFFICIENT_WEIGHTS)";
+            break;
 
         /* Mutation mapping errors */
         case TSK_ERR_GENOTYPES_ALL_MISSING:
@@ -1164,3 +1177,101 @@ tsk_avl_tree_int_ordered_nodes(const tsk_avl_tree_int_t *self, tsk_avl_node_int_
     ordered_nodes_traverse(self->head.rlink, 0, out);
     return 0;
 }
+
+// Bit Array implementation. Allows us to store unsigned integers in a compact manner.
+// Currently implemented as an array of 32-bit unsigned integers for ease of counting.
+
+int
+tsk_bit_array_init(tsk_bit_array_t *self, tsk_size_t num_bits, tsk_size_t length)
+{
+    int ret = 0;
+
+    self->size = (num_bits >> TSK_BIT_ARRAY_CHUNK)
+                 + (num_bits % TSK_BIT_ARRAY_NUM_BITS ? 1 : 0);
+    self->data = tsk_calloc(self->size * length, sizeof(*self->data));
+    if (self->data == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+out:
+    return ret;
+}
+
+void
+tsk_bit_array_get_row(const tsk_bit_array_t *self, tsk_size_t row, tsk_bit_array_t *out)
+{
+    out->size = self->size;
+    out->data = self->data + (row * self->size);
+}
+
+void
+tsk_bit_array_intersect(
+    const tsk_bit_array_t *self, const tsk_bit_array_t *other, tsk_bit_array_t *out)
+{
+    for (tsk_size_t i = 0; i < self->size; i++) {
+        out->data[i] = self->data[i] & other->data[i];
+    }
+}
+
+void
+tsk_bit_array_subtract(tsk_bit_array_t *self, const tsk_bit_array_t *other)
+{
+    for (tsk_size_t i = 0; i < self->size; i++) {
+        self->data[i] &= ~(other->data[i]);
+    }
+}
+
+void
+tsk_bit_array_add(tsk_bit_array_t *self, const tsk_bit_array_t *other)
+{
+    for (tsk_size_t i = 0; i < self->size; i++) {
+        self->data[i] |= other->data[i];
+    }
+}
+
+void
+tsk_bit_array_add_bit(tsk_bit_array_t *self, const tsk_bit_array_value_t bit)
+{
+    tsk_bit_array_value_t i = bit >> TSK_BIT_ARRAY_CHUNK;
+    self->data[i] |= (tsk_bit_array_value_t) 1 << (bit - (TSK_BIT_ARRAY_NUM_BITS * i));
+}
+
+bool
+tsk_bit_array_contains(const tsk_bit_array_t *self, const tsk_bit_array_value_t bit)
+{
+    tsk_bit_array_value_t i = bit >> TSK_BIT_ARRAY_CHUNK;
+    return self->data[i]
+           & ((tsk_bit_array_value_t) 1 << (bit - (TSK_BIT_ARRAY_NUM_BITS * i)));
+}
+
+tsk_size_t
+tsk_bit_array_count(const tsk_bit_array_t *self)
+{
+    // Utilizes 12 operations per bit array. NB this only works on 32 bit integers.
+    // Taken from:
+    //   https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
+    // There's a nice breakdown of this algorithm here:
+    //   https://stackoverflow.com/a/109025
+    // Could probably do better with explicit SIMD (instead of SWAR), but not as
+    // portable: https://arxiv.org/pdf/1611.07612.pdf
+    //
+    // There is one solution to explore further, which uses __builtin_popcountll.
+    // This option is relatively simple, but requires a 64 bit bit array and also
+    // involves some compiler flag plumbing (-mpopcnt)
+
+    tsk_bit_array_value_t tmp;
+    tsk_size_t i, count = 0;
+
+    for (i = 0; i < self->size; i++) {
+        tmp = self->data[i] - ((self->data[i] >> 1) & 0x55555555);
+        tmp = (tmp & 0x33333333) + ((tmp >> 2) & 0x33333333);
+        count += (((tmp + (tmp >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
+    }
+    return count;
+}
+
+void
+tsk_bit_array_free(tsk_bit_array_t *self)
+{
+    tsk_safe_free(self->data);
+}
diff --git a/tskit/core.h b/tskit/core.h
index b8b9f35..a10f437 100644
--- a/tskit/core.h
+++ b/tskit/core.h
@@ -675,6 +675,20 @@ Statistics based on branch lengths were attempted when the ``time_units``
 were ``uncalibrated``.
 */
 #define TSK_ERR_TIME_UNCALIBRATED                                   -910
+/**
+The TSK_STAT_POLARISED option was passed to a statistic that does
+not support it.
+*/
+#define TSK_ERR_STAT_POLARISED_UNSUPPORTED                          -911
+/**
+The TSK_STAT_SPAN_NORMALISE option was passed to a statistic that does
+not support it.
+*/
+#define TSK_ERR_STAT_SPAN_NORMALISE_UNSUPPORTED                     -912
+/**
+Insufficient weights were provided.
+*/
+#define TSK_ERR_INSUFFICIENT_WEIGHTS                                -913
 /** @} */
 
 /**
@@ -995,6 +1009,30 @@ int tsk_memcmp(const void *s1, const void *s2, tsk_size_t size);
 void tsk_set_debug_stream(FILE *f);
 FILE *tsk_get_debug_stream(void);
 
+/* Bit Array functionality */
+
+typedef uint32_t tsk_bit_array_value_t;
+typedef struct {
+    tsk_size_t size;             // Number of chunks per row
+    tsk_bit_array_value_t *data; // Array data
+} tsk_bit_array_t;
+
+#define TSK_BIT_ARRAY_CHUNK 5U
+#define TSK_BIT_ARRAY_NUM_BITS (1U << TSK_BIT_ARRAY_CHUNK)
+
+int tsk_bit_array_init(tsk_bit_array_t *self, tsk_size_t num_bits, tsk_size_t length);
+void tsk_bit_array_free(tsk_bit_array_t *self);
+void tsk_bit_array_get_row(
+    const tsk_bit_array_t *self, tsk_size_t row, tsk_bit_array_t *out);
+void tsk_bit_array_intersect(
+    const tsk_bit_array_t *self, const tsk_bit_array_t *other, tsk_bit_array_t *out);
+void tsk_bit_array_subtract(tsk_bit_array_t *self, const tsk_bit_array_t *other);
+void tsk_bit_array_add(tsk_bit_array_t *self, const tsk_bit_array_t *other);
+void tsk_bit_array_add_bit(tsk_bit_array_t *self, const tsk_bit_array_value_t bit);
+bool tsk_bit_array_contains(
+    const tsk_bit_array_t *self, const tsk_bit_array_value_t bit);
+tsk_size_t tsk_bit_array_count(const tsk_bit_array_t *self);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/tskit/haplotype_matching.c b/tskit/haplotype_matching.c
index b942da1..d6fdfd7 100644
--- a/tskit/haplotype_matching.c
+++ b/tskit/haplotype_matching.c
@@ -209,7 +209,7 @@ int
 tsk_ls_hmm_free(tsk_ls_hmm_t *self)
 {
     tsk_tree_free(&self->tree);
-    tsk_diff_iter_free(&self->diffs);
+    tsk_tree_position_free(&self->tree_pos);
     tsk_safe_free(self->recombination_rate);
     tsk_safe_free(self->mutation_rate);
     tsk_safe_free(self->recombination_rate);
@@ -248,9 +248,8 @@ tsk_ls_hmm_reset(tsk_ls_hmm_t *self)
     tsk_memset(self->transition_parent, 0xff,
         self->max_transitions * sizeof(*self->transition_parent));
 
-    /* This is safe because we've already zero'd out the memory. */
-    tsk_diff_iter_free(&self->diffs);
-    ret = tsk_diff_iter_init_from_ts(&self->diffs, self->tree_sequence, false);
+    tsk_tree_position_free(&self->tree_pos);
+    ret = tsk_tree_position_init(&self->tree_pos, self->tree_sequence, 0);
     if (ret != 0) {
         goto out;
     }
@@ -306,21 +305,20 @@ tsk_ls_hmm_update_tree(tsk_ls_hmm_t *self)
     int ret = 0;
     tsk_id_t *restrict parent = self->parent;
     tsk_id_t *restrict T_index = self->transition_index;
+    const tsk_id_t *restrict edges_child = self->tree_sequence->tables->edges.child;
+    const tsk_id_t *restrict edges_parent = self->tree_sequence->tables->edges.parent;
     tsk_value_transition_t *restrict T = self->transitions;
-    tsk_edge_list_node_t *record;
-    tsk_edge_list_t records_out, records_in;
-    tsk_edge_t edge;
-    double left, right;
-    tsk_id_t u;
+    tsk_id_t u, c, p, j, e;
     tsk_value_transition_t *vt;
 
-    ret = tsk_diff_iter_next(&self->diffs, &left, &right, &records_out, &records_in);
-    if (ret < 0) {
-        goto out;
-    }
+    tsk_tree_position_next(&self->tree_pos);
+    tsk_bug_assert(self->tree_pos.index != -1);
+    tsk_bug_assert(self->tree_pos.index == self->tree.index);
 
-    for (record = records_out.head; record != NULL; record = record->next) {
-        u = record->edge.child;
+    for (j = self->tree_pos.out.start; j < self->tree_pos.out.stop; j++) {
+        e = self->tree_pos.out.order[j];
+        c = edges_child[e];
+        u = c;
         if (T_index[u] == TSK_NULL) {
             /* Ensure the subtree we're detaching has a transition at the root */
             while (T_index[u] == TSK_NULL) {
@@ -328,25 +326,27 @@ tsk_ls_hmm_update_tree(tsk_ls_hmm_t *self)
                 tsk_bug_assert(u != TSK_NULL);
             }
             tsk_bug_assert(self->num_transitions < self->max_transitions);
-            T_index[record->edge.child] = (tsk_id_t) self->num_transitions;
-            T[self->num_transitions].tree_node = record->edge.child;
+            T_index[c] = (tsk_id_t) self->num_transitions;
+            T[self->num_transitions].tree_node = c;
             T[self->num_transitions].value = T[T_index[u]].value;
             self->num_transitions++;
         }
-        parent[record->edge.child] = TSK_NULL;
+        parent[c] = TSK_NULL;
     }
 
-    for (record = records_in.head; record != NULL; record = record->next) {
-        edge = record->edge;
-        parent[edge.child] = edge.parent;
-        u = edge.parent;
-        if (parent[edge.parent] == TSK_NULL) {
+    for (j = self->tree_pos.in.start; j < self->tree_pos.in.stop; j++) {
+        e = self->tree_pos.in.order[j];
+        c = edges_child[e];
+        p = edges_parent[e];
+        parent[c] = p;
+        u = p;
+        if (parent[p] == TSK_NULL) {
             /* Grafting onto a new root. */
-            if (T_index[record->edge.parent] == TSK_NULL) {
-                T_index[edge.parent] = (tsk_id_t) self->num_transitions;
+            if (T_index[p] == TSK_NULL) {
+                T_index[p] = (tsk_id_t) self->num_transitions;
                 tsk_bug_assert(self->num_transitions < self->max_transitions);
-                T[self->num_transitions].tree_node = edge.parent;
-                T[self->num_transitions].value = T[T_index[edge.child]].value;
+                T[self->num_transitions].tree_node = p;
+                T[self->num_transitions].value = T[T_index[c]].value;
                 self->num_transitions++;
             }
         } else {
@@ -356,18 +356,17 @@ tsk_ls_hmm_update_tree(tsk_ls_hmm_t *self)
             }
             tsk_bug_assert(u != TSK_NULL);
         }
-        tsk_bug_assert(T_index[u] != -1 && T_index[edge.child] != -1);
-        if (T[T_index[u]].value == T[T_index[edge.child]].value) {
-            vt = &T[T_index[edge.child]];
+        tsk_bug_assert(T_index[u] != -1 && T_index[c] != -1);
+        if (T[T_index[u]].value == T[T_index[c]].value) {
+            vt = &T[T_index[c]];
             /* Mark the value transition as unusued */
             vt->value = -1;
             vt->tree_node = TSK_NULL;
-            T_index[edge.child] = TSK_NULL;
+            T_index[c] = TSK_NULL;
         }
     }
 
     ret = tsk_ls_hmm_remove_dead_roots(self);
-out:
     return ret;
 }
 
diff --git a/tskit/haplotype_matching.h b/tskit/haplotype_matching.h
index 46631fb..e4d82be 100644
--- a/tskit/haplotype_matching.h
+++ b/tskit/haplotype_matching.h
@@ -1,7 +1,7 @@
 /*
  * MIT License
  *
- * Copyright (c) 2019-2022 Tskit Developers
+ * Copyright (c) 2019-2023 Tskit Developers
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -98,7 +98,10 @@ typedef struct _tsk_ls_hmm_t {
     tsk_size_t num_nodes;
     /* state */
     tsk_tree_t tree;
-    tsk_diff_iter_t diffs;
+    /* NOTE: this tree_position will be redundant once we integrate the top-level
+     * tree class with this.
+     */
+    tsk_tree_position_t tree_pos;
     tsk_id_t *parent;
     /* The probability value transitions on the tree */
     tsk_value_transition_t *transitions;
diff --git a/tskit/trees.c b/tskit/trees.c
index 4604579..abe7d07 100644
--- a/tskit/trees.c
+++ b/tskit/trees.c
@@ -1191,9 +1191,11 @@ out:
  * General stats framework
  ***********************************/
 
+#define TSK_REQUIRE_FULL_SPAN 1
+
 static int
-tsk_treeseq_check_windows(
-    const tsk_treeseq_t *self, tsk_size_t num_windows, const double *windows)
+tsk_treeseq_check_windows(const tsk_treeseq_t *self, tsk_size_t num_windows,
+    const double *windows, tsk_flags_t options)
 {
     int ret = TSK_ERR_BAD_WINDOWS;
     tsk_size_t j;
@@ -1202,12 +1204,23 @@ tsk_treeseq_check_windows(
         ret = TSK_ERR_BAD_NUM_WINDOWS;
         goto out;
     }
-    /* TODO these restrictions can be lifted later if we want a specific interval. */
-    if (windows[0] != 0) {
-        goto out;
-    }
-    if (windows[num_windows] != self->tables->sequence_length) {
-        goto out;
+    if (options & TSK_REQUIRE_FULL_SPAN) {
+        /* TODO the general stat code currently requires that we include the
+         * entire tree sequence span. This should be relaxed, so hopefully
+         * this branch (and the option) can be removed at some point */
+        if (windows[0] != 0) {
+            goto out;
+        }
+        if (windows[num_windows] != self->tables->sequence_length) {
+            goto out;
+        }
+    } else {
+        if (windows[0] < 0) {
+            goto out;
+        }
+        if (windows[num_windows] > self->tables->sequence_length) {
+            goto out;
+        }
     }
     for (j = 0; j < num_windows; j++) {
         if (windows[j] >= windows[j + 1]) {
@@ -1470,7 +1483,7 @@ get_allele_weights(const tsk_site_t *site, const double *state, tsk_size_t state
             allele_row[k] += state_row[k];
         }
 
-        /* Get the index for the alternate allele that we must substract from */
+        /* Get the index for the alternate allele that we must subtract from */
         alt_allele = site->ancestral_state;
         alt_allele_length = site->ancestral_state_length;
         if (mutation.parent != TSK_NULL) {
@@ -1960,7 +1973,8 @@ tsk_treeseq_general_stat(const tsk_treeseq_t *self, tsk_size_t state_dim,
         num_windows = 1;
         windows = default_windows;
     } else {
-        ret = tsk_treeseq_check_windows(self, num_windows, windows);
+        ret = tsk_treeseq_check_windows(
+            self, num_windows, windows, TSK_REQUIRE_FULL_SPAN);
         if (ret != 0) {
             goto out;
         }
@@ -2057,6 +2071,11 @@ typedef struct {
     const tsk_id_t *set_indexes;
 } sample_count_stat_params_t;
 
+typedef struct {
+    double *total_weights;
+    const tsk_id_t *index_tuples;
+} indexed_weight_stat_params_t;
+
 static int
 tsk_treeseq_sample_count_stat(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
     const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
@@ -2106,3603 +2125,5253 @@ out:
 }
 
 /***********************************
- * Allele frequency spectrum
+ * Two Locus Statistics
  ***********************************/
 
-static inline void
-fold(tsk_size_t *restrict coordinate, const tsk_size_t *restrict dims,
-    tsk_size_t num_dims)
-{
-    tsk_size_t k;
-    double n = 0;
-    int s = 0;
-
-    for (k = 0; k < num_dims; k++) {
-        tsk_bug_assert(coordinate[k] < dims[k]);
-        n += (double) dims[k] - 1;
-        s += (int) coordinate[k];
-    }
-    n /= 2;
-    k = num_dims;
-    while (s == n && k > 0) {
-        k--;
-        n -= ((double) (dims[k] - 1)) / 2;
-        s -= (int) coordinate[k];
-    }
-    if (s > n) {
-        for (k = 0; k < num_dims; k++) {
-            s = (int) (dims[k] - 1 - coordinate[k]);
-            tsk_bug_assert(s >= 0);
-            coordinate[k] = (tsk_size_t) s;
-        }
-    }
-}
-
 static int
-tsk_treeseq_update_site_afs(const tsk_treeseq_t *self, const tsk_site_t *site,
-    const double *total_counts, const double *counts, tsk_size_t num_sample_sets,
-    tsk_size_t window_index, tsk_size_t *result_dims, tsk_flags_t options,
-    double *result)
+get_allele_samples(const tsk_site_t *site, const tsk_bit_array_t *state,
+    tsk_bit_array_t *out_allele_samples, tsk_size_t *out_num_alleles)
 {
     int ret = 0;
-    tsk_size_t afs_size;
-    tsk_size_t k, allele, num_alleles, all_samples;
-    double increment, *afs, *allele_counts, *allele_count;
-    tsk_size_t *coordinate = tsk_malloc(num_sample_sets * sizeof(*coordinate));
-    bool polarised = !!(options & TSK_STAT_POLARISED);
-    const tsk_size_t K = num_sample_sets + 1;
+    tsk_mutation_t mutation, parent_mut;
+    tsk_size_t mutation_index, allele, alt_allele_length;
+    /* The allele table */
+    tsk_size_t max_alleles = site->mutations_length + 1;
+    const char **alleles = tsk_malloc(max_alleles * sizeof(*alleles));
+    tsk_size_t *allele_lengths = tsk_calloc(max_alleles, sizeof(*allele_lengths));
+    const char *alt_allele;
+    tsk_bit_array_t state_row;
+    tsk_bit_array_t allele_samples_row;
+    tsk_bit_array_t alt_allele_samples_row;
+    tsk_size_t num_alleles = 1;
 
-    if (coordinate == NULL) {
+    if (alleles == NULL || allele_lengths == NULL) {
         ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
-    ret = get_allele_weights(
-        site, counts, K, total_counts, &num_alleles, &allele_counts);
-    if (ret != 0) {
-        goto out;
-    }
 
-    afs_size = result_dims[num_sample_sets];
-    afs = result + afs_size * window_index;
+    tsk_bug_assert(state != NULL);
+    alleles[0] = site->ancestral_state;
+    allele_lengths[0] = site->ancestral_state_length;
 
-    increment = polarised ? 1 : 0.5;
-    /* Sum over the allele weights. Skip the ancestral state if polarised. */
-    for (allele = polarised ? 1 : 0; allele < num_alleles; allele++) {
-        allele_count = GET_2D_ROW(allele_counts, K, allele);
-        all_samples = (tsk_size_t) allele_count[num_sample_sets];
-        if (all_samples > 0 && all_samples < self->num_samples) {
-            for (k = 0; k < num_sample_sets; k++) {
-                coordinate[k] = (tsk_size_t) allele_count[k];
+    for (mutation_index = 0; mutation_index < site->mutations_length; mutation_index++) {
+        mutation = site->mutations[mutation_index];
+        /* Compute the allele index for this derived state value. */
+        for (allele = 0; allele < num_alleles; allele++) {
+            if (mutation.derived_state_length == allele_lengths[allele]
+                && tsk_memcmp(
+                       mutation.derived_state, alleles[allele], allele_lengths[allele])
+                       == 0) {
+                break;
             }
-            if (!polarised) {
-                fold(coordinate, result_dims, num_sample_sets);
+        }
+        if (allele == num_alleles) {
+            tsk_bug_assert(allele < max_alleles);
+            alleles[allele] = mutation.derived_state;
+            allele_lengths[allele] = mutation.derived_state_length;
+            num_alleles++;
+        }
+
+        /* Add the mutation's samples to this allele */
+        tsk_bit_array_get_row(out_allele_samples, allele, &allele_samples_row);
+        tsk_bit_array_get_row(state, mutation_index, &state_row);
+        tsk_bit_array_add(&allele_samples_row, &state_row);
+
+        /* Get the index for the alternate allele that we must subtract from */
+        alt_allele = site->ancestral_state;
+        alt_allele_length = site->ancestral_state_length;
+        if (mutation.parent != TSK_NULL) {
+            parent_mut = site->mutations[mutation.parent - site->mutations[0].id];
+            alt_allele = parent_mut.derived_state;
+            alt_allele_length = parent_mut.derived_state_length;
+        }
+        for (allele = 0; allele < num_alleles; allele++) {
+            if (alt_allele_length == allele_lengths[allele]
+                && tsk_memcmp(alt_allele, alleles[allele], allele_lengths[allele])
+                       == 0) {
+                break;
             }
-            increment_nd_array_value(
-                afs, num_sample_sets, result_dims, coordinate, increment);
         }
+        tsk_bug_assert(allele < num_alleles);
+
+        tsk_bit_array_get_row(out_allele_samples, allele, &alt_allele_samples_row);
+        tsk_bit_array_subtract(&alt_allele_samples_row, &allele_samples_row);
     }
+    *out_num_alleles = num_alleles;
 out:
-    tsk_safe_free(coordinate);
-    tsk_safe_free(allele_counts);
+    tsk_safe_free(alleles);
+    tsk_safe_free(allele_lengths);
     return ret;
 }
 
 static int
-tsk_treeseq_site_allele_frequency_spectrum(const tsk_treeseq_t *self,
-    tsk_size_t num_sample_sets, const tsk_size_t *sample_set_sizes, double *counts,
-    tsk_size_t num_windows, const double *windows, tsk_size_t *result_dims,
-    tsk_flags_t options, double *result)
+get_mutation_samples(const tsk_tree_t *self, const tsk_size_t *site_offsets,
+    tsk_bit_array_t *allele_samples, tsk_size_t **num_alleles)
 {
     int ret = 0;
-    tsk_id_t u, v;
-    tsk_size_t tree_site, tree_index, window_index;
-    tsk_size_t num_nodes = self->tables->nodes.num_rows;
-    const tsk_id_t num_edges = (tsk_id_t) self->tables->edges.num_rows;
-    const tsk_id_t *restrict I = self->tables->indexes.edge_insertion_order;
-    const tsk_id_t *restrict O = self->tables->indexes.edge_removal_order;
-    const double *restrict edge_left = self->tables->edges.left;
-    const double *restrict edge_right = self->tables->edges.right;
-    const tsk_id_t *restrict edge_parent = self->tables->edges.parent;
-    const tsk_id_t *restrict edge_child = self->tables->edges.child;
-    const double sequence_length = self->tables->sequence_length;
-    tsk_id_t *restrict parent = tsk_malloc(num_nodes * sizeof(*parent));
-    tsk_site_t *site;
-    tsk_id_t tj, tk, h;
-    tsk_size_t j;
-    const tsk_size_t K = num_sample_sets + 1;
-    double t_left, t_right;
-    double *total_counts = tsk_malloc((1 + num_sample_sets) * sizeof(*total_counts));
 
-    if (parent == NULL || total_counts == NULL) {
+    const tsk_treeseq_t *restrict ts = self->tree_sequence;
+
+    const tsk_size_t num_samples = tsk_treeseq_get_num_samples(ts);
+    const tsk_size_t num_tree_sites = ts->tree_sites_length[self->index];
+    const tsk_site_t *restrict tree_sites = ts->tree_sites[self->index];
+    const tsk_flags_t *restrict flags = ts->tables->nodes.flags;
+    const tsk_id_t *restrict mut_nodes = ts->tables->mutations.node;
+
+    const tsk_site_t *restrict site;
+
+    tsk_bit_array_t mut_samples, mut_samples_row, out_row;
+    tsk_size_t num_mutations, mut_samples_offset, mut_offset;
+    tsk_size_t s, m, n;
+
+    tsk_memset(&mut_samples, 0, sizeof(mut_samples));
+
+    tsk_id_t node;
+    tsk_size_t num_nodes;
+    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
+
+    if (nodes == NULL) {
         ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
-    tsk_memset(parent, 0xff, num_nodes * sizeof(*parent));
 
-    for (j = 0; j < num_sample_sets; j++) {
-        total_counts[j] = (double) sample_set_sizes[j];
+    // Get the number of mutations
+    num_mutations = 0;
+    for (s = 0; s < num_tree_sites; s++) {
+        site = &tree_sites[s];
+        num_mutations += site->mutations_length;
     }
-    total_counts[num_sample_sets] = (double) self->num_samples;
 
-    /* Iterate over the trees */
-    tj = 0;
-    tk = 0;
-    t_left = 0;
-    tree_index = 0;
-    window_index = 0;
-    while (tj < num_edges || t_left < sequence_length) {
-        while (tk < num_edges && edge_right[O[tk]] == t_left) {
-            h = O[tk];
-            tk++;
-            u = edge_child[h];
-            v = edge_parent[h];
-            while (v != TSK_NULL) {
-                update_state(counts, K, v, u, -1);
-                v = parent[v];
-            }
-            parent[u] = TSK_NULL;
-        }
+    ret = tsk_bit_array_init(&mut_samples, num_samples, num_mutations);
+    if (ret != 0) {
+        goto out;
+    }
 
-        while (tj < num_edges && edge_left[I[tj]] == t_left) {
-            h = I[tj];
-            tj++;
-            u = edge_child[h];
-            v = edge_parent[h];
-            parent[u] = v;
-            while (v != TSK_NULL) {
-                update_state(counts, K, v, u, +1);
-                v = parent[v];
-            }
-        }
-        t_right = sequence_length;
-        if (tj < num_edges) {
-            t_right = TSK_MIN(t_right, edge_left[I[tj]]);
-        }
-        if (tk < num_edges) {
-            t_right = TSK_MIN(t_right, edge_right[O[tk]]);
+    // Current position minus num ancestral alleles to this point, if there are any sites
+    mut_offset = num_tree_sites
+                     ? (site_offsets[tree_sites[0].id] - (tsk_size_t) tree_sites[0].id)
+                     : 0;
+
+    // Traverse down the tree, recording all samples below each mutation.
+    // We currently perform one preorder traversal per mutation, but there
+    // might be more clever ways to do this. The preorder traversals begin at
+    // the focal mutation's node.
+    for (m = 0; m < num_mutations; m++) {
+        tsk_bit_array_get_row(&mut_samples, m, &mut_samples_row);
+
+        ret = tsk_tree_preorder_from(self, mut_nodes[m + mut_offset], nodes, &num_nodes);
+        if (ret != 0) {
+            goto out;
         }
 
-        /* Update the sites */
-        for (tree_site = 0; tree_site < self->tree_sites_length[tree_index];
-             tree_site++) {
-            site = self->tree_sites[tree_index] + tree_site;
-            while (windows[window_index + 1] <= site->position) {
-                window_index++;
-                tsk_bug_assert(window_index < num_windows);
-            }
-            ret = tsk_treeseq_update_site_afs(self, site, total_counts, counts,
-                num_sample_sets, window_index, result_dims, options, result);
-            if (ret != 0) {
-                goto out;
+        for (n = 0; n < num_nodes; n++) {
+            node = nodes[n];
+            if (flags[node] & TSK_NODE_IS_SAMPLE) {
+                tsk_bit_array_add_bit(&mut_samples_row, (tsk_bit_array_value_t) node);
             }
-            tsk_bug_assert(windows[window_index] <= site->position);
-            tsk_bug_assert(site->position < windows[window_index + 1]);
         }
-        tree_index++;
-        t_left = t_right;
     }
-out:
-    /* Can't use msp_safe_free here because of restrict */
-    if (parent != NULL) {
-        free(parent);
+
+    mut_samples_offset = 0;
+    for (s = 0; s < num_tree_sites; s++) {
+        site = &tree_sites[s];
+
+        tsk_bit_array_get_row(&mut_samples, mut_samples_offset, &mut_samples_row);
+        mut_samples_offset += site->mutations_length;
+
+        tsk_bit_array_get_row(allele_samples, site_offsets[site->id], &out_row);
+        get_allele_samples(site, &mut_samples_row, &out_row, &(*num_alleles)[site->id]);
     }
-    tsk_safe_free(total_counts);
+out:
+    tsk_bit_array_free(&mut_samples);
+    tsk_safe_free(nodes);
+
     return ret;
 }
 
-static int TSK_WARN_UNUSED
-tsk_treeseq_update_branch_afs(const tsk_treeseq_t *self, tsk_id_t u, double right,
-    const double *restrict branch_length, double *restrict last_update,
-    const double *counts, tsk_size_t num_sample_sets, tsk_size_t window_index,
-    const tsk_size_t *result_dims, tsk_flags_t options, double *result)
+static int
+norm_hap_weighted(tsk_size_t state_dim, const double *hap_weights,
+    tsk_size_t TSK_UNUSED(n_a), tsk_size_t TSK_UNUSED(n_b), double *result, void *params)
 {
-    int ret = 0;
-    tsk_size_t afs_size;
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *weight_row;
+    double n;
     tsk_size_t k;
-    double *afs;
-    tsk_size_t *coordinate = tsk_malloc(num_sample_sets * sizeof(*coordinate));
-    bool polarised = !!(options & TSK_STAT_POLARISED);
-    const double *count_row = GET_2D_ROW(counts, num_sample_sets + 1, u);
-    double x = (right - last_update[u]) * branch_length[u];
-    const tsk_size_t all_samples = (tsk_size_t) count_row[num_sample_sets];
 
-    if (coordinate == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
+    for (k = 0; k < state_dim; k++) {
+        weight_row = GET_2D_ROW(hap_weights, 3, k);
+        n = (double) args.sample_set_sizes[k];
+        // TODO: what to do when n = 0
+        result[k] = weight_row[0] / n;
     }
+    return 0;
+}
 
-    if (0 < all_samples && all_samples < self->num_samples) {
-        if (!polarised) {
-            x *= 0.5;
-        }
-        afs_size = result_dims[num_sample_sets];
-        afs = result + afs_size * window_index;
-        for (k = 0; k < num_sample_sets; k++) {
-            coordinate[k] = (tsk_size_t) count_row[k];
-        }
-        if (!polarised) {
-            fold(coordinate, result_dims, num_sample_sets);
-        }
-        increment_nd_array_value(afs, num_sample_sets, result_dims, coordinate, x);
+static int
+norm_total_weighted(tsk_size_t state_dim, const double *TSK_UNUSED(hap_weights),
+    tsk_size_t n_a, tsk_size_t n_b, double *result, void *TSK_UNUSED(params))
+{
+    tsk_size_t k;
+
+    for (k = 0; k < state_dim; k++) {
+        result[k] = 1 / (double) (n_a * n_b);
+    }
+    return 0;
+}
+
+static void
+get_all_samples_bits(tsk_bit_array_t *all_samples, tsk_size_t n)
+{
+    tsk_size_t i;
+    const tsk_bit_array_value_t all = ~((tsk_bit_array_value_t) 0);
+    const tsk_bit_array_value_t remainder_samples = n % TSK_BIT_ARRAY_NUM_BITS;
+
+    all_samples->data[all_samples->size - 1]
+        = remainder_samples ? ~(all << remainder_samples) : all;
+    for (i = 0; i < all_samples->size - 1; i++) {
+        all_samples->data[i] = all;
     }
-    last_update[u] = right;
-out:
-    tsk_safe_free(coordinate);
-    return ret;
 }
 
+typedef int norm_func_t(tsk_size_t state_dim, const double *hap_weights, tsk_size_t n_a,
+    tsk_size_t n_b, double *result, void *params);
+
 static int
-tsk_treeseq_branch_allele_frequency_spectrum(const tsk_treeseq_t *self,
-    tsk_size_t num_sample_sets, double *counts, tsk_size_t num_windows,
-    const double *windows, const tsk_size_t *result_dims, tsk_flags_t options,
+compute_general_two_site_stat_result(const tsk_bit_array_t *site_a_state,
+    const tsk_bit_array_t *site_b_state, tsk_size_t num_a_alleles,
+    tsk_size_t num_b_alleles, tsk_size_t num_samples, tsk_size_t state_dim,
+    const tsk_bit_array_t *sample_sets, tsk_size_t result_dim, general_stat_func_t *f,
+    sample_count_stat_params_t *f_params, norm_func_t *norm_f, bool polarised,
     double *result)
 {
     int ret = 0;
-    tsk_id_t u, v;
-    tsk_size_t window_index;
-    tsk_size_t num_nodes = self->tables->nodes.num_rows;
-    const tsk_id_t num_edges = (tsk_id_t) self->tables->edges.num_rows;
-    const tsk_id_t *restrict I = self->tables->indexes.edge_insertion_order;
-    const tsk_id_t *restrict O = self->tables->indexes.edge_removal_order;
-    const double *restrict edge_left = self->tables->edges.left;
-    const double *restrict edge_right = self->tables->edges.right;
-    const tsk_id_t *restrict edge_parent = self->tables->edges.parent;
-    const tsk_id_t *restrict edge_child = self->tables->edges.child;
-    const double *restrict node_time = self->tables->nodes.time;
-    const double sequence_length = self->tables->sequence_length;
-    tsk_id_t *restrict parent = tsk_malloc(num_nodes * sizeof(*parent));
-    double *restrict last_update = tsk_calloc(num_nodes, sizeof(*last_update));
-    double *restrict branch_length = tsk_calloc(num_nodes, sizeof(*branch_length));
-    tsk_id_t tj, tk, h;
-    double t_left, t_right, w_right;
-    const tsk_size_t K = num_sample_sets + 1;
 
-    if (self->time_uncalibrated && !(options & TSK_STAT_ALLOW_TIME_UNCALIBRATED)) {
-        ret = TSK_ERR_TIME_UNCALIBRATED;
+    tsk_bit_array_t A_samples, B_samples;
+    // ss_ prefix refers to a sample set
+    tsk_bit_array_t ss_row;
+    tsk_bit_array_t ss_A_samples, ss_B_samples, ss_AB_samples, AB_samples;
+
+    tsk_memset(&ss_A_samples, 0, sizeof(ss_A_samples));
+    tsk_memset(&ss_B_samples, 0, sizeof(ss_B_samples));
+    tsk_memset(&ss_AB_samples, 0, sizeof(ss_AB_samples));
+    tsk_memset(&AB_samples, 0, sizeof(AB_samples));
+
+    // Sample sets and b sites are rows, a sites are columns
+    //       b1           b2           b3
+    // a1   [s1, s2, s3] [s1, s2, s3] [s1, s2, s3]
+    // a2   [s1, s2, s3] [s1, s2, s3] [s1, s2, s3]
+    // a3   [s1, s2, s3] [s1, s2, s3] [s1, s2, s3]
+
+    tsk_size_t k, mut_a, mut_b;
+    tsk_size_t row_len = num_b_alleles * state_dim;
+    tsk_size_t w_A = 0, w_B = 0, w_AB = 0;
+    uint8_t polarised_val = polarised ? 1 : 0;
+
+    double *hap_weight_row;
+    double *result_tmp_row;
+    double *weights = tsk_malloc(3 * state_dim * sizeof(*weights));
+    double *norm = tsk_malloc(state_dim * sizeof(*norm));
+    double *result_tmp = tsk_malloc(row_len * num_a_alleles * sizeof(*result_tmp));
+
+    if (weights == NULL || norm == NULL || result_tmp == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
 
-    if (parent == NULL || last_update == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
+    ret = tsk_bit_array_init(&ss_A_samples, num_samples, 1);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_bit_array_init(&ss_B_samples, num_samples, 1);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_bit_array_init(&ss_AB_samples, num_samples, 1);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_bit_array_init(&AB_samples, num_samples, 1);
+    if (ret != 0) {
         goto out;
     }
-    tsk_memset(parent, 0xff, num_nodes * sizeof(*parent));
 
-    /* Iterate over the trees */
-    tj = 0;
-    tk = 0;
-    t_left = 0;
-    window_index = 0;
-    while (tj < num_edges || t_left < sequence_length) {
-        tsk_bug_assert(window_index < num_windows);
-        while (tk < num_edges && edge_right[O[tk]] == t_left) {
-            h = O[tk];
-            tk++;
-            u = edge_child[h];
-            v = edge_parent[h];
-            ret = tsk_treeseq_update_branch_afs(self, u, t_left, branch_length,
-                last_update, counts, num_sample_sets, window_index, result_dims, options,
-                result);
+    for (mut_a = polarised_val; mut_a < num_a_alleles; mut_a++) {
+        result_tmp_row = GET_2D_ROW(result_tmp, row_len, mut_a);
+        for (mut_b = polarised_val; mut_b < num_b_alleles; mut_b++) {
+            tsk_bit_array_get_row(site_a_state, mut_a, &A_samples);
+            tsk_bit_array_get_row(site_b_state, mut_b, &B_samples);
+            tsk_bit_array_intersect(&A_samples, &B_samples, &AB_samples);
+            for (k = 0; k < state_dim; k++) {
+                tsk_bit_array_get_row(sample_sets, k, &ss_row);
+                hap_weight_row = GET_2D_ROW(weights, 3, k);
+
+                tsk_bit_array_intersect(&A_samples, &ss_row, &ss_A_samples);
+                tsk_bit_array_intersect(&B_samples, &ss_row, &ss_B_samples);
+                tsk_bit_array_intersect(&AB_samples, &ss_row, &ss_AB_samples);
+
+                w_AB = tsk_bit_array_count(&ss_AB_samples);
+                w_A = tsk_bit_array_count(&ss_A_samples);
+                w_B = tsk_bit_array_count(&ss_B_samples);
+
+                hap_weight_row[0] = (double) w_AB;
+                hap_weight_row[1] = (double) (w_A - w_AB); // w_Ab
+                hap_weight_row[2] = (double) (w_B - w_AB); // w_aB
+            }
+            ret = f(state_dim, weights, result_dim, result_tmp_row, f_params);
             if (ret != 0) {
                 goto out;
             }
-            while (v != TSK_NULL) {
-                ret = tsk_treeseq_update_branch_afs(self, v, t_left, branch_length,
-                    last_update, counts, num_sample_sets, window_index, result_dims,
-                    options, result);
-                if (ret != 0) {
-                    goto out;
-                }
-                update_state(counts, K, v, u, -1);
-                v = parent[v];
+            ret = norm_f(state_dim, weights, num_a_alleles - polarised_val,
+                num_b_alleles - polarised_val, norm, f_params);
+            if (ret != 0) {
+                goto out;
             }
-            parent[u] = TSK_NULL;
-            branch_length[u] = 0;
-        }
-
-        while (tj < num_edges && edge_left[I[tj]] == t_left) {
-            h = I[tj];
-            tj++;
-            u = edge_child[h];
-            v = edge_parent[h];
-            parent[u] = v;
-            branch_length[u] = node_time[v] - node_time[u];
-            while (v != TSK_NULL) {
-                ret = tsk_treeseq_update_branch_afs(self, v, t_left, branch_length,
-                    last_update, counts, num_sample_sets, window_index, result_dims,
-                    options, result);
-                if (ret != 0) {
-                    goto out;
-                }
-                update_state(counts, K, v, u, +1);
-                v = parent[v];
+            for (k = 0; k < state_dim; k++) {
+                result[k] += result_tmp_row[k] * norm[k];
             }
+            result_tmp_row += state_dim; // Advance to the next column
         }
+    }
 
-        t_right = sequence_length;
-        if (tj < num_edges) {
-            t_right = TSK_MIN(t_right, edge_left[I[tj]]);
-        }
-        if (tk < num_edges) {
-            t_right = TSK_MIN(t_right, edge_right[O[tk]]);
-        }
+out:
+    tsk_safe_free(weights);
+    tsk_safe_free(norm);
+    tsk_safe_free(result_tmp);
+    tsk_bit_array_free(&ss_A_samples);
+    tsk_bit_array_free(&ss_B_samples);
+    tsk_bit_array_free(&ss_AB_samples);
+    tsk_bit_array_free(&AB_samples);
+    return ret;
+}
 
-        while (window_index < num_windows && windows[window_index + 1] <= t_right) {
-            w_right = windows[window_index + 1];
-            /* Flush the contributions of all nodes to the current window */
-            for (u = 0; u < (tsk_id_t) num_nodes; u++) {
-                tsk_bug_assert(last_update[u] < w_right);
-                ret = tsk_treeseq_update_branch_afs(self, u, w_right, branch_length,
-                    last_update, counts, num_sample_sets, window_index, result_dims,
-                    options, result);
-                if (ret != 0) {
-                    goto out;
-                }
-            }
-            window_index++;
-        }
+static int
+get_all_mutation_samples(const tsk_treeseq_t *self, const tsk_size_t *site_offsets,
+    tsk_size_t *num_alleles, tsk_bit_array_t *allele_samples)
+{
+    int ret = 0;
+    tsk_tree_t tree;
 
-        t_left = t_right;
-    }
-out:
-    /* Can't use msp_safe_free here because of restrict */
-    if (parent != NULL) {
-        free(parent);
-    }
-    if (last_update != NULL) {
-        free(last_update);
+    ret = tsk_tree_init(&tree, self, TSK_TS_INIT_BUILD_INDEXES | TSK_NO_SAMPLE_COUNTS);
+    if (ret != 0) {
+        goto out;
     }
-    if (branch_length != NULL) {
-        free(branch_length);
+
+    for (ret = tsk_tree_first(&tree); ret == TSK_TREE_OK; ret = tsk_tree_next(&tree)) {
+        ret = get_mutation_samples(&tree, site_offsets, allele_samples, &num_alleles);
+        if (ret != 0) {
+            goto out;
+        }
     }
+    // if adding code below, check ret before continuing
+
+out:
+    tsk_tree_free(&tree);
     return ret;
 }
 
-int
-tsk_treeseq_allele_frequency_spectrum(const tsk_treeseq_t *self,
-    tsk_size_t num_sample_sets, const tsk_size_t *sample_set_sizes,
-    const tsk_id_t *sample_sets, tsk_size_t num_windows, const double *windows,
-    tsk_flags_t options, double *result)
+static int
+tsk_treeseq_two_site_count_stat(const tsk_treeseq_t *self, tsk_size_t state_dim,
+    const tsk_bit_array_t *sample_sets, tsk_size_t result_dim, general_stat_func_t *f,
+    sample_count_stat_params_t *f_params, norm_func_t *norm_f,
+    const double *TSK_UNUSED(left_window), const double *TSK_UNUSED(right_window),
+    tsk_flags_t options, tsk_size_t *result_size, double **result)
 {
     int ret = 0;
-    bool stat_site = !!(options & TSK_STAT_SITE);
-    bool stat_branch = !!(options & TSK_STAT_BRANCH);
-    bool stat_node = !!(options & TSK_STAT_NODE);
-    double default_windows[] = { 0, self->tables->sequence_length };
-    const tsk_size_t num_nodes = self->tables->nodes.num_rows;
-    const tsk_size_t K = num_sample_sets + 1;
-    tsk_size_t j, k, l, afs_size;
-    tsk_id_t u;
-    tsk_size_t *result_dims = NULL;
-    /* These counts should really be ints, but we use doubles so that we can
-     * reuse code from the general_stats code paths. */
-    double *counts = NULL;
-    double *count_row;
 
-    if (stat_node) {
-        ret = TSK_ERR_UNSUPPORTED_STAT_MODE;
+    tsk_bit_array_t all_samples_bits, allele_samples, allele_samples_row;
+    tsk_bit_array_t site_a_state, site_b_state;
+    tsk_size_t site_id, num_alleles_cumsum, inner, result_offset;
+    tsk_size_t site_a, site_b;
+    bool polarised = false;
+
+    tsk_memset(&all_samples_bits, 0, sizeof(all_samples_bits));
+    tsk_memset(&allele_samples, 0, sizeof(allele_samples));
+
+    const tsk_size_t num_sites = self->tables->sites.num_rows;
+    const tsk_size_t num_samples = self->num_samples;
+    const tsk_size_t max_alleles = self->tables->mutations.num_rows + num_sites;
+    tsk_size_t *restrict site_offsets = tsk_malloc(num_sites * sizeof(*site_offsets));
+    tsk_size_t *restrict num_alleles = tsk_malloc(num_sites * sizeof(*num_alleles));
+
+    if (site_offsets == NULL || num_alleles == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
-    /* If no mode is specified, we default to site mode */
-    if (!(stat_site || stat_branch)) {
-        stat_site = true;
+
+    ret = tsk_bit_array_init(&allele_samples, num_samples, max_alleles);
+    if (ret != 0) {
+        goto out;
     }
-    /* It's an error to specify more than one mode */
-    if (stat_site + stat_branch > 1) {
-        ret = TSK_ERR_MULTIPLE_STAT_MODES;
+    ret = tsk_bit_array_init(&all_samples_bits, num_samples, 1);
+    if (ret != 0) {
         goto out;
     }
-    if (windows == NULL) {
-        num_windows = 1;
-        windows = default_windows;
-    } else {
-        ret = tsk_treeseq_check_windows(self, num_windows, windows);
-        if (ret != 0) {
-            goto out;
-        }
+
+    // A future improvement could get a union of all sample sets
+    // instead of all samples
+    get_all_samples_bits(&all_samples_bits, num_samples);
+
+    num_alleles_cumsum = 0;
+    for (site_id = 0; site_id < num_sites; site_id++) {
+        // Initialize the allele_samples with all samples in the ancestral allele
+        tsk_bit_array_get_row(&allele_samples, num_alleles_cumsum, &allele_samples_row);
+        tsk_bit_array_add(&allele_samples_row, &all_samples_bits);
+        // Store the allele offset for each site
+        site_offsets[site_id] = num_alleles_cumsum;
+        num_alleles_cumsum += self->site_mutations_length[site_id] + 1;
     }
-    ret = tsk_treeseq_check_sample_sets(
-        self, num_sample_sets, sample_set_sizes, sample_sets);
+
+    ret = get_all_mutation_samples(self, site_offsets, num_alleles, &allele_samples);
     if (ret != 0) {
         goto out;
     }
 
-    /* the last element of result_dims stores the total size of the dimenensions */
-    result_dims = tsk_malloc((num_sample_sets + 1) * sizeof(*result_dims));
-    counts = tsk_calloc(num_nodes * K, sizeof(*counts));
-    if (counts == NULL || result_dims == NULL) {
+    // Number of pairs w/ replacement (sites)
+    *result_size = (num_sites * (1 + num_sites)) / 2U;
+    *result = tsk_calloc(*result_size * result_dim, sizeof(*result));
+
+    if (result == NULL) {
         ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
-    afs_size = 1;
+
+    if (options & TSK_STAT_POLARISED) {
+        polarised = true;
+    }
+
+    inner = 0;
+    result_offset = 0;
+    // TODO: implement windows!
+    for (site_a = 0; site_a < num_sites; site_a++) {
+        for (site_b = inner; site_b < num_sites; site_b++) {
+            tsk_bit_array_get_row(&allele_samples, site_offsets[site_a], &site_a_state);
+            tsk_bit_array_get_row(&allele_samples, site_offsets[site_b], &site_b_state);
+            ret = compute_general_two_site_stat_result(&site_a_state, &site_b_state,
+                num_alleles[site_a], num_alleles[site_b], num_samples, state_dim,
+                sample_sets, result_dim, f, f_params, norm_f, polarised,
+                &((*result)[result_offset]));
+            if (ret != 0) {
+                goto out;
+            }
+            result_offset += result_dim;
+        }
+        inner++;
+    }
+
+out:
+    if (site_offsets != NULL) {
+        free(site_offsets);
+    }
+    if (num_alleles != NULL) {
+        free(num_alleles);
+    }
+    tsk_bit_array_free(&allele_samples);
+    tsk_bit_array_free(&all_samples_bits);
+    return ret;
+}
+
+static int
+sample_sets_to_bit_array(const tsk_treeseq_t *self, const tsk_size_t *sample_set_sizes,
+    const tsk_id_t *sample_sets, tsk_size_t num_sample_sets,
+    tsk_bit_array_t *sample_sets_bits)
+{
+    int ret;
+
+    tsk_bit_array_t bits_row;
+    tsk_size_t j, k, l;
+    tsk_id_t u, sample_index;
+
+    ret = tsk_bit_array_init(sample_sets_bits, self->num_samples, num_sample_sets);
+    if (ret != 0) {
+        return ret;
+    }
+
     j = 0;
     for (k = 0; k < num_sample_sets; k++) {
-        result_dims[k] = 1 + sample_set_sizes[k];
-        afs_size *= result_dims[k];
+        tsk_bit_array_get_row(sample_sets_bits, k, &bits_row);
         for (l = 0; l < sample_set_sizes[k]; l++) {
             u = sample_sets[j];
-            count_row = GET_2D_ROW(counts, K, u);
-            if (count_row[k] != 0) {
+            sample_index = self->sample_index_map[u];
+            if (tsk_bit_array_contains(
+                    &bits_row, (tsk_bit_array_value_t) sample_index)) {
                 ret = TSK_ERR_DUPLICATE_SAMPLE;
                 goto out;
             }
-            count_row[k] = 1;
+            tsk_bit_array_add_bit(&bits_row, (tsk_bit_array_value_t) sample_index);
             j++;
         }
     }
-    for (j = 0; j < self->num_samples; j++) {
-        u = self->samples[j];
-        count_row = GET_2D_ROW(counts, K, u);
-        count_row[num_sample_sets] = 1;
-    }
-    result_dims[num_sample_sets] = (tsk_size_t) afs_size;
 
-    tsk_memset(result, 0, num_windows * afs_size * sizeof(*result));
-    if (stat_site) {
-        ret = tsk_treeseq_site_allele_frequency_spectrum(self, num_sample_sets,
-            sample_set_sizes, counts, num_windows, windows, result_dims, options,
-            result);
-    } else {
-        ret = tsk_treeseq_branch_allele_frequency_spectrum(self, num_sample_sets, counts,
-            num_windows, windows, result_dims, options, result);
-    }
-
-    if (options & TSK_STAT_SPAN_NORMALISE) {
-        span_normalise(num_windows, windows, afs_size, result);
-    }
 out:
-    tsk_safe_free(counts);
-    tsk_safe_free(result_dims);
     return ret;
 }
 
-/***********************************
- * One way stats
- ***********************************/
-
 static int
-diversity_summary_func(tsk_size_t state_dim, const double *state,
-    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+tsk_treeseq_two_locus_count_stat(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t result_dim, const tsk_id_t *set_indexes, general_stat_func_t *f,
+    norm_func_t *norm_f, tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result)
 {
-    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
-    const double *x = state;
-    double n;
-    tsk_size_t j;
+    // TODO: generalize this function if we ever decide to do weighted two_locus stats.
+    //       We only implement count stats and therefore we don't handle weights.
 
-    for (j = 0; j < state_dim; j++) {
-        n = (double) args.sample_set_sizes[j];
-        result[j] = x[j] * (n - x[j]) / (n * (n - 1));
-    }
-    return 0;
-}
+    int ret = 0;
 
-int
-tsk_treeseq_diversity(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
-    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
-    tsk_size_t num_windows, const double *windows, tsk_flags_t options, double *result)
-{
-    return tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
-        sample_sets, num_sample_sets, NULL, diversity_summary_func, num_windows, windows,
-        options, result);
-}
+    tsk_bit_array_t sample_sets_bits;
+    tsk_memset(&sample_sets_bits, 0, sizeof(sample_sets_bits));
 
-static int
-trait_covariance_summary_func(tsk_size_t state_dim, const double *state,
-    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
-{
-    weight_stat_params_t args = *(weight_stat_params_t *) params;
-    const double n = (double) args.num_samples;
-    const double *x = state;
-    tsk_size_t j;
+    bool stat_site = !!(options & TSK_STAT_SITE);
+    bool stat_branch = !!(options & TSK_STAT_BRANCH);
+    double default_windows[] = { 0, self->tables->sequence_length };
 
-    for (j = 0; j < state_dim; j++) {
-        result[j] = (x[j] * x[j]) / (2 * (n - 1) * (n - 1));
-    }
-    return 0;
-}
+    tsk_size_t state_dim = num_sample_sets;
+    sample_count_stat_params_t f_params = { .sample_sets = sample_sets,
+        .num_sample_sets = num_sample_sets,
+        .sample_set_sizes = sample_set_sizes,
+        .set_indexes = set_indexes };
 
-int
-tsk_treeseq_trait_covariance(const tsk_treeseq_t *self, tsk_size_t num_weights,
-    const double *weights, tsk_size_t num_windows, const double *windows,
-    tsk_flags_t options, double *result)
-{
-    tsk_size_t num_samples = self->num_samples;
-    tsk_size_t j, k;
-    int ret;
-    const double *row;
-    double *new_row;
-    double *means = tsk_calloc(num_weights, sizeof(double));
-    double *new_weights = tsk_malloc((num_weights + 1) * num_samples * sizeof(double));
-    weight_stat_params_t args = { num_samples = self->num_samples };
+    ret = tsk_treeseq_check_sample_sets(
+        self, num_sample_sets, sample_set_sizes, sample_sets);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = sample_sets_to_bit_array(
+        self, sample_set_sizes, sample_sets, num_sample_sets, &sample_sets_bits);
+    if (ret != 0) {
+        goto out;
+    }
 
-    if (new_weights == NULL || means == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
+    /* If no mode is specified, we default to site mode */
+    if (!(stat_site || stat_branch)) {
+        stat_site = true;
+    }
+    /* It's an error to specify more than one mode */
+    if (stat_site + stat_branch > 1) {
+        ret = TSK_ERR_MULTIPLE_STAT_MODES;
         goto out;
     }
 
-    // center weights
-    for (j = 0; j < num_samples; j++) {
-        row = GET_2D_ROW(weights, num_weights, j);
-        for (k = 0; k < num_weights; k++) {
-            means[k] += row[k];
-        }
+    if (state_dim < 1) {
+        ret = TSK_ERR_BAD_STATE_DIMS;
+        goto out;
     }
-    for (k = 0; k < num_weights; k++) {
-        means[k] /= (double) num_samples;
+    if (result_dim < 1) {
+        ret = TSK_ERR_BAD_RESULT_DIMS;
+        goto out;
     }
-    for (j = 0; j < num_samples; j++) {
-        row = GET_2D_ROW(weights, num_weights, j);
-        new_row = GET_2D_ROW(new_weights, num_weights, j);
-        for (k = 0; k < num_weights; k++) {
-            new_row[k] = row[k] - means[k];
+    if (left_windows == NULL) {
+        num_left_windows = 1;
+        left_windows = default_windows;
+        num_right_windows = 1;
+        right_windows = default_windows;
+    } else if (right_windows == NULL) {
+        ret = tsk_treeseq_check_windows(self, num_left_windows, left_windows, 0);
+        if (ret != 0) {
+            goto out;
+        }
+        num_right_windows = num_left_windows;
+        right_windows = left_windows;
+    } else {
+        ret = tsk_treeseq_check_windows(self, num_left_windows, left_windows, 0);
+        if (ret != 0) {
+            goto out;
+        }
+        ret = tsk_treeseq_check_windows(self, num_right_windows, right_windows, 0);
+        if (ret != 0) {
+            goto out;
         }
     }
 
-    ret = tsk_treeseq_general_stat(self, num_weights, new_weights, num_weights,
-        trait_covariance_summary_func, &args, num_windows, windows, options, result);
+    if (stat_site) {
+        // TODO: assert 1 window left/right
+        ret = tsk_treeseq_two_site_count_stat(self, state_dim, &sample_sets_bits,
+            result_dim, f, &f_params, norm_f, left_windows, right_windows, options,
+            result_size, result);
+    } else {
+        // TODO: branch statistics
+        ret = TSK_ERR_GENERIC;
+    }
 
 out:
-    tsk_safe_free(means);
-    tsk_safe_free(new_weights);
+    tsk_bit_array_free(&sample_sets_bits);
     return ret;
 }
 
-static int
-trait_correlation_summary_func(tsk_size_t state_dim, const double *state,
-    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+/***********************************
+ * Allele frequency spectrum
+ ***********************************/
+
+static inline void
+fold(tsk_size_t *restrict coordinate, const tsk_size_t *restrict dims,
+    tsk_size_t num_dims)
 {
-    weight_stat_params_t args = *(weight_stat_params_t *) params;
-    const double n = (double) args.num_samples;
-    const double *x = state;
-    double p;
-    tsk_size_t j;
+    tsk_size_t k;
+    double n = 0;
+    int s = 0;
 
-    p = x[state_dim - 1];
-    for (j = 0; j < state_dim - 1; j++) {
-        if ((p > 0.0) && (p < 1.0)) {
-            result[j] = (x[j] * x[j]) / (2 * (p * (1 - p)) * n * (n - 1));
-        } else {
-            result[j] = 0.0;
+    for (k = 0; k < num_dims; k++) {
+        tsk_bug_assert(coordinate[k] < dims[k]);
+        n += (double) dims[k] - 1;
+        s += (int) coordinate[k];
+    }
+    n /= 2;
+    k = num_dims;
+    while (s == n && k > 0) {
+        k--;
+        n -= ((double) (dims[k] - 1)) / 2;
+        s -= (int) coordinate[k];
+    }
+    if (s > n) {
+        for (k = 0; k < num_dims; k++) {
+            s = (int) (dims[k] - 1 - coordinate[k]);
+            tsk_bug_assert(s >= 0);
+            coordinate[k] = (tsk_size_t) s;
         }
     }
-    return 0;
 }
 
-int
-tsk_treeseq_trait_correlation(const tsk_treeseq_t *self, tsk_size_t num_weights,
-    const double *weights, tsk_size_t num_windows, const double *windows,
-    tsk_flags_t options, double *result)
+static int
+tsk_treeseq_update_site_afs(const tsk_treeseq_t *self, const tsk_site_t *site,
+    const double *total_counts, const double *counts, tsk_size_t num_sample_sets,
+    tsk_size_t window_index, tsk_size_t *result_dims, tsk_flags_t options,
+    double *result)
 {
-    tsk_size_t num_samples = self->num_samples;
-    tsk_size_t j, k;
-    int ret;
-    double *means = tsk_calloc(num_weights, sizeof(double));
-    double *meansqs = tsk_calloc(num_weights, sizeof(double));
-    double *sds = tsk_calloc(num_weights, sizeof(double));
-    const double *row;
-    double *new_row;
-    double *new_weights = tsk_malloc((num_weights + 1) * num_samples * sizeof(double));
-    weight_stat_params_t args = { num_samples = self->num_samples };
+    int ret = 0;
+    tsk_size_t afs_size;
+    tsk_size_t k, allele, num_alleles, all_samples;
+    double increment, *afs, *allele_counts, *allele_count;
+    tsk_size_t *coordinate = tsk_malloc(num_sample_sets * sizeof(*coordinate));
+    bool polarised = !!(options & TSK_STAT_POLARISED);
+    const tsk_size_t K = num_sample_sets + 1;
 
-    if (new_weights == NULL || means == NULL || meansqs == NULL || sds == NULL) {
+    if (coordinate == NULL) {
         ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
-
-    if (num_weights < 1) {
-        ret = TSK_ERR_BAD_STATE_DIMS;
+    ret = get_allele_weights(
+        site, counts, K, total_counts, &num_alleles, &allele_counts);
+    if (ret != 0) {
         goto out;
     }
 
-    // center and scale weights
-    for (j = 0; j < num_samples; j++) {
-        row = GET_2D_ROW(weights, num_weights, j);
-        for (k = 0; k < num_weights; k++) {
-            means[k] += row[k];
-            meansqs[k] += row[k] * row[k];
-        }
-    }
-    for (k = 0; k < num_weights; k++) {
-        means[k] /= (double) num_samples;
-        meansqs[k] -= means[k] * means[k] * (double) num_samples;
-        meansqs[k] /= (double) (num_samples - 1);
-        sds[k] = sqrt(meansqs[k]);
-    }
-    for (j = 0; j < num_samples; j++) {
-        row = GET_2D_ROW(weights, num_weights, j);
-        new_row = GET_2D_ROW(new_weights, num_weights + 1, j);
-        for (k = 0; k < num_weights; k++) {
-            new_row[k] = (row[k] - means[k]) / sds[k];
+    afs_size = result_dims[num_sample_sets];
+    afs = result + afs_size * window_index;
+
+    increment = polarised ? 1 : 0.5;
+    /* Sum over the allele weights. Skip the ancestral state if polarised. */
+    for (allele = polarised ? 1 : 0; allele < num_alleles; allele++) {
+        allele_count = GET_2D_ROW(allele_counts, K, allele);
+        all_samples = (tsk_size_t) allele_count[num_sample_sets];
+        if (all_samples > 0 && all_samples < self->num_samples) {
+            for (k = 0; k < num_sample_sets; k++) {
+                coordinate[k] = (tsk_size_t) allele_count[k];
+            }
+            if (!polarised) {
+                fold(coordinate, result_dims, num_sample_sets);
+            }
+            increment_nd_array_value(
+                afs, num_sample_sets, result_dims, coordinate, increment);
         }
-        // set final row to 1/n to compute frequency
-        new_row[num_weights] = 1.0 / (double) num_samples;
     }
-
-    ret = tsk_treeseq_general_stat(self, num_weights + 1, new_weights, num_weights,
-        trait_correlation_summary_func, &args, num_windows, windows, options, result);
-
 out:
-    tsk_safe_free(means);
-    tsk_safe_free(meansqs);
-    tsk_safe_free(sds);
-    tsk_safe_free(new_weights);
+    tsk_safe_free(coordinate);
+    tsk_safe_free(allele_counts);
     return ret;
 }
 
 static int
-trait_linear_model_summary_func(tsk_size_t state_dim, const double *state,
-    tsk_size_t result_dim, double *result, void *params)
+tsk_treeseq_site_allele_frequency_spectrum(const tsk_treeseq_t *self,
+    tsk_size_t num_sample_sets, const tsk_size_t *sample_set_sizes, double *counts,
+    tsk_size_t num_windows, const double *windows, tsk_size_t *result_dims,
+    tsk_flags_t options, double *result)
 {
-    covariates_stat_params_t args = *(covariates_stat_params_t *) params;
+    int ret = 0;
+    tsk_id_t u, v;
+    tsk_size_t tree_site, tree_index, window_index;
+    tsk_size_t num_nodes = self->tables->nodes.num_rows;
+    const tsk_id_t num_edges = (tsk_id_t) self->tables->edges.num_rows;
+    const tsk_id_t *restrict I = self->tables->indexes.edge_insertion_order;
+    const tsk_id_t *restrict O = self->tables->indexes.edge_removal_order;
+    const double *restrict edge_left = self->tables->edges.left;
+    const double *restrict edge_right = self->tables->edges.right;
+    const tsk_id_t *restrict edge_parent = self->tables->edges.parent;
+    const tsk_id_t *restrict edge_child = self->tables->edges.child;
+    const double sequence_length = self->tables->sequence_length;
+    tsk_id_t *restrict parent = tsk_malloc(num_nodes * sizeof(*parent));
+    tsk_site_t *site;
+    tsk_id_t tj, tk, h;
+    tsk_size_t j;
+    const tsk_size_t K = num_sample_sets + 1;
+    double t_left, t_right;
+    double *total_counts = tsk_malloc((1 + num_sample_sets) * sizeof(*total_counts));
+
+    if (parent == NULL || total_counts == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    tsk_memset(parent, 0xff, num_nodes * sizeof(*parent));
+
+    for (j = 0; j < num_sample_sets; j++) {
+        total_counts[j] = (double) sample_set_sizes[j];
+    }
+    total_counts[num_sample_sets] = (double) self->num_samples;
+
+    /* Iterate over the trees */
+    tj = 0;
+    tk = 0;
+    t_left = 0;
+    tree_index = 0;
+    window_index = 0;
+    while (tj < num_edges || t_left < sequence_length) {
+        while (tk < num_edges && edge_right[O[tk]] == t_left) {
+            h = O[tk];
+            tk++;
+            u = edge_child[h];
+            v = edge_parent[h];
+            while (v != TSK_NULL) {
+                update_state(counts, K, v, u, -1);
+                v = parent[v];
+            }
+            parent[u] = TSK_NULL;
+        }
+
+        while (tj < num_edges && edge_left[I[tj]] == t_left) {
+            h = I[tj];
+            tj++;
+            u = edge_child[h];
+            v = edge_parent[h];
+            parent[u] = v;
+            while (v != TSK_NULL) {
+                update_state(counts, K, v, u, +1);
+                v = parent[v];
+            }
+        }
+        t_right = sequence_length;
+        if (tj < num_edges) {
+            t_right = TSK_MIN(t_right, edge_left[I[tj]]);
+        }
+        if (tk < num_edges) {
+            t_right = TSK_MIN(t_right, edge_right[O[tk]]);
+        }
+
+        /* Update the sites */
+        for (tree_site = 0; tree_site < self->tree_sites_length[tree_index];
+             tree_site++) {
+            site = self->tree_sites[tree_index] + tree_site;
+            while (windows[window_index + 1] <= site->position) {
+                window_index++;
+                tsk_bug_assert(window_index < num_windows);
+            }
+            ret = tsk_treeseq_update_site_afs(self, site, total_counts, counts,
+                num_sample_sets, window_index, result_dims, options, result);
+            if (ret != 0) {
+                goto out;
+            }
+            tsk_bug_assert(windows[window_index] <= site->position);
+            tsk_bug_assert(site->position < windows[window_index + 1]);
+        }
+        tree_index++;
+        t_left = t_right;
+    }
+out:
+    /* Can't use msp_safe_free here because of restrict */
+    if (parent != NULL) {
+        free(parent);
+    }
+    tsk_safe_free(total_counts);
+    return ret;
+}
+
+static int TSK_WARN_UNUSED
+tsk_treeseq_update_branch_afs(const tsk_treeseq_t *self, tsk_id_t u, double right,
+    const double *restrict branch_length, double *restrict last_update,
+    const double *counts, tsk_size_t num_sample_sets, tsk_size_t window_index,
+    const tsk_size_t *result_dims, tsk_flags_t options, double *result)
+{
+    int ret = 0;
+    tsk_size_t afs_size;
+    tsk_size_t k;
+    double *afs;
+    tsk_size_t *coordinate = tsk_malloc(num_sample_sets * sizeof(*coordinate));
+    bool polarised = !!(options & TSK_STAT_POLARISED);
+    const double *count_row = GET_2D_ROW(counts, num_sample_sets + 1, u);
+    double x = (right - last_update[u]) * branch_length[u];
+    const tsk_size_t all_samples = (tsk_size_t) count_row[num_sample_sets];
+
+    if (coordinate == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+
+    if (0 < all_samples && all_samples < self->num_samples) {
+        if (!polarised) {
+            x *= 0.5;
+        }
+        afs_size = result_dims[num_sample_sets];
+        afs = result + afs_size * window_index;
+        for (k = 0; k < num_sample_sets; k++) {
+            coordinate[k] = (tsk_size_t) count_row[k];
+        }
+        if (!polarised) {
+            fold(coordinate, result_dims, num_sample_sets);
+        }
+        increment_nd_array_value(afs, num_sample_sets, result_dims, coordinate, x);
+    }
+    last_update[u] = right;
+out:
+    tsk_safe_free(coordinate);
+    return ret;
+}
+
+static int
+tsk_treeseq_branch_allele_frequency_spectrum(const tsk_treeseq_t *self,
+    tsk_size_t num_sample_sets, double *counts, tsk_size_t num_windows,
+    const double *windows, const tsk_size_t *result_dims, tsk_flags_t options,
+    double *result)
+{
+    int ret = 0;
+    tsk_id_t u, v;
+    tsk_size_t window_index;
+    tsk_size_t num_nodes = self->tables->nodes.num_rows;
+    const tsk_id_t num_edges = (tsk_id_t) self->tables->edges.num_rows;
+    const tsk_id_t *restrict I = self->tables->indexes.edge_insertion_order;
+    const tsk_id_t *restrict O = self->tables->indexes.edge_removal_order;
+    const double *restrict edge_left = self->tables->edges.left;
+    const double *restrict edge_right = self->tables->edges.right;
+    const tsk_id_t *restrict edge_parent = self->tables->edges.parent;
+    const tsk_id_t *restrict edge_child = self->tables->edges.child;
+    const double *restrict node_time = self->tables->nodes.time;
+    const double sequence_length = self->tables->sequence_length;
+    tsk_id_t *restrict parent = tsk_malloc(num_nodes * sizeof(*parent));
+    double *restrict last_update = tsk_calloc(num_nodes, sizeof(*last_update));
+    double *restrict branch_length = tsk_calloc(num_nodes, sizeof(*branch_length));
+    tsk_id_t tj, tk, h;
+    double t_left, t_right, w_right;
+    const tsk_size_t K = num_sample_sets + 1;
+
+    if (self->time_uncalibrated && !(options & TSK_STAT_ALLOW_TIME_UNCALIBRATED)) {
+        ret = TSK_ERR_TIME_UNCALIBRATED;
+        goto out;
+    }
+
+    if (parent == NULL || last_update == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    tsk_memset(parent, 0xff, num_nodes * sizeof(*parent));
+
+    /* Iterate over the trees */
+    tj = 0;
+    tk = 0;
+    t_left = 0;
+    window_index = 0;
+    while (tj < num_edges || t_left < sequence_length) {
+        tsk_bug_assert(window_index < num_windows);
+        while (tk < num_edges && edge_right[O[tk]] == t_left) {
+            h = O[tk];
+            tk++;
+            u = edge_child[h];
+            v = edge_parent[h];
+            ret = tsk_treeseq_update_branch_afs(self, u, t_left, branch_length,
+                last_update, counts, num_sample_sets, window_index, result_dims, options,
+                result);
+            if (ret != 0) {
+                goto out;
+            }
+            while (v != TSK_NULL) {
+                ret = tsk_treeseq_update_branch_afs(self, v, t_left, branch_length,
+                    last_update, counts, num_sample_sets, window_index, result_dims,
+                    options, result);
+                if (ret != 0) {
+                    goto out;
+                }
+                update_state(counts, K, v, u, -1);
+                v = parent[v];
+            }
+            parent[u] = TSK_NULL;
+            branch_length[u] = 0;
+        }
+
+        while (tj < num_edges && edge_left[I[tj]] == t_left) {
+            h = I[tj];
+            tj++;
+            u = edge_child[h];
+            v = edge_parent[h];
+            parent[u] = v;
+            branch_length[u] = node_time[v] - node_time[u];
+            while (v != TSK_NULL) {
+                ret = tsk_treeseq_update_branch_afs(self, v, t_left, branch_length,
+                    last_update, counts, num_sample_sets, window_index, result_dims,
+                    options, result);
+                if (ret != 0) {
+                    goto out;
+                }
+                update_state(counts, K, v, u, +1);
+                v = parent[v];
+            }
+        }
+
+        t_right = sequence_length;
+        if (tj < num_edges) {
+            t_right = TSK_MIN(t_right, edge_left[I[tj]]);
+        }
+        if (tk < num_edges) {
+            t_right = TSK_MIN(t_right, edge_right[O[tk]]);
+        }
+
+        while (window_index < num_windows && windows[window_index + 1] <= t_right) {
+            w_right = windows[window_index + 1];
+            /* Flush the contributions of all nodes to the current window */
+            for (u = 0; u < (tsk_id_t) num_nodes; u++) {
+                tsk_bug_assert(last_update[u] < w_right);
+                ret = tsk_treeseq_update_branch_afs(self, u, w_right, branch_length,
+                    last_update, counts, num_sample_sets, window_index, result_dims,
+                    options, result);
+                if (ret != 0) {
+                    goto out;
+                }
+            }
+            window_index++;
+        }
+
+        t_left = t_right;
+    }
+out:
+    /* Can't use msp_safe_free here because of restrict */
+    if (parent != NULL) {
+        free(parent);
+    }
+    if (last_update != NULL) {
+        free(last_update);
+    }
+    if (branch_length != NULL) {
+        free(branch_length);
+    }
+    return ret;
+}
+
+int
+tsk_treeseq_allele_frequency_spectrum(const tsk_treeseq_t *self,
+    tsk_size_t num_sample_sets, const tsk_size_t *sample_set_sizes,
+    const tsk_id_t *sample_sets, tsk_size_t num_windows, const double *windows,
+    tsk_flags_t options, double *result)
+{
+    int ret = 0;
+    bool stat_site = !!(options & TSK_STAT_SITE);
+    bool stat_branch = !!(options & TSK_STAT_BRANCH);
+    bool stat_node = !!(options & TSK_STAT_NODE);
+    const double default_windows[] = { 0, self->tables->sequence_length };
+    const tsk_size_t num_nodes = self->tables->nodes.num_rows;
+    const tsk_size_t K = num_sample_sets + 1;
+    tsk_size_t j, k, l, afs_size;
+    tsk_id_t u;
+    tsk_size_t *result_dims = NULL;
+    /* These counts should really be ints, but we use doubles so that we can
+     * reuse code from the general_stats code paths. */
+    double *counts = NULL;
+    double *count_row;
+
+    if (stat_node) {
+        ret = TSK_ERR_UNSUPPORTED_STAT_MODE;
+        goto out;
+    }
+    /* If no mode is specified, we default to site mode */
+    if (!(stat_site || stat_branch)) {
+        stat_site = true;
+    }
+    /* It's an error to specify more than one mode */
+    if (stat_site + stat_branch > 1) {
+        ret = TSK_ERR_MULTIPLE_STAT_MODES;
+        goto out;
+    }
+    if (windows == NULL) {
+        num_windows = 1;
+        windows = default_windows;
+    } else {
+        ret = tsk_treeseq_check_windows(
+            self, num_windows, windows, TSK_REQUIRE_FULL_SPAN);
+        if (ret != 0) {
+            goto out;
+        }
+    }
+    ret = tsk_treeseq_check_sample_sets(
+        self, num_sample_sets, sample_set_sizes, sample_sets);
+    if (ret != 0) {
+        goto out;
+    }
+
+    /* the last element of result_dims stores the total size of the dimenensions */
+    result_dims = tsk_malloc((num_sample_sets + 1) * sizeof(*result_dims));
+    counts = tsk_calloc(num_nodes * K, sizeof(*counts));
+    if (counts == NULL || result_dims == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    afs_size = 1;
+    j = 0;
+    for (k = 0; k < num_sample_sets; k++) {
+        result_dims[k] = 1 + sample_set_sizes[k];
+        afs_size *= result_dims[k];
+        for (l = 0; l < sample_set_sizes[k]; l++) {
+            u = sample_sets[j];
+            count_row = GET_2D_ROW(counts, K, u);
+            if (count_row[k] != 0) {
+                ret = TSK_ERR_DUPLICATE_SAMPLE;
+                goto out;
+            }
+            count_row[k] = 1;
+            j++;
+        }
+    }
+    for (j = 0; j < self->num_samples; j++) {
+        u = self->samples[j];
+        count_row = GET_2D_ROW(counts, K, u);
+        count_row[num_sample_sets] = 1;
+    }
+    result_dims[num_sample_sets] = (tsk_size_t) afs_size;
+
+    tsk_memset(result, 0, num_windows * afs_size * sizeof(*result));
+    if (stat_site) {
+        ret = tsk_treeseq_site_allele_frequency_spectrum(self, num_sample_sets,
+            sample_set_sizes, counts, num_windows, windows, result_dims, options,
+            result);
+    } else {
+        ret = tsk_treeseq_branch_allele_frequency_spectrum(self, num_sample_sets, counts,
+            num_windows, windows, result_dims, options, result);
+    }
+
+    if (options & TSK_STAT_SPAN_NORMALISE) {
+        span_normalise(num_windows, windows, afs_size, result);
+    }
+out:
+    tsk_safe_free(counts);
+    tsk_safe_free(result_dims);
+    return ret;
+}
+
+/***********************************
+ * One way stats
+ ***********************************/
+
+static int
+diversity_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *x = state;
+    double n;
+    tsk_size_t j;
+
+    for (j = 0; j < state_dim; j++) {
+        n = (double) args.sample_set_sizes[j];
+        result[j] = x[j] * (n - x[j]) / (n * (n - 1));
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_diversity(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_windows, const double *windows, tsk_flags_t options, double *result)
+{
+    return tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_sample_sets, NULL, diversity_summary_func, num_windows, windows,
+        options, result);
+}
+
+static int
+trait_covariance_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    weight_stat_params_t args = *(weight_stat_params_t *) params;
+    const double n = (double) args.num_samples;
+    const double *x = state;
+    tsk_size_t j;
+
+    for (j = 0; j < state_dim; j++) {
+        result[j] = (x[j] * x[j]) / (2 * (n - 1) * (n - 1));
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_trait_covariance(const tsk_treeseq_t *self, tsk_size_t num_weights,
+    const double *weights, tsk_size_t num_windows, const double *windows,
+    tsk_flags_t options, double *result)
+{
+    tsk_size_t num_samples = self->num_samples;
+    tsk_size_t j, k;
+    int ret;
+    const double *row;
+    double *new_row;
+    double *means = tsk_calloc(num_weights, sizeof(double));
+    double *new_weights = tsk_malloc((num_weights + 1) * num_samples * sizeof(double));
+    weight_stat_params_t args = { num_samples = self->num_samples };
+
+    if (new_weights == NULL || means == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    if (num_weights == 0) {
+        ret = TSK_ERR_INSUFFICIENT_WEIGHTS;
+        goto out;
+    }
+
+    // center weights
+    for (j = 0; j < num_samples; j++) {
+        row = GET_2D_ROW(weights, num_weights, j);
+        for (k = 0; k < num_weights; k++) {
+            means[k] += row[k];
+        }
+    }
+    for (k = 0; k < num_weights; k++) {
+        means[k] /= (double) num_samples;
+    }
+    for (j = 0; j < num_samples; j++) {
+        row = GET_2D_ROW(weights, num_weights, j);
+        new_row = GET_2D_ROW(new_weights, num_weights, j);
+        for (k = 0; k < num_weights; k++) {
+            new_row[k] = row[k] - means[k];
+        }
+    }
+
+    ret = tsk_treeseq_general_stat(self, num_weights, new_weights, num_weights,
+        trait_covariance_summary_func, &args, num_windows, windows, options, result);
+
+out:
+    tsk_safe_free(means);
+    tsk_safe_free(new_weights);
+    return ret;
+}
+
+static int
+trait_correlation_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    weight_stat_params_t args = *(weight_stat_params_t *) params;
+    const double n = (double) args.num_samples;
+    const double *x = state;
+    double p;
+    tsk_size_t j;
+
+    p = x[state_dim - 1];
+    for (j = 0; j < state_dim - 1; j++) {
+        if ((p > 0.0) && (p < 1.0)) {
+            result[j] = (x[j] * x[j]) / (2 * (p * (1 - p)) * n * (n - 1));
+        } else {
+            result[j] = 0.0;
+        }
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_trait_correlation(const tsk_treeseq_t *self, tsk_size_t num_weights,
+    const double *weights, tsk_size_t num_windows, const double *windows,
+    tsk_flags_t options, double *result)
+{
+    tsk_size_t num_samples = self->num_samples;
+    tsk_size_t j, k;
+    int ret;
+    double *means = tsk_calloc(num_weights, sizeof(double));
+    double *meansqs = tsk_calloc(num_weights, sizeof(double));
+    double *sds = tsk_calloc(num_weights, sizeof(double));
+    const double *row;
+    double *new_row;
+    double *new_weights = tsk_malloc((num_weights + 1) * num_samples * sizeof(double));
+    weight_stat_params_t args = { num_samples = self->num_samples };
+
+    if (new_weights == NULL || means == NULL || meansqs == NULL || sds == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+
+    if (num_weights < 1) {
+        ret = TSK_ERR_INSUFFICIENT_WEIGHTS;
+        goto out;
+    }
+
+    // center and scale weights
+    for (j = 0; j < num_samples; j++) {
+        row = GET_2D_ROW(weights, num_weights, j);
+        for (k = 0; k < num_weights; k++) {
+            means[k] += row[k];
+            meansqs[k] += row[k] * row[k];
+        }
+    }
+    for (k = 0; k < num_weights; k++) {
+        means[k] /= (double) num_samples;
+        meansqs[k] -= means[k] * means[k] * (double) num_samples;
+        meansqs[k] /= (double) (num_samples - 1);
+        sds[k] = sqrt(meansqs[k]);
+    }
+    for (j = 0; j < num_samples; j++) {
+        row = GET_2D_ROW(weights, num_weights, j);
+        new_row = GET_2D_ROW(new_weights, num_weights + 1, j);
+        for (k = 0; k < num_weights; k++) {
+            new_row[k] = (row[k] - means[k]) / sds[k];
+        }
+        // set final row to 1/n to compute frequency
+        new_row[num_weights] = 1.0 / (double) num_samples;
+    }
+
+    ret = tsk_treeseq_general_stat(self, num_weights + 1, new_weights, num_weights,
+        trait_correlation_summary_func, &args, num_windows, windows, options, result);
+
+out:
+    tsk_safe_free(means);
+    tsk_safe_free(meansqs);
+    tsk_safe_free(sds);
+    tsk_safe_free(new_weights);
+    return ret;
+}
+
+static int
+trait_linear_model_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t result_dim, double *result, void *params)
+{
+    covariates_stat_params_t args = *(covariates_stat_params_t *) params;
     const double num_samples = (double) args.num_samples;
     const tsk_size_t k = args.num_covariates;
     const double *V = args.V;
     ;
     const double *x = state;
-    const double *v;
-    double m, a, denom, z;
-    tsk_size_t i, j;
-    // x[0], ..., x[result_dim - 1] contains the traits, W
-    // x[result_dim], ..., x[state_dim - 2] contains the covariates, Z
-    // x[state_dim - 1] has the number of samples below the node
+    const double *v;
+    double m, a, denom, z;
+    tsk_size_t i, j;
+    // x[0], ..., x[result_dim - 1] contains the traits, W
+    // x[result_dim], ..., x[state_dim - 2] contains the covariates, Z
+    // x[state_dim - 1] has the number of samples below the node
+
+    m = x[state_dim - 1];
+    for (i = 0; i < result_dim; i++) {
+        if ((m > 0.0) && (m < num_samples)) {
+            v = GET_2D_ROW(V, k, i);
+            a = x[i];
+            denom = m;
+            for (j = 0; j < k; j++) {
+                z = x[result_dim + j];
+                a -= z * v[j];
+                denom -= z * z;
+            }
+            // denom is the length of projection of the trait onto the subspace
+            // spanned by the covariates, so if it is zero then the system is
+            // singular and the solution is nonunique. This numerical tolerance
+            // could be smaller without hitting floating-point error, but being
+            // a tiny bit conservative about when the trait is almost in the
+            // span of the covariates is probably good.
+            if (denom < 1e-8) {
+                result[i] = 0.0;
+            } else {
+                result[i] = (a * a) / (2 * denom * denom);
+            }
+        } else {
+            result[i] = 0.0;
+        }
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_trait_linear_model(const tsk_treeseq_t *self, tsk_size_t num_weights,
+    const double *weights, tsk_size_t num_covariates, const double *covariates,
+    tsk_size_t num_windows, const double *windows, tsk_flags_t options, double *result)
+{
+    tsk_size_t num_samples = self->num_samples;
+    tsk_size_t i, j, k;
+    int ret;
+    const double *w, *z;
+    double *v, *new_row;
+    double *V = tsk_calloc(num_covariates * num_weights, sizeof(double));
+    double *new_weights
+        = tsk_malloc((num_weights + num_covariates + 1) * num_samples * sizeof(double));
+
+    covariates_stat_params_t args
+        = { .num_samples = self->num_samples, .num_covariates = num_covariates, .V = V };
+
+    // We assume that the covariates have been *already standardised*,
+    // so that (a) 1 is in the span of the columns, and
+    // (b) their crossproduct is the identity.
+    // We could do this instead here with gsl linalg.
+
+    if (new_weights == NULL || V == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+
+    if (num_weights < 1) {
+        ret = TSK_ERR_INSUFFICIENT_WEIGHTS;
+        goto out;
+    }
+
+    // V = weights^T (matrix mult) covariates
+    for (k = 0; k < num_samples; k++) {
+        w = GET_2D_ROW(weights, num_weights, k);
+        z = GET_2D_ROW(covariates, num_covariates, k);
+        for (i = 0; i < num_weights; i++) {
+            v = GET_2D_ROW(V, num_covariates, i);
+            for (j = 0; j < num_covariates; j++) {
+                v[j] += w[i] * z[j];
+            }
+        }
+    }
+
+    for (k = 0; k < num_samples; k++) {
+        w = GET_2D_ROW(weights, num_weights, k);
+        z = GET_2D_ROW(covariates, num_covariates, k);
+        new_row = GET_2D_ROW(new_weights, num_covariates + num_weights + 1, k);
+        for (i = 0; i < num_weights; i++) {
+            new_row[i] = w[i];
+        }
+        for (i = 0; i < num_covariates; i++) {
+            new_row[i + num_weights] = z[i];
+        }
+        // set final row to 1 to count alleles
+        new_row[num_weights + num_covariates] = 1.0;
+    }
+
+    ret = tsk_treeseq_general_stat(self, num_weights + num_covariates + 1, new_weights,
+        num_weights, trait_linear_model_summary_func, &args, num_windows, windows,
+        options, result);
+
+out:
+    tsk_safe_free(V);
+    tsk_safe_free(new_weights);
+    return ret;
+}
+
+static int
+segregating_sites_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *x = state;
+    double n;
+    tsk_size_t j;
+
+    // this works because sum_{i=1}^k (1-p_i) = k-1
+    for (j = 0; j < state_dim; j++) {
+        n = (double) args.sample_set_sizes[j];
+        result[j] = (x[j] > 0) * (1 - x[j] / n);
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_segregating_sites(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_windows, const double *windows, tsk_flags_t options, double *result)
+{
+    return tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_sample_sets, NULL, segregating_sites_summary_func, num_windows,
+        windows, options, result);
+}
+
+static int
+Y1_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
+    tsk_size_t result_dim, double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *x = state;
+    double ni, denom, numer;
+    tsk_size_t i;
+
+    for (i = 0; i < result_dim; i++) {
+        ni = (double) args.sample_set_sizes[i];
+        denom = ni * (ni - 1) * (ni - 2);
+        numer = x[i] * (ni - x[i]) * (ni - x[i] - 1);
+        result[i] = numer / denom;
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_Y1(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_windows, const double *windows, tsk_flags_t options, double *result)
+{
+    return tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_sample_sets, NULL, Y1_summary_func, num_windows, windows,
+        options, result);
+}
+
+static int
+D_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    double n;
+    const double *state_row;
+    tsk_size_t j;
+
+    for (j = 0; j < state_dim; j++) {
+        n = (double) args.sample_set_sizes[j];
+        state_row = GET_2D_ROW(state, 3, j);
+        double p_AB = state_row[0] / n;
+        double p_Ab = state_row[1] / n;
+        double p_aB = state_row[2] / n;
+
+        double p_A = p_AB + p_Ab;
+        double p_B = p_AB + p_aB;
+        result[j] = p_AB - (p_A * p_B);
+    }
+
+    return 0;
+}
+
+int
+tsk_treeseq_D(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result)
+{
+    options |= TSK_STAT_POLARISED; // TODO: allow user to pick?
+    return tsk_treeseq_two_locus_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_sample_sets, NULL, D_summary_func, norm_total_weighted,
+        num_left_windows, left_windows, num_right_windows, right_windows, options,
+        result_size, result);
+}
+
+static int
+D2_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    double n;
+    const double *state_row;
+    tsk_size_t j;
+
+    for (j = 0; j < state_dim; j++) {
+        n = (double) args.sample_set_sizes[j];
+        state_row = GET_2D_ROW(state, 3, j);
+        double p_AB = state_row[0] / n;
+        double p_Ab = state_row[1] / n;
+        double p_aB = state_row[2] / n;
+
+        double p_A = p_AB + p_Ab;
+        double p_B = p_AB + p_aB;
+        result[j] = p_AB - (p_A * p_B);
+        result[j] *= result[j];
+    }
+
+    return 0;
+}
+
+int
+tsk_treeseq_D2(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result)
+{
+    return tsk_treeseq_two_locus_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_sample_sets, NULL, D2_summary_func, norm_total_weighted,
+        num_left_windows, left_windows, num_right_windows, right_windows, options,
+        result_size, result);
+}
+
+static int
+r2_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    double n;
+    const double *state_row;
+    tsk_size_t j;
+
+    for (j = 0; j < state_dim; j++) {
+        n = (double) args.sample_set_sizes[j];
+        state_row = GET_2D_ROW(state, 3, j);
+        double p_AB = state_row[0] / n;
+        double p_Ab = state_row[1] / n;
+        double p_aB = state_row[2] / n;
+
+        double p_A = p_AB + p_Ab;
+        double p_B = p_AB + p_aB;
+
+        double D_ = p_AB - (p_A * p_B);
+        double denom = p_A * p_B * (1 - p_A) * (1 - p_B);
+
+        if (denom == 0 && D_ == 0) {
+            result[j] = 0;
+        } else {
+            result[j] = (D_ * D_) / denom;
+        }
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_r2(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result)
+{
+    return tsk_treeseq_two_locus_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_sample_sets, NULL, r2_summary_func, norm_hap_weighted,
+        num_left_windows, left_windows, num_right_windows, right_windows, options,
+        result_size, result);
+}
+
+static int
+D_prime_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    double n;
+    const double *state_row;
+    tsk_size_t j;
+
+    for (j = 0; j < state_dim; j++) {
+        n = (double) args.sample_set_sizes[j];
+        state_row = GET_2D_ROW(state, 3, j);
+        double p_AB = state_row[0] / n;
+        double p_Ab = state_row[1] / n;
+        double p_aB = state_row[2] / n;
+
+        double p_A = p_AB + p_Ab;
+        double p_B = p_AB + p_aB;
+
+        double D_ = p_AB - (p_A * p_B);
+        if (D_ >= 0) {
+            result[j] = D_ / TSK_MIN(p_A * (1 - p_B), (1 - p_A) * p_B);
+        } else {
+            result[j] = D_ / TSK_MIN(p_A * p_B, (1 - p_A) * (1 - p_B));
+        }
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_D_prime(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result)
+{
+    options |= TSK_STAT_POLARISED; // TODO: allow user to pick?
+    return tsk_treeseq_two_locus_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_sample_sets, NULL, D_prime_summary_func, norm_hap_weighted,
+        num_left_windows, left_windows, num_right_windows, right_windows, options,
+        result_size, result);
+}
+
+static int
+r_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    double n;
+    const double *state_row;
+    tsk_size_t j;
+
+    for (j = 0; j < state_dim; j++) {
+        n = (double) args.sample_set_sizes[j];
+        state_row = GET_2D_ROW(state, 3, j);
+        double p_AB = state_row[0] / n;
+        double p_Ab = state_row[1] / n;
+        double p_aB = state_row[2] / n;
+
+        double p_A = p_AB + p_Ab;
+        double p_B = p_AB + p_aB;
+
+        double D_ = p_AB - (p_A * p_B);
+        double denom = p_A * p_B * (1 - p_A) * (1 - p_B);
+
+        if (denom == 0 && D_ == 0) {
+            result[j] = 0;
+        } else {
+            result[j] = D_ / sqrt(denom);
+        }
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_r(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result)
+{
+    options |= TSK_STAT_POLARISED; // TODO: allow user to pick?
+    return tsk_treeseq_two_locus_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_sample_sets, NULL, r_summary_func, norm_total_weighted,
+        num_left_windows, left_windows, num_right_windows, right_windows, options,
+        result_size, result);
+}
+
+static int
+Dz_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    double n;
+    const double *state_row;
+    tsk_size_t j;
+
+    for (j = 0; j < state_dim; j++) {
+        n = (double) args.sample_set_sizes[j];
+        state_row = GET_2D_ROW(state, 3, j);
+        double p_AB = state_row[0] / n;
+        double p_Ab = state_row[1] / n;
+        double p_aB = state_row[2] / n;
+
+        double p_A = p_AB + p_Ab;
+        double p_B = p_AB + p_aB;
+
+        double D_ = p_AB - (p_A * p_B);
+
+        result[j] = D_ * (1 - 2 * p_A) * (1 - 2 * p_B);
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_Dz(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result)
+{
+    return tsk_treeseq_two_locus_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_sample_sets, NULL, Dz_summary_func, norm_total_weighted,
+        num_left_windows, left_windows, num_right_windows, right_windows, options,
+        result_size, result);
+}
+
+static int
+pi2_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    double n;
+    const double *state_row;
+    tsk_size_t j;
+
+    for (j = 0; j < state_dim; j++) {
+        n = (double) args.sample_set_sizes[j];
+        state_row = GET_2D_ROW(state, 3, j);
+        double p_AB = state_row[0] / n;
+        double p_Ab = state_row[1] / n;
+        double p_aB = state_row[2] / n;
+
+        double p_A = p_AB + p_Ab;
+        double p_B = p_AB + p_aB;
+        result[j] = p_A * (1 - p_A) * p_B * (1 - p_B);
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_pi2(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result)
+{
+    return tsk_treeseq_two_locus_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_sample_sets, NULL, pi2_summary_func, norm_total_weighted,
+        num_left_windows, left_windows, num_right_windows, right_windows, options,
+        result_size, result);
+}
+
+/***********************************
+ * Two way stats
+ ***********************************/
+
+static int
+check_sample_stat_inputs(tsk_size_t num_sample_sets, tsk_size_t tuple_size,
+    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples)
+{
+    int ret = 0;
+
+    if (num_sample_sets < tuple_size) {
+        ret = TSK_ERR_INSUFFICIENT_SAMPLE_SETS;
+        goto out;
+    }
+    if (num_index_tuples < 1) {
+        ret = TSK_ERR_INSUFFICIENT_INDEX_TUPLES;
+        goto out;
+    }
+    ret = check_set_indexes(
+        num_sample_sets, tuple_size * num_index_tuples, index_tuples);
+    if (ret != 0) {
+        goto out;
+    }
+out:
+    return ret;
+}
+
+static int
+divergence_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
+    tsk_size_t result_dim, double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *x = state;
+    double ni, nj, denom;
+    tsk_id_t i, j;
+    tsk_size_t k;
+
+    for (k = 0; k < result_dim; k++) {
+        i = args.set_indexes[2 * k];
+        j = args.set_indexes[2 * k + 1];
+        ni = (double) args.sample_set_sizes[i];
+        nj = (double) args.sample_set_sizes[j];
+        denom = ni * (nj - (i == j));
+        result[k] = x[i] * (nj - x[j]) / denom;
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_divergence(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
+    const double *windows, tsk_flags_t options, double *result)
+{
+    int ret = 0;
+    ret = check_sample_stat_inputs(num_sample_sets, 2, num_index_tuples, index_tuples);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_index_tuples, index_tuples, divergence_summary_func,
+        num_windows, windows, options, result);
+out:
+    return ret;
+}
+
+static int
+genetic_relatedness_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t result_dim, double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *x = state;
+    tsk_id_t i, j;
+    tsk_size_t k;
+    double sumx = 0;
+    double sumn = 0;
+    double meanx, ni, nj;
+
+    for (k = 0; k < state_dim; k++) {
+        sumx += x[k];
+        sumn += (double) args.sample_set_sizes[k];
+    }
+
+    meanx = sumx / sumn;
+    for (k = 0; k < result_dim; k++) {
+        i = args.set_indexes[2 * k];
+        j = args.set_indexes[2 * k + 1];
+        ni = (double) args.sample_set_sizes[i];
+        nj = (double) args.sample_set_sizes[j];
+        result[k] = (x[i] - ni * meanx) * (x[j] - nj * meanx) / 2;
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_genetic_relatedness(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
+    const double *windows, tsk_flags_t options, double *result)
+{
+    int ret = 0;
+    ret = check_sample_stat_inputs(num_sample_sets, 2, num_index_tuples, index_tuples);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_index_tuples, index_tuples, genetic_relatedness_summary_func,
+        num_windows, windows, options, result);
+out:
+    return ret;
+}
+
+static int
+genetic_relatedness_weighted_summary_func(tsk_size_t state_dim, const double *state,
+    tsk_size_t result_dim, double *result, void *params)
+{
+    indexed_weight_stat_params_t args = *(indexed_weight_stat_params_t *) params;
+    const double *x = state;
+    tsk_id_t i, j;
+    tsk_size_t k;
+    double meanx, ni, nj;
+
+    meanx = state[state_dim - 1] / args.total_weights[state_dim - 1];
+    for (k = 0; k < result_dim; k++) {
+        i = args.index_tuples[2 * k];
+        j = args.index_tuples[2 * k + 1];
+        ni = args.total_weights[i];
+        nj = args.total_weights[j];
+        result[k] = (x[i] - ni * meanx) * (x[j] - nj * meanx) / 2;
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_genetic_relatedness_weighted(const tsk_treeseq_t *self,
+    tsk_size_t num_weights, const double *weights, tsk_size_t num_index_tuples,
+    const tsk_id_t *index_tuples, tsk_size_t num_windows, const double *windows,
+    double *result, tsk_flags_t options)
+{
+    int ret = 0;
+    tsk_size_t num_samples = self->num_samples;
+    size_t j, k;
+    indexed_weight_stat_params_t args;
+    const double *row;
+    double *new_row;
+    double *total_weights = tsk_calloc((num_weights + 1), sizeof(*total_weights));
+    double *new_weights
+        = tsk_malloc((num_weights + 1) * num_samples * sizeof(*new_weights));
+
+    if (total_weights == NULL || new_weights == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    if (num_weights == 0) {
+        ret = TSK_ERR_INSUFFICIENT_WEIGHTS;
+        goto out;
+    }
+
+    // Add a column of ones to W
+    for (j = 0; j < num_samples; j++) {
+        row = GET_2D_ROW(weights, num_weights, j);
+        new_row = GET_2D_ROW(new_weights, num_weights + 1, j);
+        for (k = 0; k < num_weights; k++) {
+            new_row[k] = row[k];
+            total_weights[k] += row[k];
+        }
+        new_row[num_weights] = 1.0;
+    }
+    total_weights[num_weights] = (double) num_samples;
+
+    args.total_weights = total_weights;
+    args.index_tuples = index_tuples;
+    ret = tsk_treeseq_general_stat(self, num_weights + 1, new_weights, num_index_tuples,
+        genetic_relatedness_weighted_summary_func, &args, num_windows, windows, options,
+        result);
+    if (ret != 0) {
+        goto out;
+    }
+
+out:
+    tsk_safe_free(total_weights);
+    tsk_safe_free(new_weights);
+    return ret;
+}
+
+static int
+Y2_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
+    tsk_size_t result_dim, double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *x = state;
+    double ni, nj, denom;
+    tsk_id_t i, j;
+    tsk_size_t k;
+
+    for (k = 0; k < result_dim; k++) {
+        i = args.set_indexes[2 * k];
+        j = args.set_indexes[2 * k + 1];
+        ni = (double) args.sample_set_sizes[i];
+        nj = (double) args.sample_set_sizes[j];
+        denom = ni * nj * (nj - 1);
+        result[k] = x[i] * (nj - x[j]) * (nj - x[j] - 1) / denom;
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_Y2(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
+    const double *windows, tsk_flags_t options, double *result)
+{
+    int ret = 0;
+    ret = check_sample_stat_inputs(num_sample_sets, 2, num_index_tuples, index_tuples);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_index_tuples, index_tuples, Y2_summary_func, num_windows,
+        windows, options, result);
+out:
+    return ret;
+}
+
+static int
+f2_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
+    tsk_size_t result_dim, double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *x = state;
+    double ni, nj, denom, numer;
+    tsk_id_t i, j;
+    tsk_size_t k;
+
+    for (k = 0; k < result_dim; k++) {
+        i = args.set_indexes[2 * k];
+        j = args.set_indexes[2 * k + 1];
+        ni = (double) args.sample_set_sizes[i];
+        nj = (double) args.sample_set_sizes[j];
+        denom = ni * (ni - 1) * nj * (nj - 1);
+        numer = x[i] * (x[i] - 1) * (nj - x[j]) * (nj - x[j] - 1)
+                - x[i] * (ni - x[i]) * (nj - x[j]) * x[j];
+        result[k] = numer / denom;
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_f2(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
+    const double *windows, tsk_flags_t options, double *result)
+{
+    int ret = 0;
+    ret = check_sample_stat_inputs(num_sample_sets, 2, num_index_tuples, index_tuples);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_index_tuples, index_tuples, f2_summary_func, num_windows,
+        windows, options, result);
+out:
+    return ret;
+}
+
+/***********************************
+ * Three way stats
+ ***********************************/
+
+static int
+Y3_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
+    tsk_size_t result_dim, double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *x = state;
+    double ni, nj, nk, denom, numer;
+    tsk_id_t i, j, k;
+    tsk_size_t tuple_index;
+
+    for (tuple_index = 0; tuple_index < result_dim; tuple_index++) {
+        i = args.set_indexes[3 * tuple_index];
+        j = args.set_indexes[3 * tuple_index + 1];
+        k = args.set_indexes[3 * tuple_index + 2];
+        ni = (double) args.sample_set_sizes[i];
+        nj = (double) args.sample_set_sizes[j];
+        nk = (double) args.sample_set_sizes[k];
+        denom = ni * nj * nk;
+        numer = x[i] * (nj - x[j]) * (nk - x[k]);
+        result[tuple_index] = numer / denom;
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_Y3(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
+    const double *windows, tsk_flags_t options, double *result)
+{
+    int ret = 0;
+    ret = check_sample_stat_inputs(num_sample_sets, 3, num_index_tuples, index_tuples);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_index_tuples, index_tuples, Y3_summary_func, num_windows,
+        windows, options, result);
+out:
+    return ret;
+}
+
+static int
+f3_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
+    tsk_size_t result_dim, double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *x = state;
+    double ni, nj, nk, denom, numer;
+    tsk_id_t i, j, k;
+    tsk_size_t tuple_index;
+
+    for (tuple_index = 0; tuple_index < result_dim; tuple_index++) {
+        i = args.set_indexes[3 * tuple_index];
+        j = args.set_indexes[3 * tuple_index + 1];
+        k = args.set_indexes[3 * tuple_index + 2];
+        ni = (double) args.sample_set_sizes[i];
+        nj = (double) args.sample_set_sizes[j];
+        nk = (double) args.sample_set_sizes[k];
+        denom = ni * (ni - 1) * nj * nk;
+        numer = x[i] * (x[i] - 1) * (nj - x[j]) * (nk - x[k])
+                - x[i] * (ni - x[i]) * (nj - x[j]) * x[k];
+        result[tuple_index] = numer / denom;
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_f3(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
+    const double *windows, tsk_flags_t options, double *result)
+{
+    int ret = 0;
+    ret = check_sample_stat_inputs(num_sample_sets, 3, num_index_tuples, index_tuples);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_index_tuples, index_tuples, f3_summary_func, num_windows,
+        windows, options, result);
+out:
+    return ret;
+}
+
+/***********************************
+ * Four way stats
+ ***********************************/
+
+static int
+f4_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
+    tsk_size_t result_dim, double *result, void *params)
+{
+    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
+    const double *x = state;
+    double ni, nj, nk, nl, denom, numer;
+    tsk_id_t i, j, k, l;
+    tsk_size_t tuple_index;
+
+    for (tuple_index = 0; tuple_index < result_dim; tuple_index++) {
+        i = args.set_indexes[4 * tuple_index];
+        j = args.set_indexes[4 * tuple_index + 1];
+        k = args.set_indexes[4 * tuple_index + 2];
+        l = args.set_indexes[4 * tuple_index + 3];
+        ni = (double) args.sample_set_sizes[i];
+        nj = (double) args.sample_set_sizes[j];
+        nk = (double) args.sample_set_sizes[k];
+        nl = (double) args.sample_set_sizes[l];
+        denom = ni * nj * nk * nl;
+        numer = x[i] * x[k] * (nj - x[j]) * (nl - x[l])
+                - x[i] * x[l] * (nj - x[j]) * (nk - x[k]);
+        result[tuple_index] = numer / denom;
+    }
+    return 0;
+}
+
+int
+tsk_treeseq_f4(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
+    const double *windows, tsk_flags_t options, double *result)
+{
+    int ret = 0;
+    ret = check_sample_stat_inputs(num_sample_sets, 4, num_index_tuples, index_tuples);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
+        sample_sets, num_index_tuples, index_tuples, f4_summary_func, num_windows,
+        windows, options, result);
+out:
+    return ret;
+}
+
+/* Error-raising getter functions */
+
+int TSK_WARN_UNUSED
+tsk_treeseq_get_node(const tsk_treeseq_t *self, tsk_id_t index, tsk_node_t *node)
+{
+    return tsk_node_table_get_row(&self->tables->nodes, index, node);
+}
+
+int TSK_WARN_UNUSED
+tsk_treeseq_get_edge(const tsk_treeseq_t *self, tsk_id_t index, tsk_edge_t *edge)
+{
+    return tsk_edge_table_get_row(&self->tables->edges, index, edge);
+}
+
+int TSK_WARN_UNUSED
+tsk_treeseq_get_migration(
+    const tsk_treeseq_t *self, tsk_id_t index, tsk_migration_t *migration)
+{
+    return tsk_migration_table_get_row(&self->tables->migrations, index, migration);
+}
+
+int TSK_WARN_UNUSED
+tsk_treeseq_get_mutation(
+    const tsk_treeseq_t *self, tsk_id_t index, tsk_mutation_t *mutation)
+{
+    int ret = 0;
+
+    ret = tsk_mutation_table_get_row(&self->tables->mutations, index, mutation);
+    if (ret != 0) {
+        goto out;
+    }
+    mutation->edge = self->site_mutations_mem[index].edge;
+out:
+    return ret;
+}
+
+int TSK_WARN_UNUSED
+tsk_treeseq_get_site(const tsk_treeseq_t *self, tsk_id_t index, tsk_site_t *site)
+{
+    int ret = 0;
+
+    ret = tsk_site_table_get_row(&self->tables->sites, index, site);
+    if (ret != 0) {
+        goto out;
+    }
+    site->mutations = self->site_mutations[index];
+    site->mutations_length = self->site_mutations_length[index];
+out:
+    return ret;
+}
+
+int TSK_WARN_UNUSED
+tsk_treeseq_get_individual(
+    const tsk_treeseq_t *self, tsk_id_t index, tsk_individual_t *individual)
+{
+    int ret = 0;
+
+    ret = tsk_individual_table_get_row(&self->tables->individuals, index, individual);
+    if (ret != 0) {
+        goto out;
+    }
+    individual->nodes = self->individual_nodes[index];
+    individual->nodes_length = self->individual_nodes_length[index];
+out:
+    return ret;
+}
+
+int TSK_WARN_UNUSED
+tsk_treeseq_get_population(
+    const tsk_treeseq_t *self, tsk_id_t index, tsk_population_t *population)
+{
+    return tsk_population_table_get_row(&self->tables->populations, index, population);
+}
+
+int TSK_WARN_UNUSED
+tsk_treeseq_get_provenance(
+    const tsk_treeseq_t *self, tsk_id_t index, tsk_provenance_t *provenance)
+{
+    return tsk_provenance_table_get_row(&self->tables->provenances, index, provenance);
+}
+
+int TSK_WARN_UNUSED
+tsk_treeseq_simplify(const tsk_treeseq_t *self, const tsk_id_t *samples,
+    tsk_size_t num_samples, tsk_flags_t options, tsk_treeseq_t *output,
+    tsk_id_t *node_map)
+{
+    int ret = 0;
+    tsk_table_collection_t *tables = tsk_malloc(sizeof(*tables));
+
+    if (tables == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    ret = tsk_treeseq_copy_tables(self, tables, 0);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_table_collection_simplify(tables, samples, num_samples, options, node_map);
+    if (ret != 0) {
+        goto out;
+    }
+    ret = tsk_treeseq_init(
+        output, tables, TSK_TS_INIT_BUILD_INDEXES | TSK_TAKE_OWNERSHIP);
+    /* Once tsk_treeseq_init has returned ownership of tables is transferred */
+    tables = NULL;
+out:
+    if (tables != NULL) {
+        tsk_table_collection_free(tables);
+        tsk_safe_free(tables);
+    }
+    return ret;
+}
+
+int TSK_WARN_UNUSED
+tsk_treeseq_split_edges(const tsk_treeseq_t *self, double time, tsk_flags_t flags,
+    tsk_id_t population, const char *metadata, tsk_size_t metadata_length,
+    tsk_flags_t TSK_UNUSED(options), tsk_treeseq_t *output)
+{
+    int ret = 0;
+    tsk_table_collection_t *tables = tsk_malloc(sizeof(*tables));
+    const double *restrict node_time = self->tables->nodes.time;
+    const tsk_size_t num_edges = self->tables->edges.num_rows;
+    const tsk_size_t num_mutations = self->tables->mutations.num_rows;
+    tsk_id_t *split_edge = tsk_malloc(num_edges * sizeof(*split_edge));
+    tsk_id_t j, u, mapped_node, ret_id;
+    double mutation_time;
+    tsk_edge_t edge;
+    tsk_mutation_t mutation;
+    tsk_bookmark_t sort_start;
+
+    memset(output, 0, sizeof(*output));
+    if (split_edge == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    ret = tsk_treeseq_copy_tables(self, tables, 0);
+    if (ret != 0) {
+        goto out;
+    }
+    if (tables->migrations.num_rows > 0) {
+        ret = TSK_ERR_MIGRATIONS_NOT_SUPPORTED;
+        goto out;
+    }
+    /* We could catch this below in add_row, but it's simpler to guarantee
+     * that we always catch the error in corner cases where the values
+     * aren't used. */
+    if (population < -1 || population >= (tsk_id_t) self->tables->populations.num_rows) {
+        ret = TSK_ERR_POPULATION_OUT_OF_BOUNDS;
+        goto out;
+    }
+    if (!tsk_isfinite(time)) {
+        ret = TSK_ERR_TIME_NONFINITE;
+        goto out;
+    }
 
-    m = x[state_dim - 1];
-    for (i = 0; i < result_dim; i++) {
-        if ((m > 0.0) && (m < num_samples)) {
-            v = GET_2D_ROW(V, k, i);
-            a = x[i];
-            denom = m;
-            for (j = 0; j < k; j++) {
-                z = x[result_dim + j];
-                a -= z * v[j];
-                denom -= z * z;
+    tsk_edge_table_clear(&tables->edges);
+    tsk_memset(split_edge, TSK_NULL, num_edges * sizeof(*split_edge));
+
+    for (j = 0; j < (tsk_id_t) num_edges; j++) {
+        /* Would prefer to use tsk_edge_table_get_row_unsafe, but it's
+         * currently static to tables.c */
+        ret = tsk_edge_table_get_row(&self->tables->edges, j, &edge);
+        tsk_bug_assert(ret == 0);
+        if (node_time[edge.child] < time && time < node_time[edge.parent]) {
+            u = tsk_node_table_add_row(&tables->nodes, flags, time, population, TSK_NULL,
+                metadata, metadata_length);
+            if (u < 0) {
+                ret = (int) u;
+                goto out;
             }
-            // denom is the length of projection of the trait onto the subspace
-            // spanned by the covariates, so if it is zero then the system is
-            // singular and the solution is nonunique. This numerical tolerance
-            // could be smaller without hitting floating-point error, but being
-            // a tiny bit conservative about when the trait is almost in the
-            // span of the covariates is probably good.
-            if (denom < 1e-8) {
-                result[i] = 0.0;
-            } else {
-                result[i] = (a * a) / (2 * denom * denom);
+            ret_id = tsk_edge_table_add_row(&tables->edges, edge.left, edge.right, u,
+                edge.child, edge.metadata, edge.metadata_length);
+            if (ret_id < 0) {
+                ret = (int) ret_id;
+                goto out;
             }
-        } else {
-            result[i] = 0.0;
+            edge.child = u;
+            split_edge[j] = u;
+        }
+        ret_id = tsk_edge_table_add_row(&tables->edges, edge.left, edge.right,
+            edge.parent, edge.child, edge.metadata, edge.metadata_length);
+        if (ret_id < 0) {
+            ret = (int) ret_id;
+            goto out;
+        }
+    }
+
+    for (j = 0; j < (tsk_id_t) num_mutations; j++) {
+        /* Note: we could speed this up a bit by accessing the local
+         * memory for mutations directly. */
+        ret = tsk_treeseq_get_mutation(self, j, &mutation);
+        tsk_bug_assert(ret == 0);
+        mapped_node = TSK_NULL;
+        if (mutation.edge != TSK_NULL) {
+            mapped_node = split_edge[mutation.edge];
+        }
+        mutation_time = tsk_is_unknown_time(mutation.time) ? node_time[mutation.node]
+                                                           : mutation.time;
+        if (mapped_node != TSK_NULL && mutation_time >= time) {
+            /* Update the column in-place to save a bit of time. */
+            tables->mutations.node[j] = mapped_node;
         }
     }
+
+    /* Skip mutations and sites as they haven't been altered */
+    /* Note we can probably optimise the edge sort a bit here also by
+     * reasoning about when the first edge gets altered in the table.
+     */
+    memset(&sort_start, 0, sizeof(sort_start));
+    sort_start.sites = tables->sites.num_rows;
+    sort_start.mutations = tables->mutations.num_rows;
+    ret = tsk_table_collection_sort(tables, &sort_start, 0);
+    if (ret != 0) {
+        goto out;
+    }
+
+    ret = tsk_treeseq_init(
+        output, tables, TSK_TS_INIT_BUILD_INDEXES | TSK_TAKE_OWNERSHIP);
+    tables = NULL;
+out:
+    if (tables != NULL) {
+        tsk_table_collection_free(tables);
+        tsk_safe_free(tables);
+    }
+    tsk_safe_free(split_edge);
+    return ret;
+}
+
+/* ======================================================== *
+ * tree_position
+ * ======================================================== */
+
+static void
+tsk_tree_position_set_null(tsk_tree_position_t *self)
+{
+    self->index = -1;
+    self->interval.left = 0;
+    self->interval.right = 0;
+}
+
+int
+tsk_tree_position_init(tsk_tree_position_t *self, const tsk_treeseq_t *tree_sequence,
+    tsk_flags_t TSK_UNUSED(options))
+{
+    memset(self, 0, sizeof(*self));
+    self->tree_sequence = tree_sequence;
+    tsk_tree_position_set_null(self);
     return 0;
 }
 
 int
-tsk_treeseq_trait_linear_model(const tsk_treeseq_t *self, tsk_size_t num_weights,
-    const double *weights, tsk_size_t num_covariates, const double *covariates,
-    tsk_size_t num_windows, const double *windows, tsk_flags_t options, double *result)
+tsk_tree_position_free(tsk_tree_position_t *TSK_UNUSED(self))
 {
-    tsk_size_t num_samples = self->num_samples;
-    tsk_size_t i, j, k;
-    int ret;
-    const double *w, *z;
-    double *v, *new_row;
-    double *V = tsk_calloc(num_covariates * num_weights, sizeof(double));
-    double *new_weights
-        = tsk_malloc((num_weights + num_covariates + 1) * num_samples * sizeof(double));
+    return 0;
+}
 
-    covariates_stat_params_t args
-        = { .num_samples = self->num_samples, .num_covariates = num_covariates, .V = V };
+int
+tsk_tree_position_print_state(const tsk_tree_position_t *self, FILE *out)
+{
+    fprintf(out, "Tree position state\n");
+    fprintf(out, "index = %d\n", (int) self->index);
+    fprintf(
+        out, "out   = start=%d\tstop=%d\n", (int) self->out.start, (int) self->out.stop);
+    fprintf(
+        out, "in    = start=%d\tstop=%d\n", (int) self->in.start, (int) self->in.stop);
+    return 0;
+}
 
-    // We assume that the covariates have been *already standardised*,
-    // so that (a) 1 is in the span of the columns, and
-    // (b) their crossproduct is the identity.
-    // We could do this instead here with gsl linalg.
+bool
+tsk_tree_position_next(tsk_tree_position_t *self)
+{
+    const tsk_table_collection_t *tables = self->tree_sequence->tables;
+    const tsk_id_t M = (tsk_id_t) tables->edges.num_rows;
+    const tsk_id_t num_trees = (tsk_id_t) self->tree_sequence->num_trees;
+    const double *restrict left_coords = tables->edges.left;
+    const tsk_id_t *restrict left_order = tables->indexes.edge_insertion_order;
+    const double *restrict right_coords = tables->edges.right;
+    const tsk_id_t *restrict right_order = tables->indexes.edge_removal_order;
+    const double *restrict breakpoints = self->tree_sequence->breakpoints;
+    tsk_id_t j, left_current_index, right_current_index;
+    double left;
 
-    if (new_weights == NULL || V == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
+    if (self->index == -1) {
+        self->interval.right = 0;
+        self->in.stop = 0;
+        self->out.stop = 0;
+        self->direction = TSK_DIR_FORWARD;
     }
 
-    if (num_weights < 1) {
-        ret = TSK_ERR_BAD_STATE_DIMS;
-        goto out;
+    if (self->direction == TSK_DIR_FORWARD) {
+        left_current_index = self->in.stop;
+        right_current_index = self->out.stop;
+    } else {
+        left_current_index = self->out.stop + 1;
+        right_current_index = self->in.stop + 1;
     }
 
-    // V = weights^T (matrix mult) covariates
-    for (k = 0; k < num_samples; k++) {
-        w = GET_2D_ROW(weights, num_weights, k);
-        z = GET_2D_ROW(covariates, num_covariates, k);
-        for (i = 0; i < num_weights; i++) {
-            v = GET_2D_ROW(V, num_covariates, i);
-            for (j = 0; j < num_covariates; j++) {
-                v[j] += w[i] * z[j];
-            }
-        }
-    }
+    left = self->interval.right;
 
-    for (k = 0; k < num_samples; k++) {
-        w = GET_2D_ROW(weights, num_weights, k);
-        z = GET_2D_ROW(covariates, num_covariates, k);
-        new_row = GET_2D_ROW(new_weights, num_covariates + num_weights + 1, k);
-        for (i = 0; i < num_weights; i++) {
-            new_row[i] = w[i];
-        }
-        for (i = 0; i < num_covariates; i++) {
-            new_row[i + num_weights] = z[i];
-        }
-        // set final row to 1 to count alleles
-        new_row[num_weights + num_covariates] = 1.0;
+    j = right_current_index;
+    self->out.start = j;
+    while (j < M && right_coords[right_order[j]] == left) {
+        j++;
     }
+    self->out.stop = j;
+    self->out.order = right_order;
 
-    ret = tsk_treeseq_general_stat(self, num_weights + num_covariates + 1, new_weights,
-        num_weights, trait_linear_model_summary_func, &args, num_windows, windows,
-        options, result);
+    j = left_current_index;
+    self->in.start = j;
+    while (j < M && left_coords[left_order[j]] == left) {
+        j++;
+    }
+    self->in.stop = j;
+    self->in.order = left_order;
 
-out:
-    tsk_safe_free(V);
-    tsk_safe_free(new_weights);
-    return ret;
+    self->direction = TSK_DIR_FORWARD;
+    self->index++;
+    if (self->index == num_trees) {
+        tsk_tree_position_set_null(self);
+    } else {
+        self->interval.left = left;
+        self->interval.right = breakpoints[self->index + 1];
+    }
+    return self->index != -1;
 }
 
-static int
-segregating_sites_summary_func(tsk_size_t state_dim, const double *state,
-    tsk_size_t TSK_UNUSED(result_dim), double *result, void *params)
+bool
+tsk_tree_position_prev(tsk_tree_position_t *self)
 {
-    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
-    const double *x = state;
-    double n;
-    tsk_size_t j;
+    const tsk_table_collection_t *tables = self->tree_sequence->tables;
+    const tsk_id_t M = (tsk_id_t) tables->edges.num_rows;
+    const double sequence_length = tables->sequence_length;
+    const tsk_id_t num_trees = (tsk_id_t) self->tree_sequence->num_trees;
+    const double *restrict left_coords = tables->edges.left;
+    const tsk_id_t *restrict left_order = tables->indexes.edge_insertion_order;
+    const double *restrict right_coords = tables->edges.right;
+    const tsk_id_t *restrict right_order = tables->indexes.edge_removal_order;
+    const double *restrict breakpoints = self->tree_sequence->breakpoints;
+    tsk_id_t j, left_current_index, right_current_index;
+    double right;
 
-    // this works because sum_{i=1}^k (1-p_i) = k-1
-    for (j = 0; j < state_dim; j++) {
-        n = (double) args.sample_set_sizes[j];
-        result[j] = (x[j] > 0) * (1 - x[j] / n);
+    if (self->index == -1) {
+        self->index = num_trees;
+        self->interval.left = sequence_length;
+        self->in.stop = M - 1;
+        self->out.stop = M - 1;
+        self->direction = TSK_DIR_REVERSE;
     }
-    return 0;
+
+    if (self->direction == TSK_DIR_REVERSE) {
+        left_current_index = self->out.stop;
+        right_current_index = self->in.stop;
+    } else {
+        left_current_index = self->in.stop - 1;
+        right_current_index = self->out.stop - 1;
+    }
+
+    right = self->interval.left;
+
+    j = left_current_index;
+    self->out.start = j;
+    while (j >= 0 && left_coords[left_order[j]] == right) {
+        j--;
+    }
+    self->out.stop = j;
+    self->out.order = left_order;
+
+    j = right_current_index;
+    self->in.start = j;
+    while (j >= 0 && right_coords[right_order[j]] == right) {
+        j--;
+    }
+    self->in.stop = j;
+    self->in.order = right_order;
+
+    self->index--;
+    self->direction = TSK_DIR_REVERSE;
+    if (self->index == -1) {
+        tsk_tree_position_set_null(self);
+    } else {
+        self->interval.left = breakpoints[self->index];
+        self->interval.right = right;
+    }
+    return self->index != -1;
 }
 
-int
-tsk_treeseq_segregating_sites(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
-    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
-    tsk_size_t num_windows, const double *windows, tsk_flags_t options, double *result)
+/* ======================================================== *
+ * Tree
+ * ======================================================== */
+
+/* Return the root for the specified node.
+ * NOTE: no bounds checking is done here.
+ */
+static tsk_id_t
+tsk_tree_get_node_root(const tsk_tree_t *self, tsk_id_t u)
 {
-    return tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
-        sample_sets, num_sample_sets, NULL, segregating_sites_summary_func, num_windows,
-        windows, options, result);
+    const tsk_id_t *restrict parent = self->parent;
+
+    while (parent[u] != TSK_NULL) {
+        u = parent[u];
+    }
+    return u;
 }
 
-static int
-Y1_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
-    tsk_size_t result_dim, double *result, void *params)
+int TSK_WARN_UNUSED
+tsk_tree_init(tsk_tree_t *self, const tsk_treeseq_t *tree_sequence, tsk_flags_t options)
 {
-    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
-    const double *x = state;
-    double ni, denom, numer;
-    tsk_size_t i;
+    int ret = TSK_ERR_NO_MEMORY;
+    tsk_size_t num_samples, num_nodes, N;
 
-    for (i = 0; i < result_dim; i++) {
-        ni = (double) args.sample_set_sizes[i];
-        denom = ni * (ni - 1) * (ni - 2);
-        numer = x[i] * (ni - x[i]) * (ni - x[i] - 1);
-        result[i] = numer / denom;
+    tsk_memset(self, 0, sizeof(tsk_tree_t));
+    if (tree_sequence == NULL) {
+        ret = TSK_ERR_BAD_PARAM_VALUE;
+        goto out;
+    }
+    num_nodes = tree_sequence->tables->nodes.num_rows;
+    num_samples = tree_sequence->num_samples;
+    self->num_nodes = num_nodes;
+    self->virtual_root = (tsk_id_t) num_nodes;
+    self->tree_sequence = tree_sequence;
+    self->samples = tree_sequence->samples;
+    self->options = options;
+    self->root_threshold = 1;
+
+    /* Allocate space in the quintuply linked tree for the virtual root */
+    N = num_nodes + 1;
+    self->parent = tsk_malloc(N * sizeof(*self->parent));
+    self->left_child = tsk_malloc(N * sizeof(*self->left_child));
+    self->right_child = tsk_malloc(N * sizeof(*self->right_child));
+    self->left_sib = tsk_malloc(N * sizeof(*self->left_sib));
+    self->right_sib = tsk_malloc(N * sizeof(*self->right_sib));
+    self->num_children = tsk_calloc(N, sizeof(*self->num_children));
+    self->edge = tsk_malloc(N * sizeof(*self->edge));
+    if (self->parent == NULL || self->left_child == NULL || self->right_child == NULL
+        || self->left_sib == NULL || self->right_sib == NULL
+        || self->num_children == NULL || self->edge == NULL) {
+        goto out;
     }
-    return 0;
+    if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
+        self->num_samples = tsk_calloc(N, sizeof(*self->num_samples));
+        self->num_tracked_samples = tsk_calloc(N, sizeof(*self->num_tracked_samples));
+        if (self->num_samples == NULL || self->num_tracked_samples == NULL) {
+            goto out;
+        }
+    }
+    if (self->options & TSK_SAMPLE_LISTS) {
+        self->left_sample = tsk_malloc(N * sizeof(*self->left_sample));
+        self->right_sample = tsk_malloc(N * sizeof(*self->right_sample));
+        self->next_sample = tsk_malloc(num_samples * sizeof(*self->next_sample));
+        if (self->left_sample == NULL || self->right_sample == NULL
+            || self->next_sample == NULL) {
+            goto out;
+        }
+    }
+    ret = tsk_tree_clear(self);
+out:
+    return ret;
 }
 
 int
-tsk_treeseq_Y1(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
-    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
-    tsk_size_t num_windows, const double *windows, tsk_flags_t options, double *result)
-{
-    return tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
-        sample_sets, num_sample_sets, NULL, Y1_summary_func, num_windows, windows,
-        options, result);
-}
-
-/***********************************
- * Two way stats
- ***********************************/
-
-static int
-check_sample_stat_inputs(tsk_size_t num_sample_sets, tsk_size_t tuple_size,
-    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples)
+tsk_tree_set_root_threshold(tsk_tree_t *self, tsk_size_t root_threshold)
 {
     int ret = 0;
 
-    if (num_sample_sets < tuple_size) {
-        ret = TSK_ERR_INSUFFICIENT_SAMPLE_SETS;
-        goto out;
-    }
-    if (num_index_tuples < 1) {
-        ret = TSK_ERR_INSUFFICIENT_INDEX_TUPLES;
+    if (root_threshold == 0) {
+        ret = TSK_ERR_BAD_PARAM_VALUE;
         goto out;
     }
-    ret = check_set_indexes(
-        num_sample_sets, tuple_size * num_index_tuples, index_tuples);
-    if (ret != 0) {
+    /* Don't allow the value to be set when the tree is out of the null
+     * state */
+    if (self->index != -1) {
+        ret = TSK_ERR_UNSUPPORTED_OPERATION;
         goto out;
     }
+    self->root_threshold = root_threshold;
+    /* Reset the roots */
+    ret = tsk_tree_clear(self);
 out:
     return ret;
 }
 
-static int
-divergence_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
-    tsk_size_t result_dim, double *result, void *params)
+tsk_size_t
+tsk_tree_get_root_threshold(const tsk_tree_t *self)
 {
-    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
-    const double *x = state;
-    double ni, nj, denom;
-    tsk_id_t i, j;
-    tsk_size_t k;
-
-    for (k = 0; k < result_dim; k++) {
-        i = args.set_indexes[2 * k];
-        j = args.set_indexes[2 * k + 1];
-        ni = (double) args.sample_set_sizes[i];
-        nj = (double) args.sample_set_sizes[j];
-        denom = ni * (nj - (i == j));
-        result[k] = x[i] * (nj - x[j]) / denom;
-    }
-    return 0;
+    return self->root_threshold;
 }
 
 int
-tsk_treeseq_divergence(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
-    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
-    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
-    const double *windows, tsk_flags_t options, double *result)
+tsk_tree_free(tsk_tree_t *self)
 {
-    int ret = 0;
-    ret = check_sample_stat_inputs(num_sample_sets, 2, num_index_tuples, index_tuples);
-    if (ret != 0) {
-        goto out;
-    }
-    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
-        sample_sets, num_index_tuples, index_tuples, divergence_summary_func,
-        num_windows, windows, options, result);
-out:
-    return ret;
+    tsk_safe_free(self->parent);
+    tsk_safe_free(self->left_child);
+    tsk_safe_free(self->right_child);
+    tsk_safe_free(self->left_sib);
+    tsk_safe_free(self->right_sib);
+    tsk_safe_free(self->num_samples);
+    tsk_safe_free(self->num_tracked_samples);
+    tsk_safe_free(self->left_sample);
+    tsk_safe_free(self->right_sample);
+    tsk_safe_free(self->next_sample);
+    tsk_safe_free(self->num_children);
+    tsk_safe_free(self->edge);
+    return 0;
 }
 
-static int
-genetic_relatedness_summary_func(tsk_size_t state_dim, const double *state,
-    tsk_size_t result_dim, double *result, void *params)
+bool
+tsk_tree_has_sample_lists(const tsk_tree_t *self)
 {
-    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
-    const double *x = state;
-    tsk_id_t i, j;
-    tsk_size_t k;
-    double sumx = 0;
-    double sumn = 0;
-    double meanx, ni, nj;
-
-    for (k = 0; k < state_dim; k++) {
-        sumx += x[k];
-        sumn += (double) args.sample_set_sizes[k];
-    }
+    return !!(self->options & TSK_SAMPLE_LISTS);
+}
 
-    meanx = sumx / sumn;
-    for (k = 0; k < result_dim; k++) {
-        i = args.set_indexes[2 * k];
-        j = args.set_indexes[2 * k + 1];
-        ni = (double) args.sample_set_sizes[i];
-        nj = (double) args.sample_set_sizes[j];
-        result[k] = (x[i] - ni * meanx) * (x[j] - nj * meanx) / 2;
-    }
-    return 0;
+bool
+tsk_tree_has_sample_counts(const tsk_tree_t *self)
+{
+    return !(self->options & TSK_NO_SAMPLE_COUNTS);
 }
 
-int
-tsk_treeseq_genetic_relatedness(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
-    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
-    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
-    const double *windows, tsk_flags_t options, double *result)
+static int TSK_WARN_UNUSED
+tsk_tree_reset_tracked_samples(tsk_tree_t *self)
 {
     int ret = 0;
-    ret = check_sample_stat_inputs(num_sample_sets, 2, num_index_tuples, index_tuples);
-    if (ret != 0) {
+
+    if (!tsk_tree_has_sample_counts(self)) {
+        ret = TSK_ERR_UNSUPPORTED_OPERATION;
         goto out;
     }
-    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
-        sample_sets, num_index_tuples, index_tuples, genetic_relatedness_summary_func,
-        num_windows, windows, options, result);
+    tsk_memset(self->num_tracked_samples, 0,
+        (self->num_nodes + 1) * sizeof(*self->num_tracked_samples));
 out:
     return ret;
 }
 
-static int
-Y2_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
-    tsk_size_t result_dim, double *result, void *params)
+int TSK_WARN_UNUSED
+tsk_tree_set_tracked_samples(
+    tsk_tree_t *self, tsk_size_t num_tracked_samples, const tsk_id_t *tracked_samples)
 {
-    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
-    const double *x = state;
-    double ni, nj, denom;
-    tsk_id_t i, j;
-    tsk_size_t k;
+    int ret = TSK_ERR_GENERIC;
+    tsk_size_t *tree_num_tracked_samples = self->num_tracked_samples;
+    const tsk_id_t *parent = self->parent;
+    tsk_size_t j;
+    tsk_id_t u;
 
-    for (k = 0; k < result_dim; k++) {
-        i = args.set_indexes[2 * k];
-        j = args.set_indexes[2 * k + 1];
-        ni = (double) args.sample_set_sizes[i];
-        nj = (double) args.sample_set_sizes[j];
-        denom = ni * nj * (nj - 1);
-        result[k] = x[i] * (nj - x[j]) * (nj - x[j] - 1) / denom;
+    /* TODO This is not needed when the tree is new. We should use the
+     * state machine to check and only reset the tracked samples when needed.
+     */
+    ret = tsk_tree_reset_tracked_samples(self);
+    if (ret != 0) {
+        goto out;
     }
-    return 0;
+    self->num_tracked_samples[self->virtual_root] = num_tracked_samples;
+    for (j = 0; j < num_tracked_samples; j++) {
+        u = tracked_samples[j];
+        if (u < 0 || u >= (tsk_id_t) self->num_nodes) {
+            ret = TSK_ERR_NODE_OUT_OF_BOUNDS;
+            goto out;
+        }
+        if (!tsk_treeseq_is_sample(self->tree_sequence, u)) {
+            ret = TSK_ERR_BAD_SAMPLES;
+            goto out;
+        }
+        if (self->num_tracked_samples[u] != 0) {
+            ret = TSK_ERR_DUPLICATE_SAMPLE;
+            goto out;
+        }
+        /* Propagate this upwards */
+        while (u != TSK_NULL) {
+            tree_num_tracked_samples[u]++;
+            u = parent[u];
+        }
+    }
+out:
+    return ret;
 }
 
-int
-tsk_treeseq_Y2(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
-    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
-    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
-    const double *windows, tsk_flags_t options, double *result)
+int TSK_WARN_UNUSED
+tsk_tree_track_descendant_samples(tsk_tree_t *self, tsk_id_t node)
 {
     int ret = 0;
-    ret = check_sample_stat_inputs(num_sample_sets, 2, num_index_tuples, index_tuples);
+    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
+    const tsk_id_t *restrict parent = self->parent;
+    const tsk_id_t *restrict left_child = self->left_child;
+    const tsk_id_t *restrict right_sib = self->right_sib;
+    const tsk_flags_t *restrict flags = self->tree_sequence->tables->nodes.flags;
+    tsk_size_t *num_tracked_samples = self->num_tracked_samples;
+    tsk_size_t n, j, num_nodes;
+    tsk_id_t u, v;
+
+    if (nodes == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    ret = tsk_tree_postorder_from(self, node, nodes, &num_nodes);
     if (ret != 0) {
         goto out;
     }
-    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
-        sample_sets, num_index_tuples, index_tuples, Y2_summary_func, num_windows,
-        windows, options, result);
+    ret = tsk_tree_reset_tracked_samples(self);
+    if (ret != 0) {
+        goto out;
+    }
+    u = 0; /* keep the compiler happy */
+    for (j = 0; j < num_nodes; j++) {
+        u = nodes[j];
+        for (v = left_child[u]; v != TSK_NULL; v = right_sib[v]) {
+            num_tracked_samples[u] += num_tracked_samples[v];
+        }
+        num_tracked_samples[u] += flags[u] & TSK_NODE_IS_SAMPLE ? 1 : 0;
+    }
+    n = num_tracked_samples[u];
+    u = parent[u];
+    while (u != TSK_NULL) {
+        num_tracked_samples[u] = n;
+        u = parent[u];
+    }
+    num_tracked_samples[self->virtual_root] = n;
 out:
+    tsk_safe_free(nodes);
     return ret;
 }
 
-static int
-f2_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
-    tsk_size_t result_dim, double *result, void *params)
+int TSK_WARN_UNUSED
+tsk_tree_copy(const tsk_tree_t *self, tsk_tree_t *dest, tsk_flags_t options)
 {
-    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
-    const double *x = state;
-    double ni, nj, denom, numer;
-    tsk_id_t i, j;
-    tsk_size_t k;
+    int ret = TSK_ERR_GENERIC;
+    tsk_size_t N = self->num_nodes + 1;
 
-    for (k = 0; k < result_dim; k++) {
-        i = args.set_indexes[2 * k];
-        j = args.set_indexes[2 * k + 1];
-        ni = (double) args.sample_set_sizes[i];
-        nj = (double) args.sample_set_sizes[j];
-        denom = ni * (ni - 1) * nj * (nj - 1);
-        numer = x[i] * (x[i] - 1) * (nj - x[j]) * (nj - x[j] - 1)
-                - x[i] * (ni - x[i]) * (nj - x[j]) * x[j];
-        result[k] = numer / denom;
+    if (!(options & TSK_NO_INIT)) {
+        ret = tsk_tree_init(dest, self->tree_sequence, options);
+        if (ret != 0) {
+            goto out;
+        }
     }
-    return 0;
-}
-
-int
-tsk_treeseq_f2(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
-    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
-    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
-    const double *windows, tsk_flags_t options, double *result)
-{
-    int ret = 0;
-    ret = check_sample_stat_inputs(num_sample_sets, 2, num_index_tuples, index_tuples);
-    if (ret != 0) {
+    if (self->tree_sequence != dest->tree_sequence) {
+        ret = TSK_ERR_BAD_PARAM_VALUE;
         goto out;
     }
-    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
-        sample_sets, num_index_tuples, index_tuples, f2_summary_func, num_windows,
-        windows, options, result);
+    dest->interval = self->interval;
+    dest->left_index = self->left_index;
+    dest->right_index = self->right_index;
+    dest->direction = self->direction;
+    dest->index = self->index;
+    dest->sites = self->sites;
+    dest->sites_length = self->sites_length;
+    dest->root_threshold = self->root_threshold;
+    dest->num_edges = self->num_edges;
+
+    tsk_memcpy(dest->parent, self->parent, N * sizeof(*self->parent));
+    tsk_memcpy(dest->left_child, self->left_child, N * sizeof(*self->left_child));
+    tsk_memcpy(dest->right_child, self->right_child, N * sizeof(*self->right_child));
+    tsk_memcpy(dest->left_sib, self->left_sib, N * sizeof(*self->left_sib));
+    tsk_memcpy(dest->right_sib, self->right_sib, N * sizeof(*self->right_sib));
+    tsk_memcpy(dest->num_children, self->num_children, N * sizeof(*self->num_children));
+    tsk_memcpy(dest->edge, self->edge, N * sizeof(*self->edge));
+    if (!(dest->options & TSK_NO_SAMPLE_COUNTS)) {
+        if (self->options & TSK_NO_SAMPLE_COUNTS) {
+            ret = TSK_ERR_UNSUPPORTED_OPERATION;
+            goto out;
+        }
+        tsk_memcpy(dest->num_samples, self->num_samples, N * sizeof(*self->num_samples));
+        tsk_memcpy(dest->num_tracked_samples, self->num_tracked_samples,
+            N * sizeof(*self->num_tracked_samples));
+    }
+    if (dest->options & TSK_SAMPLE_LISTS) {
+        if (!(self->options & TSK_SAMPLE_LISTS)) {
+            ret = TSK_ERR_UNSUPPORTED_OPERATION;
+            goto out;
+        }
+        tsk_memcpy(dest->left_sample, self->left_sample, N * sizeof(*self->left_sample));
+        tsk_memcpy(
+            dest->right_sample, self->right_sample, N * sizeof(*self->right_sample));
+        tsk_memcpy(dest->next_sample, self->next_sample,
+            self->tree_sequence->num_samples * sizeof(*self->next_sample));
+    }
+    ret = 0;
 out:
     return ret;
 }
 
-/***********************************
- * Three way stats
- ***********************************/
-
-static int
-Y3_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
-    tsk_size_t result_dim, double *result, void *params)
+bool TSK_WARN_UNUSED
+tsk_tree_equals(const tsk_tree_t *self, const tsk_tree_t *other)
 {
-    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
-    const double *x = state;
-    double ni, nj, nk, denom, numer;
-    tsk_id_t i, j, k;
-    tsk_size_t tuple_index;
+    bool ret = false;
 
-    for (tuple_index = 0; tuple_index < result_dim; tuple_index++) {
-        i = args.set_indexes[3 * tuple_index];
-        j = args.set_indexes[3 * tuple_index + 1];
-        k = args.set_indexes[3 * tuple_index + 2];
-        ni = (double) args.sample_set_sizes[i];
-        nj = (double) args.sample_set_sizes[j];
-        nk = (double) args.sample_set_sizes[k];
-        denom = ni * nj * nk;
-        numer = x[i] * (nj - x[j]) * (nk - x[k]);
-        result[tuple_index] = numer / denom;
+    if (self->tree_sequence == other->tree_sequence) {
+        ret = self->index == other->index;
     }
-    return 0;
+    return ret;
 }
 
-int
-tsk_treeseq_Y3(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
-    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
-    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
-    const double *windows, tsk_flags_t options, double *result)
+static int
+tsk_tree_check_node(const tsk_tree_t *self, tsk_id_t u)
 {
     int ret = 0;
-    ret = check_sample_stat_inputs(num_sample_sets, 3, num_index_tuples, index_tuples);
-    if (ret != 0) {
-        goto out;
+    if (u < 0 || u > (tsk_id_t) self->num_nodes) {
+        ret = TSK_ERR_NODE_OUT_OF_BOUNDS;
     }
-    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
-        sample_sets, num_index_tuples, index_tuples, Y3_summary_func, num_windows,
-        windows, options, result);
-out:
     return ret;
 }
 
-static int
-f3_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
-    tsk_size_t result_dim, double *result, void *params)
+bool
+tsk_tree_is_descendant(const tsk_tree_t *self, tsk_id_t u, tsk_id_t v)
 {
-    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
-    const double *x = state;
-    double ni, nj, nk, denom, numer;
-    tsk_id_t i, j, k;
-    tsk_size_t tuple_index;
+    bool ret = false;
+    tsk_id_t w = u;
+    tsk_id_t *restrict parent = self->parent;
 
-    for (tuple_index = 0; tuple_index < result_dim; tuple_index++) {
-        i = args.set_indexes[3 * tuple_index];
-        j = args.set_indexes[3 * tuple_index + 1];
-        k = args.set_indexes[3 * tuple_index + 2];
-        ni = (double) args.sample_set_sizes[i];
-        nj = (double) args.sample_set_sizes[j];
-        nk = (double) args.sample_set_sizes[k];
-        denom = ni * (ni - 1) * nj * nk;
-        numer = x[i] * (x[i] - 1) * (nj - x[j]) * (nk - x[k])
-                - x[i] * (ni - x[i]) * (nj - x[j]) * x[k];
-        result[tuple_index] = numer / denom;
+    if (tsk_tree_check_node(self, u) == 0 && tsk_tree_check_node(self, v) == 0) {
+        while (w != v && w != TSK_NULL) {
+            w = parent[w];
+        }
+        ret = w == v;
     }
-    return 0;
+    return ret;
 }
 
-int
-tsk_treeseq_f3(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
-    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
-    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
-    const double *windows, tsk_flags_t options, double *result)
+int TSK_WARN_UNUSED
+tsk_tree_get_mrca(const tsk_tree_t *self, tsk_id_t u, tsk_id_t v, tsk_id_t *mrca)
 {
     int ret = 0;
-    ret = check_sample_stat_inputs(num_sample_sets, 3, num_index_tuples, index_tuples);
+    double tu, tv;
+    const tsk_id_t *restrict parent = self->parent;
+    const double *restrict time = self->tree_sequence->tables->nodes.time;
+
+    ret = tsk_tree_check_node(self, u);
     if (ret != 0) {
         goto out;
     }
-    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
-        sample_sets, num_index_tuples, index_tuples, f3_summary_func, num_windows,
-        windows, options, result);
+    ret = tsk_tree_check_node(self, v);
+    if (ret != 0) {
+        goto out;
+    }
+
+    /* Simplest to make the virtual_root a special case here to avoid
+     * doing the time lookup. */
+    if (u == self->virtual_root || v == self->virtual_root) {
+        *mrca = self->virtual_root;
+        return 0;
+    }
+
+    tu = time[u];
+    tv = time[v];
+    while (u != v) {
+        if (tu < tv) {
+            u = parent[u];
+            if (u == TSK_NULL) {
+                break;
+            }
+            tu = time[u];
+        } else {
+            v = parent[v];
+            if (v == TSK_NULL) {
+                break;
+            }
+            tv = time[v];
+        }
+    }
+    *mrca = u == v ? u : TSK_NULL;
 out:
     return ret;
 }
 
-/***********************************
- * Four way stats
- ***********************************/
-
 static int
-f4_summary_func(tsk_size_t TSK_UNUSED(state_dim), const double *state,
-    tsk_size_t result_dim, double *result, void *params)
+tsk_tree_get_num_samples_by_traversal(
+    const tsk_tree_t *self, tsk_id_t u, tsk_size_t *num_samples)
 {
-    sample_count_stat_params_t args = *(sample_count_stat_params_t *) params;
-    const double *x = state;
-    double ni, nj, nk, nl, denom, numer;
-    tsk_id_t i, j, k, l;
-    tsk_size_t tuple_index;
+    int ret = 0;
+    tsk_size_t num_nodes, j;
+    tsk_size_t count = 0;
+    const tsk_flags_t *restrict flags = self->tree_sequence->tables->nodes.flags;
+    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
+    tsk_id_t v;
 
-    for (tuple_index = 0; tuple_index < result_dim; tuple_index++) {
-        i = args.set_indexes[4 * tuple_index];
-        j = args.set_indexes[4 * tuple_index + 1];
-        k = args.set_indexes[4 * tuple_index + 2];
-        l = args.set_indexes[4 * tuple_index + 3];
-        ni = (double) args.sample_set_sizes[i];
-        nj = (double) args.sample_set_sizes[j];
-        nk = (double) args.sample_set_sizes[k];
-        nl = (double) args.sample_set_sizes[l];
-        denom = ni * nj * nk * nl;
-        numer = x[i] * x[k] * (nj - x[j]) * (nl - x[l])
-                - x[i] * x[l] * (nj - x[j]) * (nk - x[k]);
-        result[tuple_index] = numer / denom;
+    if (nodes == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
     }
-    return 0;
+    ret = tsk_tree_preorder_from(self, u, nodes, &num_nodes);
+    if (ret != 0) {
+        goto out;
+    }
+    for (j = 0; j < num_nodes; j++) {
+        v = nodes[j];
+        if (flags[v] & TSK_NODE_IS_SAMPLE) {
+            count++;
+        }
+    }
+    *num_samples = count;
+out:
+    tsk_safe_free(nodes);
+    return ret;
 }
 
-int
-tsk_treeseq_f4(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
-    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
-    tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
-    const double *windows, tsk_flags_t options, double *result)
+int TSK_WARN_UNUSED
+tsk_tree_get_num_samples(const tsk_tree_t *self, tsk_id_t u, tsk_size_t *num_samples)
 {
     int ret = 0;
-    ret = check_sample_stat_inputs(num_sample_sets, 4, num_index_tuples, index_tuples);
+
+    ret = tsk_tree_check_node(self, u);
     if (ret != 0) {
         goto out;
     }
-    ret = tsk_treeseq_sample_count_stat(self, num_sample_sets, sample_set_sizes,
-        sample_sets, num_index_tuples, index_tuples, f4_summary_func, num_windows,
-        windows, options, result);
+
+    if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
+        *num_samples = (tsk_size_t) self->num_samples[u];
+    } else {
+        ret = tsk_tree_get_num_samples_by_traversal(self, u, num_samples);
+    }
 out:
     return ret;
 }
 
-/* Error-raising getter functions */
-
 int TSK_WARN_UNUSED
-tsk_treeseq_get_node(const tsk_treeseq_t *self, tsk_id_t index, tsk_node_t *node)
+tsk_tree_get_num_tracked_samples(
+    const tsk_tree_t *self, tsk_id_t u, tsk_size_t *num_tracked_samples)
 {
-    return tsk_node_table_get_row(&self->tables->nodes, index, node);
+    int ret = 0;
+
+    ret = tsk_tree_check_node(self, u);
+    if (ret != 0) {
+        goto out;
+    }
+    if (self->options & TSK_NO_SAMPLE_COUNTS) {
+        ret = TSK_ERR_UNSUPPORTED_OPERATION;
+        goto out;
+    }
+    *num_tracked_samples = self->num_tracked_samples[u];
+out:
+    return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_treeseq_get_edge(const tsk_treeseq_t *self, tsk_id_t index, tsk_edge_t *edge)
+bool
+tsk_tree_is_sample(const tsk_tree_t *self, tsk_id_t u)
 {
-    return tsk_edge_table_get_row(&self->tables->edges, index, edge);
+    return tsk_treeseq_is_sample(self->tree_sequence, u);
 }
 
-int TSK_WARN_UNUSED
-tsk_treeseq_get_migration(
-    const tsk_treeseq_t *self, tsk_id_t index, tsk_migration_t *migration)
+tsk_id_t
+tsk_tree_get_left_root(const tsk_tree_t *self)
 {
-    return tsk_migration_table_get_row(&self->tables->migrations, index, migration);
+    return self->left_child[self->virtual_root];
 }
 
-int TSK_WARN_UNUSED
-tsk_treeseq_get_mutation(
-    const tsk_treeseq_t *self, tsk_id_t index, tsk_mutation_t *mutation)
+tsk_id_t
+tsk_tree_get_right_root(const tsk_tree_t *self)
 {
-    int ret = 0;
+    return self->right_child[self->virtual_root];
+}
 
-    ret = tsk_mutation_table_get_row(&self->tables->mutations, index, mutation);
-    if (ret != 0) {
-        goto out;
-    }
-    mutation->edge = self->site_mutations_mem[index].edge;
-out:
-    return ret;
+tsk_size_t
+tsk_tree_get_num_roots(const tsk_tree_t *self)
+{
+    return (tsk_size_t) self->num_children[self->virtual_root];
 }
 
 int TSK_WARN_UNUSED
-tsk_treeseq_get_site(const tsk_treeseq_t *self, tsk_id_t index, tsk_site_t *site)
+tsk_tree_get_parent(const tsk_tree_t *self, tsk_id_t u, tsk_id_t *parent)
 {
     int ret = 0;
 
-    ret = tsk_site_table_get_row(&self->tables->sites, index, site);
+    ret = tsk_tree_check_node(self, u);
     if (ret != 0) {
         goto out;
     }
-    site->mutations = self->site_mutations[index];
-    site->mutations_length = self->site_mutations_length[index];
+    *parent = self->parent[u];
 out:
     return ret;
 }
 
 int TSK_WARN_UNUSED
-tsk_treeseq_get_individual(
-    const tsk_treeseq_t *self, tsk_id_t index, tsk_individual_t *individual)
+tsk_tree_get_time(const tsk_tree_t *self, tsk_id_t u, double *t)
 {
     int ret = 0;
+    tsk_node_t node;
 
-    ret = tsk_individual_table_get_row(&self->tables->individuals, index, individual);
-    if (ret != 0) {
-        goto out;
+    if (u == self->virtual_root) {
+        *t = INFINITY;
+    } else {
+        ret = tsk_treeseq_get_node(self->tree_sequence, u, &node);
+        if (ret != 0) {
+            goto out;
+        }
+        *t = node.time;
     }
-    individual->nodes = self->individual_nodes[index];
-    individual->nodes_length = self->individual_nodes_length[index];
 out:
     return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_treeseq_get_population(
-    const tsk_treeseq_t *self, tsk_id_t index, tsk_population_t *population)
+static inline double
+tsk_tree_get_branch_length_unsafe(const tsk_tree_t *self, tsk_id_t u)
 {
-    return tsk_population_table_get_row(&self->tables->populations, index, population);
-}
+    const double *times = self->tree_sequence->tables->nodes.time;
+    const tsk_id_t parent = self->parent[u];
 
-int TSK_WARN_UNUSED
-tsk_treeseq_get_provenance(
-    const tsk_treeseq_t *self, tsk_id_t index, tsk_provenance_t *provenance)
-{
-    return tsk_provenance_table_get_row(&self->tables->provenances, index, provenance);
+    return parent == TSK_NULL ? 0 : times[parent] - times[u];
 }
 
 int TSK_WARN_UNUSED
-tsk_treeseq_simplify(const tsk_treeseq_t *self, const tsk_id_t *samples,
-    tsk_size_t num_samples, tsk_flags_t options, tsk_treeseq_t *output,
-    tsk_id_t *node_map)
+tsk_tree_get_branch_length(const tsk_tree_t *self, tsk_id_t u, double *ret_branch_length)
 {
     int ret = 0;
-    tsk_table_collection_t *tables = tsk_malloc(sizeof(*tables));
 
-    if (tables == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
-    }
-    ret = tsk_treeseq_copy_tables(self, tables, 0);
-    if (ret != 0) {
-        goto out;
-    }
-    ret = tsk_table_collection_simplify(tables, samples, num_samples, options, node_map);
+    ret = tsk_tree_check_node(self, u);
     if (ret != 0) {
         goto out;
     }
-    ret = tsk_treeseq_init(
-        output, tables, TSK_TS_INIT_BUILD_INDEXES | TSK_TAKE_OWNERSHIP);
-    /* Once tsk_tree_init has returned ownership of tables is transferred */
-    tables = NULL;
+    *ret_branch_length = tsk_tree_get_branch_length_unsafe(self, u);
 out:
-    if (tables != NULL) {
-        tsk_table_collection_free(tables);
-        tsk_safe_free(tables);
-    }
     return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_treeseq_split_edges(const tsk_treeseq_t *self, double time, tsk_flags_t flags,
-    tsk_id_t population, const char *metadata, tsk_size_t metadata_length,
-    tsk_flags_t TSK_UNUSED(options), tsk_treeseq_t *output)
+int
+tsk_tree_get_total_branch_length(const tsk_tree_t *self, tsk_id_t node, double *ret_tbl)
 {
     int ret = 0;
-    tsk_table_collection_t *tables = tsk_malloc(sizeof(*tables));
-    const double *restrict node_time = self->tables->nodes.time;
-    const tsk_size_t num_edges = self->tables->edges.num_rows;
-    const tsk_size_t num_mutations = self->tables->mutations.num_rows;
-    tsk_id_t *split_edge = tsk_malloc(num_edges * sizeof(*split_edge));
-    tsk_id_t j, u, mapped_node, ret_id;
-    double mutation_time;
-    tsk_edge_t edge;
-    tsk_mutation_t mutation;
-    tsk_bookmark_t sort_start;
+    tsk_size_t j, num_nodes;
+    tsk_id_t u, v;
+    const tsk_id_t *restrict parent = self->parent;
+    const double *restrict time = self->tree_sequence->tables->nodes.time;
+    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
+    double sum = 0;
 
-    memset(output, 0, sizeof(*output));
-    if (split_edge == NULL) {
+    if (nodes == NULL) {
         ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
-    ret = tsk_treeseq_copy_tables(self, tables, 0);
+    ret = tsk_tree_preorder_from(self, node, nodes, &num_nodes);
     if (ret != 0) {
         goto out;
     }
-    if (tables->migrations.num_rows > 0) {
-        ret = TSK_ERR_MIGRATIONS_NOT_SUPPORTED;
-        goto out;
-    }
-    /* We could catch this below in add_row, but it's simpler to guarantee
-     * that we always catch the error in corner cases where the values
-     * aren't used. */
-    if (population < -1 || population >= (tsk_id_t) self->tables->populations.num_rows) {
-        ret = TSK_ERR_POPULATION_OUT_OF_BOUNDS;
-        goto out;
-    }
-    if (!tsk_isfinite(time)) {
-        ret = TSK_ERR_TIME_NONFINITE;
-        goto out;
+    /* We always skip the first node because we don't return the branch length
+     * over the input node. */
+    for (j = 1; j < num_nodes; j++) {
+        u = nodes[j];
+        v = parent[u];
+        if (v != TSK_NULL) {
+            sum += time[v] - time[u];
+        }
     }
+    *ret_tbl = sum;
+out:
+    tsk_safe_free(nodes);
+    return ret;
+}
 
-    tsk_edge_table_clear(&tables->edges);
-    tsk_memset(split_edge, TSK_NULL, num_edges * sizeof(*split_edge));
+int TSK_WARN_UNUSED
+tsk_tree_get_sites(
+    const tsk_tree_t *self, const tsk_site_t **sites, tsk_size_t *sites_length)
+{
+    *sites = self->sites;
+    *sites_length = self->sites_length;
+    return 0;
+}
 
-    for (j = 0; j < (tsk_id_t) num_edges; j++) {
-        /* Would prefer to use tsk_edge_table_get_row_unsafe, but it's
-         * currently static to tables.c */
-        ret = tsk_edge_table_get_row(&self->tables->edges, j, &edge);
-        tsk_bug_assert(ret == 0);
-        if (node_time[edge.child] < time && time < node_time[edge.parent]) {
-            u = tsk_node_table_add_row(&tables->nodes, flags, time, population, TSK_NULL,
-                metadata, metadata_length);
-            if (u < 0) {
-                ret = (int) u;
-                goto out;
-            }
-            ret_id = tsk_edge_table_add_row(&tables->edges, edge.left, edge.right, u,
-                edge.child, edge.metadata, edge.metadata_length);
-            if (ret_id < 0) {
-                ret = (int) ret_id;
-                goto out;
-            }
-            edge.child = u;
-            split_edge[j] = u;
-        }
-        ret_id = tsk_edge_table_add_row(&tables->edges, edge.left, edge.right,
-            edge.parent, edge.child, edge.metadata, edge.metadata_length);
-        if (ret_id < 0) {
-            ret = (int) ret_id;
-            goto out;
-        }
-    }
+/* u must be a valid node in the tree. For internal use */
+static int
+tsk_tree_get_depth_unsafe(const tsk_tree_t *self, tsk_id_t u)
+{
+    tsk_id_t v;
+    const tsk_id_t *restrict parent = self->parent;
+    int depth = 0;
 
-    for (j = 0; j < (tsk_id_t) num_mutations; j++) {
-        /* Note: we could speed this up a bit by accessing the local
-         * memory for mutations directly. */
-        ret = tsk_treeseq_get_mutation(self, j, &mutation);
-        tsk_bug_assert(ret == 0);
-        mapped_node = TSK_NULL;
-        if (mutation.edge != TSK_NULL) {
-            mapped_node = split_edge[mutation.edge];
-        }
-        mutation_time = tsk_is_unknown_time(mutation.time) ? node_time[mutation.node]
-                                                           : mutation.time;
-        if (mapped_node != TSK_NULL && mutation_time >= time) {
-            /* Update the column in-place to save a bit of time. */
-            tables->mutations.node[j] = mapped_node;
-        }
+    if (u == self->virtual_root) {
+        return -1;
+    }
+    for (v = parent[u]; v != TSK_NULL; v = parent[v]) {
+        depth++;
     }
+    return depth;
+}
+
+int TSK_WARN_UNUSED
+tsk_tree_get_depth(const tsk_tree_t *self, tsk_id_t u, int *depth_ret)
+{
+    int ret = 0;
 
-    /* Skip mutations and sites as they haven't been altered */
-    /* Note we can probably optimise the edge sort a bit here also by
-     * reasoning about when the first edge gets altered in the table.
-     */
-    memset(&sort_start, 0, sizeof(sort_start));
-    sort_start.sites = tables->sites.num_rows;
-    sort_start.mutations = tables->mutations.num_rows;
-    ret = tsk_table_collection_sort(tables, &sort_start, 0);
+    ret = tsk_tree_check_node(self, u);
     if (ret != 0) {
         goto out;
     }
 
-    ret = tsk_treeseq_init(
-        output, tables, TSK_TS_INIT_BUILD_INDEXES | TSK_TAKE_OWNERSHIP);
-    tables = NULL;
+    *depth_ret = tsk_tree_get_depth_unsafe(self, u);
 out:
-    if (tables != NULL) {
-        tsk_table_collection_free(tables);
-        tsk_safe_free(tables);
-    }
-    tsk_safe_free(split_edge);
     return ret;
 }
 
-/* ======================================================== *
- * Tree
- * ======================================================== */
+static tsk_id_t
+tsk_tree_node_root(tsk_tree_t *self, tsk_id_t u)
+{
+    tsk_id_t v = u;
+    while (self->parent[v] != TSK_NULL) {
+        v = self->parent[v];
+    }
 
-int TSK_WARN_UNUSED
-tsk_tree_init(tsk_tree_t *self, const tsk_treeseq_t *tree_sequence, tsk_flags_t options)
+    return v;
+}
+
+static void
+tsk_tree_check_state(const tsk_tree_t *self)
 {
-    int ret = TSK_ERR_NO_MEMORY;
-    tsk_size_t num_samples, num_nodes, N;
+    tsk_id_t u, v;
+    tsk_size_t j, num_samples;
+    int err, c;
+    tsk_site_t site;
+    tsk_id_t *children = tsk_malloc(self->num_nodes * sizeof(tsk_id_t));
+    bool *is_root = tsk_calloc(self->num_nodes, sizeof(bool));
 
-    tsk_memset(self, 0, sizeof(tsk_tree_t));
-    if (tree_sequence == NULL) {
-        ret = TSK_ERR_BAD_PARAM_VALUE;
-        goto out;
+    tsk_bug_assert(children != NULL);
+
+    /* Check the virtual root properties */
+    tsk_bug_assert(self->parent[self->virtual_root] == TSK_NULL);
+    tsk_bug_assert(self->left_sib[self->virtual_root] == TSK_NULL);
+    tsk_bug_assert(self->right_sib[self->virtual_root] == TSK_NULL);
+
+    for (j = 0; j < self->tree_sequence->num_samples; j++) {
+        u = self->samples[j];
+        while (self->parent[u] != TSK_NULL) {
+            u = self->parent[u];
+        }
+        is_root[u] = true;
+    }
+    if (self->tree_sequence->num_samples == 0) {
+        tsk_bug_assert(self->left_child[self->virtual_root] == TSK_NULL);
     }
-    num_nodes = tree_sequence->tables->nodes.num_rows;
-    num_samples = tree_sequence->num_samples;
-    self->num_nodes = num_nodes;
-    self->virtual_root = (tsk_id_t) num_nodes;
-    self->tree_sequence = tree_sequence;
-    self->samples = tree_sequence->samples;
-    self->options = options;
-    self->root_threshold = 1;
 
-    /* Allocate space in the quintuply linked tree for the virtual root */
-    N = num_nodes + 1;
-    self->parent = tsk_malloc(N * sizeof(*self->parent));
-    self->left_child = tsk_malloc(N * sizeof(*self->left_child));
-    self->right_child = tsk_malloc(N * sizeof(*self->right_child));
-    self->left_sib = tsk_malloc(N * sizeof(*self->left_sib));
-    self->right_sib = tsk_malloc(N * sizeof(*self->right_sib));
-    self->num_children = tsk_calloc(N, sizeof(*self->num_children));
-    self->edge = tsk_malloc(N * sizeof(*self->edge));
-    if (self->parent == NULL || self->left_child == NULL || self->right_child == NULL
-        || self->left_sib == NULL || self->right_sib == NULL
-        || self->num_children == NULL || self->edge == NULL) {
-        goto out;
+    /* Iterate over the roots and make sure they are set */
+    for (u = tsk_tree_get_left_root(self); u != TSK_NULL; u = self->right_sib[u]) {
+        tsk_bug_assert(is_root[u]);
+        is_root[u] = false;
+    }
+    for (u = 0; u < (tsk_id_t) self->num_nodes; u++) {
+        tsk_bug_assert(!is_root[u]);
+        c = 0;
+        for (v = self->left_child[u]; v != TSK_NULL; v = self->right_sib[v]) {
+            tsk_bug_assert(self->parent[v] == u);
+            children[c] = v;
+            c++;
+        }
+        for (v = self->right_child[u]; v != TSK_NULL; v = self->left_sib[v]) {
+            tsk_bug_assert(c > 0);
+            c--;
+            tsk_bug_assert(v == children[c]);
+        }
+    }
+    for (j = 0; j < self->sites_length; j++) {
+        site = self->sites[j];
+        tsk_bug_assert(self->interval.left <= site.position);
+        tsk_bug_assert(site.position < self->interval.right);
     }
+
     if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
-        self->num_samples = tsk_calloc(N, sizeof(*self->num_samples));
-        self->num_tracked_samples = tsk_calloc(N, sizeof(*self->num_tracked_samples));
-        if (self->num_samples == NULL || self->num_tracked_samples == NULL) {
-            goto out;
+        tsk_bug_assert(self->num_samples != NULL);
+        tsk_bug_assert(self->num_tracked_samples != NULL);
+        for (u = 0; u < (tsk_id_t) self->num_nodes; u++) {
+            err = tsk_tree_get_num_samples_by_traversal(self, u, &num_samples);
+            tsk_bug_assert(err == 0);
+            tsk_bug_assert(num_samples == (tsk_size_t) self->num_samples[u]);
         }
+    } else {
+        tsk_bug_assert(self->num_samples == NULL);
+        tsk_bug_assert(self->num_tracked_samples == NULL);
     }
     if (self->options & TSK_SAMPLE_LISTS) {
-        self->left_sample = tsk_malloc(N * sizeof(*self->left_sample));
-        self->right_sample = tsk_malloc(N * sizeof(*self->right_sample));
-        self->next_sample = tsk_malloc(num_samples * sizeof(*self->next_sample));
-        if (self->left_sample == NULL || self->right_sample == NULL
-            || self->next_sample == NULL) {
-            goto out;
+        tsk_bug_assert(self->right_sample != NULL);
+        tsk_bug_assert(self->left_sample != NULL);
+        tsk_bug_assert(self->next_sample != NULL);
+    } else {
+        tsk_bug_assert(self->right_sample == NULL);
+        tsk_bug_assert(self->left_sample == NULL);
+        tsk_bug_assert(self->next_sample == NULL);
+    }
+
+    free(children);
+    free(is_root);
+}
+
+void
+tsk_tree_print_state(const tsk_tree_t *self, FILE *out)
+{
+    tsk_size_t j;
+    tsk_site_t site;
+
+    fprintf(out, "Tree state:\n");
+    fprintf(out, "options = %d\n", self->options);
+    fprintf(out, "root_threshold = %lld\n", (long long) self->root_threshold);
+    fprintf(out, "left = %f\n", self->interval.left);
+    fprintf(out, "right = %f\n", self->interval.right);
+    fprintf(out, "index = %lld\n", (long long) self->index);
+    fprintf(out, "node\tparent\tlchild\trchild\tlsib\trsib");
+    if (self->options & TSK_SAMPLE_LISTS) {
+        fprintf(out, "\thead\ttail");
+    }
+    fprintf(out, "\n");
+
+    for (j = 0; j < self->num_nodes + 1; j++) {
+        fprintf(out, "%lld\t%lld\t%lld\t%lld\t%lld\t%lld", (long long) j,
+            (long long) self->parent[j], (long long) self->left_child[j],
+            (long long) self->right_child[j], (long long) self->left_sib[j],
+            (long long) self->right_sib[j]);
+        if (self->options & TSK_SAMPLE_LISTS) {
+            fprintf(out, "\t%lld\t%lld\t", (long long) self->left_sample[j],
+                (long long) self->right_sample[j]);
+        }
+        if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
+            fprintf(out, "\t%lld\t%lld", (long long) self->num_samples[j],
+                (long long) self->num_tracked_samples[j]);
         }
+        fprintf(out, "\n");
     }
-    ret = tsk_tree_clear(self);
-out:
-    return ret;
+    fprintf(out, "sites = \n");
+    for (j = 0; j < self->sites_length; j++) {
+        site = self->sites[j];
+        fprintf(out, "\t%lld\t%f\n", (long long) site.id, site.position);
+    }
+    tsk_tree_check_state(self);
 }
 
-int
-tsk_tree_set_root_threshold(tsk_tree_t *self, tsk_size_t root_threshold)
+/* Methods for positioning the tree along the sequence */
+
+/* The following methods are performance sensitive and so we use a
+ * lot of restrict pointers. Because we are saying that we don't have
+ * any aliases to these pointers, we pass around the reference to parent
+ * since it's used in all the functions. */
+static inline void
+tsk_tree_update_sample_lists(
+    tsk_tree_t *self, tsk_id_t node, const tsk_id_t *restrict parent)
 {
-    int ret = 0;
+    tsk_id_t u, v, sample_index;
+    tsk_id_t *restrict left_child = self->left_child;
+    tsk_id_t *restrict right_sib = self->right_sib;
+    tsk_id_t *restrict left = self->left_sample;
+    tsk_id_t *restrict right = self->right_sample;
+    tsk_id_t *restrict next = self->next_sample;
+    const tsk_id_t *restrict sample_index_map = self->tree_sequence->sample_index_map;
 
-    if (root_threshold == 0) {
-        ret = TSK_ERR_BAD_PARAM_VALUE;
-        goto out;
+    for (u = node; u != TSK_NULL; u = parent[u]) {
+        sample_index = sample_index_map[u];
+        if (sample_index != TSK_NULL) {
+            right[u] = left[u];
+        } else {
+            left[u] = TSK_NULL;
+            right[u] = TSK_NULL;
+        }
+        for (v = left_child[u]; v != TSK_NULL; v = right_sib[v]) {
+            if (left[v] != TSK_NULL) {
+                tsk_bug_assert(right[v] != TSK_NULL);
+                if (left[u] == TSK_NULL) {
+                    left[u] = left[v];
+                    right[u] = right[v];
+                } else {
+                    next[right[u]] = left[v];
+                    right[u] = right[v];
+                }
+            }
+        }
     }
-    /* Don't allow the value to be set when the tree is out of the null
-     * state */
-    if (self->index != -1) {
-        ret = TSK_ERR_UNSUPPORTED_OPERATION;
-        goto out;
+}
+
+static inline void
+tsk_tree_remove_branch(
+    tsk_tree_t *self, tsk_id_t p, tsk_id_t c, tsk_id_t *restrict parent)
+{
+    tsk_id_t *restrict left_child = self->left_child;
+    tsk_id_t *restrict right_child = self->right_child;
+    tsk_id_t *restrict left_sib = self->left_sib;
+    tsk_id_t *restrict right_sib = self->right_sib;
+    tsk_id_t *restrict num_children = self->num_children;
+    tsk_id_t lsib = left_sib[c];
+    tsk_id_t rsib = right_sib[c];
+
+    if (lsib == TSK_NULL) {
+        left_child[p] = rsib;
+    } else {
+        right_sib[lsib] = rsib;
     }
-    self->root_threshold = root_threshold;
-    /* Reset the roots */
-    ret = tsk_tree_clear(self);
-out:
-    return ret;
+    if (rsib == TSK_NULL) {
+        right_child[p] = lsib;
+    } else {
+        left_sib[rsib] = lsib;
+    }
+    parent[c] = TSK_NULL;
+    left_sib[c] = TSK_NULL;
+    right_sib[c] = TSK_NULL;
+    num_children[p]--;
 }
 
-tsk_size_t
-tsk_tree_get_root_threshold(const tsk_tree_t *self)
+static inline void
+tsk_tree_insert_branch(
+    tsk_tree_t *self, tsk_id_t p, tsk_id_t c, tsk_id_t *restrict parent)
 {
-    return self->root_threshold;
-}
+    tsk_id_t *restrict left_child = self->left_child;
+    tsk_id_t *restrict right_child = self->right_child;
+    tsk_id_t *restrict left_sib = self->left_sib;
+    tsk_id_t *restrict right_sib = self->right_sib;
+    tsk_id_t *restrict num_children = self->num_children;
+    tsk_id_t u;
 
-int
-tsk_tree_free(tsk_tree_t *self)
-{
-    tsk_safe_free(self->parent);
-    tsk_safe_free(self->left_child);
-    tsk_safe_free(self->right_child);
-    tsk_safe_free(self->left_sib);
-    tsk_safe_free(self->right_sib);
-    tsk_safe_free(self->num_samples);
-    tsk_safe_free(self->num_tracked_samples);
-    tsk_safe_free(self->left_sample);
-    tsk_safe_free(self->right_sample);
-    tsk_safe_free(self->next_sample);
-    tsk_safe_free(self->num_children);
-    tsk_safe_free(self->edge);
-    return 0;
+    parent[c] = p;
+    u = right_child[p];
+    if (u == TSK_NULL) {
+        left_child[p] = c;
+        left_sib[c] = TSK_NULL;
+        right_sib[c] = TSK_NULL;
+    } else {
+        right_sib[u] = c;
+        left_sib[c] = u;
+        right_sib[c] = TSK_NULL;
+    }
+    right_child[p] = c;
+    num_children[p]++;
 }
 
-bool
-tsk_tree_has_sample_lists(const tsk_tree_t *self)
+static inline void
+tsk_tree_insert_root(tsk_tree_t *self, tsk_id_t root, tsk_id_t *restrict parent)
 {
-    return !!(self->options & TSK_SAMPLE_LISTS);
+    tsk_tree_insert_branch(self, self->virtual_root, root, parent);
+    parent[root] = TSK_NULL;
 }
 
-bool
-tsk_tree_has_sample_counts(const tsk_tree_t *self)
+static inline void
+tsk_tree_remove_root(tsk_tree_t *self, tsk_id_t root, tsk_id_t *restrict parent)
 {
-    return !(self->options & TSK_NO_SAMPLE_COUNTS);
+    tsk_tree_remove_branch(self, self->virtual_root, root, parent);
 }
 
-static int TSK_WARN_UNUSED
-tsk_tree_reset_tracked_samples(tsk_tree_t *self)
+static void
+tsk_tree_remove_edge(tsk_tree_t *self, tsk_id_t p, tsk_id_t c)
 {
-    int ret = 0;
+    tsk_id_t *restrict parent = self->parent;
+    tsk_size_t *restrict num_samples = self->num_samples;
+    tsk_size_t *restrict num_tracked_samples = self->num_tracked_samples;
+    tsk_id_t *restrict edge = self->edge;
+    const tsk_size_t root_threshold = self->root_threshold;
+    tsk_id_t u;
+    tsk_id_t path_end = TSK_NULL;
+    bool path_end_was_root = false;
 
-    if (!tsk_tree_has_sample_counts(self)) {
-        ret = TSK_ERR_UNSUPPORTED_OPERATION;
-        goto out;
+#define POTENTIAL_ROOT(U) (num_samples[U] >= root_threshold)
+
+    tsk_tree_remove_branch(self, p, c, parent);
+    self->num_edges--;
+    edge[c] = TSK_NULL;
+
+    if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
+        u = p;
+        while (u != TSK_NULL) {
+            path_end = u;
+            path_end_was_root = POTENTIAL_ROOT(u);
+            num_samples[u] -= num_samples[c];
+            num_tracked_samples[u] -= num_tracked_samples[c];
+            u = parent[u];
+        }
+
+        if (path_end_was_root && !POTENTIAL_ROOT(path_end)) {
+            tsk_tree_remove_root(self, path_end, parent);
+        }
+        if (POTENTIAL_ROOT(c)) {
+            tsk_tree_insert_root(self, c, parent);
+        }
+    }
+
+    if (self->options & TSK_SAMPLE_LISTS) {
+        tsk_tree_update_sample_lists(self, p, parent);
     }
-    tsk_memset(self->num_tracked_samples, 0,
-        (self->num_nodes + 1) * sizeof(*self->num_tracked_samples));
-out:
-    return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_tree_set_tracked_samples(
-    tsk_tree_t *self, tsk_size_t num_tracked_samples, const tsk_id_t *tracked_samples)
+static void
+tsk_tree_insert_edge(tsk_tree_t *self, tsk_id_t p, tsk_id_t c, tsk_id_t edge_id)
 {
-    int ret = TSK_ERR_GENERIC;
-    tsk_size_t *tree_num_tracked_samples = self->num_tracked_samples;
-    const tsk_id_t *parent = self->parent;
-    tsk_size_t j;
+    tsk_id_t *restrict parent = self->parent;
+    tsk_size_t *restrict num_samples = self->num_samples;
+    tsk_size_t *restrict num_tracked_samples = self->num_tracked_samples;
+    tsk_id_t *restrict edge = self->edge;
+    const tsk_size_t root_threshold = self->root_threshold;
     tsk_id_t u;
+    tsk_id_t path_end = TSK_NULL;
+    bool path_end_was_root = false;
 
-    /* TODO This is not needed when the tree is new. We should use the
-     * state machine to check and only reset the tracked samples when needed.
-     */
-    ret = tsk_tree_reset_tracked_samples(self);
-    if (ret != 0) {
-        goto out;
-    }
-    self->num_tracked_samples[self->virtual_root] = num_tracked_samples;
-    for (j = 0; j < num_tracked_samples; j++) {
-        u = tracked_samples[j];
-        if (u < 0 || u >= (tsk_id_t) self->num_nodes) {
-            ret = TSK_ERR_NODE_OUT_OF_BOUNDS;
-            goto out;
-        }
-        if (!tsk_treeseq_is_sample(self->tree_sequence, u)) {
-            ret = TSK_ERR_BAD_SAMPLES;
-            goto out;
-        }
-        if (self->num_tracked_samples[u] != 0) {
-            ret = TSK_ERR_DUPLICATE_SAMPLE;
-            goto out;
-        }
-        /* Propagate this upwards */
+#define POTENTIAL_ROOT(U) (num_samples[U] >= root_threshold)
+
+    if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
+        u = p;
         while (u != TSK_NULL) {
-            tree_num_tracked_samples[u]++;
+            path_end = u;
+            path_end_was_root = POTENTIAL_ROOT(u);
+            num_samples[u] += num_samples[c];
+            num_tracked_samples[u] += num_tracked_samples[c];
             u = parent[u];
         }
+
+        if (POTENTIAL_ROOT(c)) {
+            tsk_tree_remove_root(self, c, parent);
+        }
+        if (POTENTIAL_ROOT(path_end) && !path_end_was_root) {
+            tsk_tree_insert_root(self, path_end, parent);
+        }
+    }
+
+    tsk_tree_insert_branch(self, p, c, parent);
+    self->num_edges++;
+    edge[c] = edge_id;
+
+    if (self->options & TSK_SAMPLE_LISTS) {
+        tsk_tree_update_sample_lists(self, p, parent);
     }
-out:
-    return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_tree_track_descendant_samples(tsk_tree_t *self, tsk_id_t node)
+static int
+tsk_tree_advance(tsk_tree_t *self, int direction, const double *restrict out_breakpoints,
+    const tsk_id_t *restrict out_order, tsk_id_t *out_index,
+    const double *restrict in_breakpoints, const tsk_id_t *restrict in_order,
+    tsk_id_t *in_index)
 {
     int ret = 0;
-    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
-    const tsk_id_t *restrict parent = self->parent;
-    const tsk_id_t *restrict left_child = self->left_child;
-    const tsk_id_t *restrict right_sib = self->right_sib;
-    const tsk_flags_t *restrict flags = self->tree_sequence->tables->nodes.flags;
-    tsk_size_t *num_tracked_samples = self->num_tracked_samples;
-    tsk_size_t n, j, num_nodes;
-    tsk_id_t u, v;
+    const int direction_change = direction * (direction != self->direction);
+    tsk_id_t in = *in_index + direction_change;
+    tsk_id_t out = *out_index + direction_change;
+    tsk_id_t k;
+    const tsk_table_collection_t *tables = self->tree_sequence->tables;
+    const double sequence_length = tables->sequence_length;
+    const tsk_id_t num_edges = (tsk_id_t) tables->edges.num_rows;
+    const tsk_id_t *restrict edge_parent = tables->edges.parent;
+    const tsk_id_t *restrict edge_child = tables->edges.child;
+    double x;
 
-    if (nodes == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
+    if (direction == TSK_DIR_FORWARD) {
+        x = self->interval.right;
+    } else {
+        x = self->interval.left;
     }
-    ret = tsk_tree_postorder_from(self, node, nodes, &num_nodes);
-    if (ret != 0) {
-        goto out;
+    while (out >= 0 && out < num_edges && out_breakpoints[out_order[out]] == x) {
+        tsk_bug_assert(out < num_edges);
+        k = out_order[out];
+        out += direction;
+        tsk_tree_remove_edge(self, edge_parent[k], edge_child[k]);
     }
-    ret = tsk_tree_reset_tracked_samples(self);
-    if (ret != 0) {
-        goto out;
+
+    while (in >= 0 && in < num_edges && in_breakpoints[in_order[in]] == x) {
+        k = in_order[in];
+        in += direction;
+        tsk_tree_insert_edge(self, edge_parent[k], edge_child[k], k);
     }
-    u = 0; /* keep the compiler happy */
-    for (j = 0; j < num_nodes; j++) {
-        u = nodes[j];
-        for (v = left_child[u]; v != TSK_NULL; v = right_sib[v]) {
-            num_tracked_samples[u] += num_tracked_samples[v];
+
+    self->direction = direction;
+    self->index = self->index + direction;
+    if (direction == TSK_DIR_FORWARD) {
+        self->interval.left = x;
+        self->interval.right = sequence_length;
+        if (out >= 0 && out < num_edges) {
+            self->interval.right
+                = TSK_MIN(self->interval.right, out_breakpoints[out_order[out]]);
+        }
+        if (in >= 0 && in < num_edges) {
+            self->interval.right
+                = TSK_MIN(self->interval.right, in_breakpoints[in_order[in]]);
+        }
+    } else {
+        self->interval.right = x;
+        self->interval.left = 0;
+        if (out >= 0 && out < num_edges) {
+            self->interval.left
+                = TSK_MAX(self->interval.left, out_breakpoints[out_order[out]]);
+        }
+        if (in >= 0 && in < num_edges) {
+            self->interval.left
+                = TSK_MAX(self->interval.left, in_breakpoints[in_order[in]]);
         }
-        num_tracked_samples[u] += flags[u] & TSK_NODE_IS_SAMPLE ? 1 : 0;
-    }
-    n = num_tracked_samples[u];
-    u = parent[u];
-    while (u != TSK_NULL) {
-        num_tracked_samples[u] = n;
-        u = parent[u];
     }
-    num_tracked_samples[self->virtual_root] = n;
-out:
-    tsk_safe_free(nodes);
+    tsk_bug_assert(self->interval.left < self->interval.right);
+    *out_index = out;
+    *in_index = in;
+    if (tables->sites.num_rows > 0) {
+        self->sites = self->tree_sequence->tree_sites[self->index];
+        self->sites_length = self->tree_sequence->tree_sites_length[self->index];
+    }
+    ret = TSK_TREE_OK;
     return ret;
 }
 
 int TSK_WARN_UNUSED
-tsk_tree_copy(const tsk_tree_t *self, tsk_tree_t *dest, tsk_flags_t options)
+tsk_tree_first(tsk_tree_t *self)
 {
-    int ret = TSK_ERR_GENERIC;
-    tsk_size_t N = self->num_nodes + 1;
+    int ret = TSK_TREE_OK;
+    tsk_table_collection_t *tables = self->tree_sequence->tables;
 
-    if (!(options & TSK_NO_INIT)) {
-        ret = tsk_tree_init(dest, self->tree_sequence, options);
+    self->interval.left = 0;
+    self->index = 0;
+    self->interval.right = tables->sequence_length;
+    self->sites = self->tree_sequence->tree_sites[0];
+    self->sites_length = self->tree_sequence->tree_sites_length[0];
+
+    if (tables->edges.num_rows > 0) {
+        /* TODO this is redundant if this is the first usage of the tree. We
+         * should add a state machine here so we know what state the tree is
+         * in and can take the appropriate actions.
+         */
+        ret = tsk_tree_clear(self);
         if (ret != 0) {
             goto out;
         }
-    }
-    if (self->tree_sequence != dest->tree_sequence) {
-        ret = TSK_ERR_BAD_PARAM_VALUE;
-        goto out;
-    }
-    dest->interval = self->interval;
-    dest->left_index = self->left_index;
-    dest->right_index = self->right_index;
-    dest->direction = self->direction;
-    dest->index = self->index;
-    dest->sites = self->sites;
-    dest->sites_length = self->sites_length;
-    dest->root_threshold = self->root_threshold;
-    dest->num_edges = self->num_edges;
+        self->index = -1;
+        self->left_index = 0;
+        self->right_index = 0;
+        self->direction = TSK_DIR_FORWARD;
+        self->interval.right = 0;
 
-    tsk_memcpy(dest->parent, self->parent, N * sizeof(*self->parent));
-    tsk_memcpy(dest->left_child, self->left_child, N * sizeof(*self->left_child));
-    tsk_memcpy(dest->right_child, self->right_child, N * sizeof(*self->right_child));
-    tsk_memcpy(dest->left_sib, self->left_sib, N * sizeof(*self->left_sib));
-    tsk_memcpy(dest->right_sib, self->right_sib, N * sizeof(*self->right_sib));
-    tsk_memcpy(dest->num_children, self->num_children, N * sizeof(*self->num_children));
-    tsk_memcpy(dest->edge, self->edge, N * sizeof(*self->edge));
-    if (!(dest->options & TSK_NO_SAMPLE_COUNTS)) {
-        if (self->options & TSK_NO_SAMPLE_COUNTS) {
-            ret = TSK_ERR_UNSUPPORTED_OPERATION;
-            goto out;
-        }
-        tsk_memcpy(dest->num_samples, self->num_samples, N * sizeof(*self->num_samples));
-        tsk_memcpy(dest->num_tracked_samples, self->num_tracked_samples,
-            N * sizeof(*self->num_tracked_samples));
-    }
-    if (dest->options & TSK_SAMPLE_LISTS) {
-        if (!(self->options & TSK_SAMPLE_LISTS)) {
-            ret = TSK_ERR_UNSUPPORTED_OPERATION;
-            goto out;
-        }
-        tsk_memcpy(dest->left_sample, self->left_sample, N * sizeof(*self->left_sample));
-        tsk_memcpy(
-            dest->right_sample, self->right_sample, N * sizeof(*self->right_sample));
-        tsk_memcpy(dest->next_sample, self->next_sample,
-            self->tree_sequence->num_samples * sizeof(*self->next_sample));
+        ret = tsk_tree_advance(self, TSK_DIR_FORWARD, tables->edges.right,
+            tables->indexes.edge_removal_order, &self->right_index, tables->edges.left,
+            tables->indexes.edge_insertion_order, &self->left_index);
     }
-    ret = 0;
 out:
     return ret;
 }
 
-bool TSK_WARN_UNUSED
-tsk_tree_equals(const tsk_tree_t *self, const tsk_tree_t *other)
+int TSK_WARN_UNUSED
+tsk_tree_last(tsk_tree_t *self)
 {
-    bool ret = false;
+    int ret = TSK_TREE_OK;
+    const tsk_treeseq_t *ts = self->tree_sequence;
+    const tsk_table_collection_t *tables = ts->tables;
 
-    if (self->tree_sequence == other->tree_sequence) {
-        ret = self->index == other->index;
+    self->interval.left = 0;
+    self->interval.right = tables->sequence_length;
+    self->index = 0;
+    self->sites = ts->tree_sites[0];
+    self->sites_length = ts->tree_sites_length[0];
+
+    if (tables->edges.num_rows > 0) {
+        /* TODO this is redundant if this is the first usage of the tree. We
+         * should add a state machine here so we know what state the tree is
+         * in and can take the appropriate actions.
+         */
+        ret = tsk_tree_clear(self);
+        if (ret != 0) {
+            goto out;
+        }
+        self->index = (tsk_id_t) tsk_treeseq_get_num_trees(ts);
+        self->left_index = (tsk_id_t) tables->edges.num_rows - 1;
+        self->right_index = (tsk_id_t) tables->edges.num_rows - 1;
+        self->direction = TSK_DIR_REVERSE;
+        self->interval.left = tables->sequence_length;
+        self->interval.right = 0;
+
+        ret = tsk_tree_advance(self, TSK_DIR_REVERSE, tables->edges.left,
+            tables->indexes.edge_insertion_order, &self->left_index, tables->edges.right,
+            tables->indexes.edge_removal_order, &self->right_index);
     }
+out:
     return ret;
 }
 
-static int
-tsk_tree_check_node(const tsk_tree_t *self, tsk_id_t u)
+int TSK_WARN_UNUSED
+tsk_tree_next(tsk_tree_t *self)
 {
     int ret = 0;
-    if (u < 0 || u > (tsk_id_t) self->num_nodes) {
-        ret = TSK_ERR_NODE_OUT_OF_BOUNDS;
+    const tsk_treeseq_t *ts = self->tree_sequence;
+    const tsk_table_collection_t *tables = ts->tables;
+    tsk_id_t num_trees = (tsk_id_t) tsk_treeseq_get_num_trees(ts);
+
+    if (self->index == -1) {
+        ret = tsk_tree_first(self);
+    } else if (self->index < num_trees - 1) {
+        ret = tsk_tree_advance(self, TSK_DIR_FORWARD, tables->edges.right,
+            tables->indexes.edge_removal_order, &self->right_index, tables->edges.left,
+            tables->indexes.edge_insertion_order, &self->left_index);
+    } else {
+        ret = tsk_tree_clear(self);
     }
     return ret;
 }
 
-bool
-tsk_tree_is_descendant(const tsk_tree_t *self, tsk_id_t u, tsk_id_t v)
+int TSK_WARN_UNUSED
+tsk_tree_prev(tsk_tree_t *self)
 {
-    bool ret = false;
-    tsk_id_t w = u;
-    tsk_id_t *restrict parent = self->parent;
+    int ret = 0;
+    const tsk_table_collection_t *tables = self->tree_sequence->tables;
 
-    if (tsk_tree_check_node(self, u) == 0 && tsk_tree_check_node(self, v) == 0) {
-        while (w != v && w != TSK_NULL) {
-            w = parent[w];
-        }
-        ret = w == v;
+    if (self->index == -1) {
+        ret = tsk_tree_last(self);
+    } else if (self->index > 0) {
+        ret = tsk_tree_advance(self, TSK_DIR_REVERSE, tables->edges.left,
+            tables->indexes.edge_insertion_order, &self->left_index, tables->edges.right,
+            tables->indexes.edge_removal_order, &self->right_index);
+    } else {
+        ret = tsk_tree_clear(self);
     }
     return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_tree_get_mrca(const tsk_tree_t *self, tsk_id_t u, tsk_id_t v, tsk_id_t *mrca)
+static inline bool
+tsk_tree_position_in_interval(const tsk_tree_t *self, double x)
 {
-    int ret = 0;
-    double tu, tv;
-    const tsk_id_t *restrict parent = self->parent;
-    const double *restrict time = self->tree_sequence->tables->nodes.time;
-
-    ret = tsk_tree_check_node(self, u);
-    if (ret != 0) {
-        goto out;
-    }
-    ret = tsk_tree_check_node(self, v);
-    if (ret != 0) {
-        goto out;
-    }
+    return self->interval.left <= x && x < self->interval.right;
+}
 
-    /* Simplest to make the virtual_root a special case here to avoid
-     * doing the time lookup. */
-    if (u == self->virtual_root || v == self->virtual_root) {
-        *mrca = self->virtual_root;
-        return 0;
-    }
+/* NOTE:
+ *
+ * Notes from Kevin Thornton:
+ *
+ * This method inserts the edges for an arbitrary tree
+ * in linear time and requires no additional memory.
+ *
+ * During design, the following alternatives were tested
+ * (in a combination of rust + C):
+ * 1. Indexing edge insertion/removal locations by tree.
+ *    The indexing can be done in O(n) time, giving O(1)
+ *    access to the first edge in a tree. We can then add
+ *    edges to the tree in O(e) time, where e is the number
+ *    of edges. This apparoach requires O(n) additional memory
+ *    and is only marginally faster than the implementation below.
+ * 2. Building an interval tree mapping edge id -> span.
+ *    This approach adds a lot of complexity and wasn't any faster
+ *    than the indexing described above.
+ */
+static int
+tsk_tree_seek_from_null(tsk_tree_t *self, double x, tsk_flags_t TSK_UNUSED(options))
+{
+    int ret = 0;
+    tsk_size_t edge;
+    tsk_id_t p, c, e, j, k, tree_index;
+    const double L = tsk_treeseq_get_sequence_length(self->tree_sequence);
+    const tsk_treeseq_t *treeseq = self->tree_sequence;
+    const tsk_table_collection_t *tables = treeseq->tables;
+    const tsk_id_t *restrict edge_parent = tables->edges.parent;
+    const tsk_id_t *restrict edge_child = tables->edges.child;
+    const tsk_size_t num_edges = tables->edges.num_rows;
+    const tsk_size_t num_trees = self->tree_sequence->num_trees;
+    const double *restrict edge_left = tables->edges.left;
+    const double *restrict edge_right = tables->edges.right;
+    const double *restrict breakpoints = treeseq->breakpoints;
+    const tsk_id_t *restrict insertion = tables->indexes.edge_insertion_order;
+    const tsk_id_t *restrict removal = tables->indexes.edge_removal_order;
 
-    tu = time[u];
-    tv = time[v];
-    while (u != v) {
-        if (tu < tv) {
-            u = parent[u];
-            if (u == TSK_NULL) {
+    // NOTE: it may be better to get the
+    // index first and then ask if we are
+    // searching in the first or last 1/2
+    // of trees.
+    j = -1;
+    if (x <= L / 2.0) {
+        for (edge = 0; edge < num_edges; edge++) {
+            e = insertion[edge];
+            if (edge_left[e] > x) {
+                j = (tsk_id_t) edge;
                 break;
             }
-            tu = time[u];
-        } else {
-            v = parent[v];
-            if (v == TSK_NULL) {
+            if (x >= edge_left[e] && x < edge_right[e]) {
+                p = edge_parent[e];
+                c = edge_child[e];
+                tsk_tree_insert_edge(self, p, c, e);
+            }
+        }
+    } else {
+        for (edge = 0; edge < num_edges; edge++) {
+            e = removal[num_edges - edge - 1];
+            if (edge_right[e] < x) {
+                j = (tsk_id_t)(num_edges - edge - 1);
+                while (j < (tsk_id_t) num_edges && edge_left[insertion[j]] <= x) {
+                    j++;
+                }
                 break;
             }
-            tv = time[v];
+            if (x >= edge_left[e] && x < edge_right[e]) {
+                p = edge_parent[e];
+                c = edge_child[e];
+                tsk_tree_insert_edge(self, p, c, e);
+            }
         }
     }
-    *mrca = u == v ? u : TSK_NULL;
-out:
-    return ret;
-}
-
-static int
-tsk_tree_get_num_samples_by_traversal(
-    const tsk_tree_t *self, tsk_id_t u, tsk_size_t *num_samples)
-{
-    int ret = 0;
-    tsk_size_t num_nodes, j;
-    tsk_size_t count = 0;
-    const tsk_flags_t *restrict flags = self->tree_sequence->tables->nodes.flags;
-    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
-    tsk_id_t v;
 
-    if (nodes == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
+    if (j == -1) {
+        j = 0;
+        while (j < (tsk_id_t) num_edges && edge_left[insertion[j]] <= x) {
+            j++;
+        }
     }
-    ret = tsk_tree_preorder_from(self, u, nodes, &num_nodes);
-    if (ret != 0) {
-        goto out;
+    k = 0;
+    while (k < (tsk_id_t) num_edges && edge_right[removal[k]] <= x) {
+        k++;
     }
-    for (j = 0; j < num_nodes; j++) {
-        v = nodes[j];
-        if (flags[v] & TSK_NODE_IS_SAMPLE) {
-            count++;
-        }
+
+    /* NOTE: tsk_search_sorted finds the first the first
+     * insertion locatiom >= the query point, which
+     * finds a RIGHT value for queries not at the left edge.
+     */
+    tree_index = (tsk_id_t) tsk_search_sorted(breakpoints, num_trees + 1, x);
+    if (breakpoints[tree_index] > x) {
+        tree_index--;
     }
-    *num_samples = count;
-out:
-    tsk_safe_free(nodes);
+    self->index = tree_index;
+    self->interval.left = breakpoints[tree_index];
+    self->interval.right = breakpoints[tree_index + 1];
+    self->left_index = j;
+    self->right_index = k;
+    self->direction = TSK_DIR_FORWARD;
+    self->num_nodes = tables->nodes.num_rows;
+    if (tables->sites.num_rows > 0) {
+        self->sites = treeseq->tree_sites[self->index];
+        self->sites_length = treeseq->tree_sites_length[self->index];
+    }
+
     return ret;
 }
 
 int TSK_WARN_UNUSED
-tsk_tree_get_num_samples(const tsk_tree_t *self, tsk_id_t u, tsk_size_t *num_samples)
+tsk_tree_seek_index(tsk_tree_t *self, tsk_id_t tree, tsk_flags_t options)
 {
     int ret = 0;
+    double x;
 
-    ret = tsk_tree_check_node(self, u);
-    if (ret != 0) {
+    if (tree < 0 || tree >= (tsk_id_t) self->tree_sequence->num_trees) {
+        ret = TSK_ERR_SEEK_OUT_OF_BOUNDS;
         goto out;
     }
-
-    if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
-        *num_samples = (tsk_size_t) self->num_samples[u];
-    } else {
-        ret = tsk_tree_get_num_samples_by_traversal(self, u, num_samples);
-    }
+    x = self->tree_sequence->breakpoints[tree];
+    ret = tsk_tree_seek(self, x, options);
 out:
     return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_tree_get_num_tracked_samples(
-    const tsk_tree_t *self, tsk_id_t u, tsk_size_t *num_tracked_samples)
+static int TSK_WARN_UNUSED
+tsk_tree_seek_linear(tsk_tree_t *self, double x, tsk_flags_t TSK_UNUSED(options))
 {
+    const double L = tsk_treeseq_get_sequence_length(self->tree_sequence);
+    const double t_l = self->interval.left;
+    const double t_r = self->interval.right;
     int ret = 0;
+    double distance_left, distance_right;
 
-    ret = tsk_tree_check_node(self, u);
-    if (ret != 0) {
-        goto out;
+    if (x < t_l) {
+        /* |-----|-----|========|---------| */
+        /* 0     x    t_l      t_r        L */
+        distance_left = t_l - x;
+        distance_right = L - t_r + x;
+    } else {
+        /* |------|========|------|-------| */
+        /* 0     t_l      t_r     x       L */
+        distance_right = x - t_r;
+        distance_left = t_l + L - x;
     }
-    if (self->options & TSK_NO_SAMPLE_COUNTS) {
-        ret = TSK_ERR_UNSUPPORTED_OPERATION;
-        goto out;
+    if (distance_right <= distance_left) {
+        while (!tsk_tree_position_in_interval(self, x)) {
+            ret = tsk_tree_next(self);
+            if (ret < 0) {
+                goto out;
+            }
+        }
+    } else {
+        while (!tsk_tree_position_in_interval(self, x)) {
+            ret = tsk_tree_prev(self);
+            if (ret < 0) {
+                goto out;
+            }
+        }
     }
-    *num_tracked_samples = self->num_tracked_samples[u];
+    ret = 0;
 out:
     return ret;
 }
 
-bool
-tsk_tree_is_sample(const tsk_tree_t *self, tsk_id_t u)
-{
-    return tsk_treeseq_is_sample(self->tree_sequence, u);
-}
-
-tsk_id_t
-tsk_tree_get_left_root(const tsk_tree_t *self)
-{
-    return self->left_child[self->virtual_root];
-}
-
-tsk_id_t
-tsk_tree_get_right_root(const tsk_tree_t *self)
-{
-    return self->right_child[self->virtual_root];
-}
-
-tsk_size_t
-tsk_tree_get_num_roots(const tsk_tree_t *self)
-{
-    return (tsk_size_t) self->num_children[self->virtual_root];
-}
-
 int TSK_WARN_UNUSED
-tsk_tree_get_parent(const tsk_tree_t *self, tsk_id_t u, tsk_id_t *parent)
+tsk_tree_seek(tsk_tree_t *self, double x, tsk_flags_t options)
 {
     int ret = 0;
+    const double L = tsk_treeseq_get_sequence_length(self->tree_sequence);
 
-    ret = tsk_tree_check_node(self, u);
-    if (ret != 0) {
+    if (x < 0 || x >= L) {
+        ret = TSK_ERR_SEEK_OUT_OF_BOUNDS;
         goto out;
     }
-    *parent = self->parent[u];
-out:
-    return ret;
-}
-
-int TSK_WARN_UNUSED
-tsk_tree_get_time(const tsk_tree_t *self, tsk_id_t u, double *t)
-{
-    int ret = 0;
-    tsk_node_t node;
 
-    if (u == self->virtual_root) {
-        *t = INFINITY;
+    if (self->index == -1) {
+        ret = tsk_tree_seek_from_null(self, x, options);
     } else {
-        ret = tsk_treeseq_get_node(self->tree_sequence, u, &node);
-        if (ret != 0) {
-            goto out;
-        }
-        *t = node.time;
+        ret = tsk_tree_seek_linear(self, x, options);
     }
+
 out:
     return ret;
 }
 
-static inline double
-tsk_tree_get_branch_length_unsafe(const tsk_tree_t *self, tsk_id_t u)
-{
-    const double *times = self->tree_sequence->tables->nodes.time;
-    const tsk_id_t parent = self->parent[u];
-
-    return parent == TSK_NULL ? 0 : times[parent] - times[u];
-}
-
 int TSK_WARN_UNUSED
-tsk_tree_get_branch_length(const tsk_tree_t *self, tsk_id_t u, double *ret_branch_length)
+tsk_tree_clear(tsk_tree_t *self)
 {
     int ret = 0;
+    tsk_size_t j;
+    tsk_id_t u;
+    const tsk_size_t N = self->num_nodes + 1;
+    const tsk_size_t num_samples = self->tree_sequence->num_samples;
+    const bool sample_counts = !(self->options & TSK_NO_SAMPLE_COUNTS);
+    const bool sample_lists = !!(self->options & TSK_SAMPLE_LISTS);
+    const tsk_flags_t *flags = self->tree_sequence->tables->nodes.flags;
 
-    ret = tsk_tree_check_node(self, u);
-    if (ret != 0) {
-        goto out;
-    }
-    *ret_branch_length = tsk_tree_get_branch_length_unsafe(self, u);
-out:
-    return ret;
-}
-
-int
-tsk_tree_get_total_branch_length(const tsk_tree_t *self, tsk_id_t node, double *ret_tbl)
-{
-    int ret = 0;
-    tsk_size_t j, num_nodes;
-    tsk_id_t u, v;
-    const tsk_id_t *restrict parent = self->parent;
-    const double *restrict time = self->tree_sequence->tables->nodes.time;
-    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
-    double sum = 0;
+    self->interval.left = 0;
+    self->interval.right = 0;
+    self->num_edges = 0;
+    self->index = -1;
+    /* TODO we should profile this method to see if just doing a single loop over
+     * the nodes would be more efficient than multiple memsets.
+     */
+    tsk_memset(self->parent, 0xff, N * sizeof(*self->parent));
+    tsk_memset(self->left_child, 0xff, N * sizeof(*self->left_child));
+    tsk_memset(self->right_child, 0xff, N * sizeof(*self->right_child));
+    tsk_memset(self->left_sib, 0xff, N * sizeof(*self->left_sib));
+    tsk_memset(self->right_sib, 0xff, N * sizeof(*self->right_sib));
+    tsk_memset(self->num_children, 0, N * sizeof(*self->num_children));
+    tsk_memset(self->edge, 0xff, N * sizeof(*self->edge));
 
-    if (nodes == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
+    if (sample_counts) {
+        tsk_memset(self->num_samples, 0, N * sizeof(*self->num_samples));
+        /* We can't reset the tracked samples via memset because we don't
+         * know where the tracked samples are.
+         */
+        for (j = 0; j < self->num_nodes; j++) {
+            if (!(flags[j] & TSK_NODE_IS_SAMPLE)) {
+                self->num_tracked_samples[j] = 0;
+            }
+        }
+        /* The total tracked_samples gets set in set_tracked_samples */
+        self->num_samples[self->virtual_root] = num_samples;
     }
-    ret = tsk_tree_preorder_from(self, node, nodes, &num_nodes);
-    if (ret != 0) {
-        goto out;
+    if (sample_lists) {
+        tsk_memset(self->left_sample, 0xff, N * sizeof(tsk_id_t));
+        tsk_memset(self->right_sample, 0xff, N * sizeof(tsk_id_t));
+        tsk_memset(self->next_sample, 0xff, num_samples * sizeof(tsk_id_t));
     }
-    /* We always skip the first node because we don't return the branch length
-     * over the input node. */
-    for (j = 1; j < num_nodes; j++) {
-        u = nodes[j];
-        v = parent[u];
-        if (v != TSK_NULL) {
-            sum += time[v] - time[u];
+    /* Set the sample attributes */
+    for (j = 0; j < num_samples; j++) {
+        u = self->samples[j];
+        if (sample_counts) {
+            self->num_samples[u] = 1;
+        }
+        if (sample_lists) {
+            /* We are mapping to *indexes* into the list of samples here */
+            self->left_sample[u] = (tsk_id_t) j;
+            self->right_sample[u] = (tsk_id_t) j;
+        }
+    }
+    if (sample_counts && self->root_threshold == 1 && num_samples > 0) {
+        for (j = 0; j < num_samples; j++) {
+            /* Set initial roots */
+            if (self->root_threshold == 1) {
+                tsk_tree_insert_root(self, self->samples[j], self->parent);
+            }
         }
     }
-    *ret_tbl = sum;
-out:
-    tsk_safe_free(nodes);
     return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_tree_get_sites(
-    const tsk_tree_t *self, const tsk_site_t **sites, tsk_size_t *sites_length)
-{
-    *sites = self->sites;
-    *sites_length = self->sites_length;
-    return 0;
-}
-
-/* u must be a valid node in the tree. For internal use */
-static int
-tsk_tree_get_depth_unsafe(const tsk_tree_t *self, tsk_id_t u)
+tsk_size_t
+tsk_tree_get_size_bound(const tsk_tree_t *self)
 {
-    tsk_id_t v;
-    const tsk_id_t *restrict parent = self->parent;
-    int depth = 0;
+    tsk_size_t bound = 0;
 
-    if (u == self->virtual_root) {
-        return -1;
-    }
-    for (v = parent[u]; v != TSK_NULL; v = parent[v]) {
-        depth++;
+    if (self->tree_sequence != NULL) {
+        /* This is a safe upper bound which can be computed cheaply.
+         * We have at most n roots and each edge adds at most one new
+         * node to the tree. We also allow space for the virtual root,
+         * to simplify client code.
+         *
+         * In the common case of a binary tree with a single root, we have
+         * 2n - 1 nodes in total, and 2n - 2 edges. Therefore, we return
+         * 3n - 1, which is an over-estimate of 1/2 and we allocate
+         * 1.5 times as much memory as we need.
+         *
+         * Since tracking the exact number of nodes in the tree would require
+         * storing the number of nodes beneath every node and complicate
+         * the tree transition method, this seems like a good compromise
+         * and will result in less memory usage overall in nearly all cases.
+         */
+        bound = 1 + self->tree_sequence->num_samples + self->num_edges;
     }
-    return depth;
+    return bound;
 }
 
-int TSK_WARN_UNUSED
-tsk_tree_get_depth(const tsk_tree_t *self, tsk_id_t u, int *depth_ret)
+/* Traversal orders */
+static tsk_id_t *
+tsk_tree_alloc_node_stack(const tsk_tree_t *self)
 {
-    int ret = 0;
-
-    ret = tsk_tree_check_node(self, u);
-    if (ret != 0) {
-        goto out;
-    }
-
-    *depth_ret = tsk_tree_get_depth_unsafe(self, u);
-out:
-    return ret;
+    return tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(tsk_id_t));
 }
 
-static tsk_id_t
-tsk_tree_node_root(tsk_tree_t *self, tsk_id_t u)
+int
+tsk_tree_preorder(const tsk_tree_t *self, tsk_id_t *nodes, tsk_size_t *num_nodes_ret)
 {
-    tsk_id_t v = u;
-    while (self->parent[v] != TSK_NULL) {
-        v = self->parent[v];
-    }
-
-    return v;
+    return tsk_tree_preorder_from(self, -1, nodes, num_nodes_ret);
 }
 
-static void
-tsk_tree_check_state(const tsk_tree_t *self)
+int
+tsk_tree_preorder_from(
+    const tsk_tree_t *self, tsk_id_t root, tsk_id_t *nodes, tsk_size_t *num_nodes_ret)
 {
+    int ret = 0;
+    const tsk_id_t *restrict right_child = self->right_child;
+    const tsk_id_t *restrict left_sib = self->left_sib;
+    tsk_id_t *stack = tsk_tree_alloc_node_stack(self);
+    tsk_size_t num_nodes = 0;
     tsk_id_t u, v;
-    tsk_size_t j, num_samples;
-    int err, c;
-    tsk_site_t site;
-    tsk_id_t *children = tsk_malloc(self->num_nodes * sizeof(tsk_id_t));
-    bool *is_root = tsk_calloc(self->num_nodes, sizeof(bool));
-
-    tsk_bug_assert(children != NULL);
-
-    /* Check the virtual root properties */
-    tsk_bug_assert(self->parent[self->virtual_root] == TSK_NULL);
-    tsk_bug_assert(self->left_sib[self->virtual_root] == TSK_NULL);
-    tsk_bug_assert(self->right_sib[self->virtual_root] == TSK_NULL);
+    int stack_top;
 
-    for (j = 0; j < self->tree_sequence->num_samples; j++) {
-        u = self->samples[j];
-        while (self->parent[u] != TSK_NULL) {
-            u = self->parent[u];
-        }
-        is_root[u] = true;
-    }
-    if (self->tree_sequence->num_samples == 0) {
-        tsk_bug_assert(self->left_child[self->virtual_root] == TSK_NULL);
+    if (stack == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
     }
 
-    /* Iterate over the roots and make sure they are set */
-    for (u = tsk_tree_get_left_root(self); u != TSK_NULL; u = self->right_sib[u]) {
-        tsk_bug_assert(is_root[u]);
-        is_root[u] = false;
-    }
-    for (u = 0; u < (tsk_id_t) self->num_nodes; u++) {
-        tsk_bug_assert(!is_root[u]);
-        c = 0;
-        for (v = self->left_child[u]; v != TSK_NULL; v = self->right_sib[v]) {
-            tsk_bug_assert(self->parent[v] == u);
-            children[c] = v;
-            c++;
-        }
-        for (v = self->right_child[u]; v != TSK_NULL; v = self->left_sib[v]) {
-            tsk_bug_assert(c > 0);
-            c--;
-            tsk_bug_assert(v == children[c]);
-        }
-    }
-    for (j = 0; j < self->sites_length; j++) {
-        site = self->sites[j];
-        tsk_bug_assert(self->interval.left <= site.position);
-        tsk_bug_assert(site.position < self->interval.right);
+    if ((root == -1 || root == self->virtual_root)
+        && !tsk_tree_has_sample_counts(self)) {
+        ret = TSK_ERR_UNSUPPORTED_OPERATION;
+        goto out;
     }
-
-    if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
-        tsk_bug_assert(self->num_samples != NULL);
-        tsk_bug_assert(self->num_tracked_samples != NULL);
-        for (u = 0; u < (tsk_id_t) self->num_nodes; u++) {
-            err = tsk_tree_get_num_samples_by_traversal(self, u, &num_samples);
-            tsk_bug_assert(err == 0);
-            tsk_bug_assert(num_samples == (tsk_size_t) self->num_samples[u]);
+    if (root == -1) {
+        stack_top = -1;
+        for (u = right_child[self->virtual_root]; u != TSK_NULL; u = left_sib[u]) {
+            stack_top++;
+            stack[stack_top] = u;
         }
     } else {
-        tsk_bug_assert(self->num_samples == NULL);
-        tsk_bug_assert(self->num_tracked_samples == NULL);
-    }
-    if (self->options & TSK_SAMPLE_LISTS) {
-        tsk_bug_assert(self->right_sample != NULL);
-        tsk_bug_assert(self->left_sample != NULL);
-        tsk_bug_assert(self->next_sample != NULL);
-    } else {
-        tsk_bug_assert(self->right_sample == NULL);
-        tsk_bug_assert(self->left_sample == NULL);
-        tsk_bug_assert(self->next_sample == NULL);
-    }
-
-    free(children);
-    free(is_root);
-}
-
-void
-tsk_tree_print_state(const tsk_tree_t *self, FILE *out)
-{
-    tsk_size_t j;
-    tsk_site_t site;
-
-    fprintf(out, "Tree state:\n");
-    fprintf(out, "options = %d\n", self->options);
-    fprintf(out, "root_threshold = %lld\n", (long long) self->root_threshold);
-    fprintf(out, "left = %f\n", self->interval.left);
-    fprintf(out, "right = %f\n", self->interval.right);
-    fprintf(out, "index = %lld\n", (long long) self->index);
-    fprintf(out, "node\tparent\tlchild\trchild\tlsib\trsib");
-    if (self->options & TSK_SAMPLE_LISTS) {
-        fprintf(out, "\thead\ttail");
-    }
-    fprintf(out, "\n");
-
-    for (j = 0; j < self->num_nodes + 1; j++) {
-        fprintf(out, "%lld\t%lld\t%lld\t%lld\t%lld\t%lld", (long long) j,
-            (long long) self->parent[j], (long long) self->left_child[j],
-            (long long) self->right_child[j], (long long) self->left_sib[j],
-            (long long) self->right_sib[j]);
-        if (self->options & TSK_SAMPLE_LISTS) {
-            fprintf(out, "\t%lld\t%lld\t", (long long) self->left_sample[j],
-                (long long) self->right_sample[j]);
-        }
-        if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
-            fprintf(out, "\t%lld\t%lld", (long long) self->num_samples[j],
-                (long long) self->num_tracked_samples[j]);
+        ret = tsk_tree_check_node(self, root);
+        if (ret != 0) {
+            goto out;
         }
-        fprintf(out, "\n");
-    }
-    fprintf(out, "sites = \n");
-    for (j = 0; j < self->sites_length; j++) {
-        site = self->sites[j];
-        fprintf(out, "\t%lld\t%f\n", (long long) site.id, site.position);
+        stack_top = 0;
+        stack[stack_top] = root;
     }
-    tsk_tree_check_state(self);
-}
-
-/* Methods for positioning the tree along the sequence */
-
-/* The following methods are performance sensitive and so we use a
- * lot of restrict pointers. Because we are saying that we don't have
- * any aliases to these pointers, we pass around the reference to parent
- * since it's used in all the functions. */
-static inline void
-tsk_tree_update_sample_lists(
-    tsk_tree_t *self, tsk_id_t node, const tsk_id_t *restrict parent)
-{
-    tsk_id_t u, v, sample_index;
-    tsk_id_t *restrict left_child = self->left_child;
-    tsk_id_t *restrict right_sib = self->right_sib;
-    tsk_id_t *restrict left = self->left_sample;
-    tsk_id_t *restrict right = self->right_sample;
-    tsk_id_t *restrict next = self->next_sample;
-    const tsk_id_t *restrict sample_index_map = self->tree_sequence->sample_index_map;
 
-    for (u = node; u != TSK_NULL; u = parent[u]) {
-        sample_index = sample_index_map[u];
-        if (sample_index != TSK_NULL) {
-            right[u] = left[u];
-        } else {
-            left[u] = TSK_NULL;
-            right[u] = TSK_NULL;
-        }
-        for (v = left_child[u]; v != TSK_NULL; v = right_sib[v]) {
-            if (left[v] != TSK_NULL) {
-                tsk_bug_assert(right[v] != TSK_NULL);
-                if (left[u] == TSK_NULL) {
-                    left[u] = left[v];
-                    right[u] = right[v];
-                } else {
-                    next[right[u]] = left[v];
-                    right[u] = right[v];
-                }
-            }
+    while (stack_top >= 0) {
+        u = stack[stack_top];
+        stack_top--;
+        nodes[num_nodes] = u;
+        num_nodes++;
+        for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
+            stack_top++;
+            stack[stack_top] = v;
         }
     }
+    *num_nodes_ret = num_nodes;
+out:
+    tsk_safe_free(stack);
+    return ret;
 }
 
-static inline void
-tsk_tree_remove_branch(
-    tsk_tree_t *self, tsk_id_t p, tsk_id_t c, tsk_id_t *restrict parent)
+/* We could implement this using the preorder function, but since it's
+ * going to be performance critical we want to avoid the overhead
+ * of mallocing the intermediate node list (which will be bigger than
+ * the number of samples). */
+int
+tsk_tree_preorder_samples_from(
+    const tsk_tree_t *self, tsk_id_t root, tsk_id_t *nodes, tsk_size_t *num_nodes_ret)
 {
-    tsk_id_t *restrict left_child = self->left_child;
-    tsk_id_t *restrict right_child = self->right_child;
-    tsk_id_t *restrict left_sib = self->left_sib;
-    tsk_id_t *restrict right_sib = self->right_sib;
-    tsk_id_t *restrict num_children = self->num_children;
-    tsk_id_t lsib = left_sib[c];
-    tsk_id_t rsib = right_sib[c];
+    int ret = 0;
+    const tsk_id_t *restrict right_child = self->right_child;
+    const tsk_id_t *restrict left_sib = self->left_sib;
+    const tsk_flags_t *restrict flags = self->tree_sequence->tables->nodes.flags;
+    tsk_id_t *stack = tsk_tree_alloc_node_stack(self);
+    tsk_size_t num_nodes = 0;
+    tsk_id_t u, v;
+    int stack_top;
 
-    if (lsib == TSK_NULL) {
-        left_child[p] = rsib;
-    } else {
-        right_sib[lsib] = rsib;
-    }
-    if (rsib == TSK_NULL) {
-        right_child[p] = lsib;
-    } else {
-        left_sib[rsib] = lsib;
+    if (stack == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
     }
-    parent[c] = TSK_NULL;
-    left_sib[c] = TSK_NULL;
-    right_sib[c] = TSK_NULL;
-    num_children[p]--;
-}
-
-static inline void
-tsk_tree_insert_branch(
-    tsk_tree_t *self, tsk_id_t p, tsk_id_t c, tsk_id_t *restrict parent)
-{
-    tsk_id_t *restrict left_child = self->left_child;
-    tsk_id_t *restrict right_child = self->right_child;
-    tsk_id_t *restrict left_sib = self->left_sib;
-    tsk_id_t *restrict right_sib = self->right_sib;
-    tsk_id_t *restrict num_children = self->num_children;
-    tsk_id_t u;
 
-    parent[c] = p;
-    u = right_child[p];
-    if (u == TSK_NULL) {
-        left_child[p] = c;
-        left_sib[c] = TSK_NULL;
-        right_sib[c] = TSK_NULL;
+    /* We could push the virtual_root onto the stack directly to simplify
+     * the code a little, but then we'd have to check put an extra check
+     * when looking up the flags array (which isn't defined for virtual_root).
+     */
+    if (root == -1 || root == self->virtual_root) {
+        if (!tsk_tree_has_sample_counts(self)) {
+            ret = TSK_ERR_UNSUPPORTED_OPERATION;
+            goto out;
+        }
+        stack_top = -1;
+        for (u = right_child[self->virtual_root]; u != TSK_NULL; u = left_sib[u]) {
+            stack_top++;
+            stack[stack_top] = u;
+        }
     } else {
-        right_sib[u] = c;
-        left_sib[c] = u;
-        right_sib[c] = TSK_NULL;
+        ret = tsk_tree_check_node(self, root);
+        if (ret != 0) {
+            goto out;
+        }
+        stack_top = 0;
+        stack[stack_top] = root;
     }
-    right_child[p] = c;
-    num_children[p]++;
-}
 
-static inline void
-tsk_tree_insert_root(tsk_tree_t *self, tsk_id_t root, tsk_id_t *restrict parent)
-{
-    tsk_tree_insert_branch(self, self->virtual_root, root, parent);
-    parent[root] = TSK_NULL;
+    while (stack_top >= 0) {
+        u = stack[stack_top];
+        stack_top--;
+        if (flags[u] & TSK_NODE_IS_SAMPLE) {
+            nodes[num_nodes] = u;
+            num_nodes++;
+        }
+        for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
+            stack_top++;
+            stack[stack_top] = v;
+        }
+    }
+    *num_nodes_ret = num_nodes;
+out:
+    tsk_safe_free(stack);
+    return ret;
 }
 
-static inline void
-tsk_tree_remove_root(tsk_tree_t *self, tsk_id_t root, tsk_id_t *restrict parent)
+int
+tsk_tree_postorder(const tsk_tree_t *self, tsk_id_t *nodes, tsk_size_t *num_nodes_ret)
 {
-    tsk_tree_remove_branch(self, self->virtual_root, root, parent);
+    return tsk_tree_postorder_from(self, -1, nodes, num_nodes_ret);
 }
-
-static void
-tsk_tree_remove_edge(tsk_tree_t *self, tsk_id_t p, tsk_id_t c)
+int
+tsk_tree_postorder_from(
+    const tsk_tree_t *self, tsk_id_t root, tsk_id_t *nodes, tsk_size_t *num_nodes_ret)
 {
-    tsk_id_t *restrict parent = self->parent;
-    tsk_size_t *restrict num_samples = self->num_samples;
-    tsk_size_t *restrict num_tracked_samples = self->num_tracked_samples;
-    tsk_id_t *restrict edge = self->edge;
-    const tsk_size_t root_threshold = self->root_threshold;
-    tsk_id_t u;
-    tsk_id_t path_end = TSK_NULL;
-    bool path_end_was_root = false;
-
-#define POTENTIAL_ROOT(U) (num_samples[U] >= root_threshold)
+    int ret = 0;
+    const tsk_id_t *restrict right_child = self->right_child;
+    const tsk_id_t *restrict left_sib = self->left_sib;
+    const tsk_id_t *restrict parent = self->parent;
+    tsk_id_t *stack = tsk_tree_alloc_node_stack(self);
+    tsk_size_t num_nodes = 0;
+    tsk_id_t u, v, postorder_parent;
+    int stack_top;
+    bool is_virtual_root = root == self->virtual_root;
 
-    tsk_tree_remove_branch(self, p, c, parent);
-    self->num_edges--;
-    edge[c] = TSK_NULL;
+    if (stack == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
 
-    if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
-        u = p;
-        while (u != TSK_NULL) {
-            path_end = u;
-            path_end_was_root = POTENTIAL_ROOT(u);
-            num_samples[u] -= num_samples[c];
-            num_tracked_samples[u] -= num_tracked_samples[c];
-            u = parent[u];
+    if (root == -1 || is_virtual_root) {
+        if (!tsk_tree_has_sample_counts(self)) {
+            ret = TSK_ERR_UNSUPPORTED_OPERATION;
+            goto out;
         }
-
-        if (path_end_was_root && !POTENTIAL_ROOT(path_end)) {
-            tsk_tree_remove_root(self, path_end, parent);
+        stack_top = -1;
+        for (u = right_child[self->virtual_root]; u != TSK_NULL; u = left_sib[u]) {
+            stack_top++;
+            stack[stack_top] = u;
         }
-        if (POTENTIAL_ROOT(c)) {
-            tsk_tree_insert_root(self, c, parent);
+    } else {
+        ret = tsk_tree_check_node(self, root);
+        if (ret != 0) {
+            goto out;
         }
+        stack_top = 0;
+        stack[stack_top] = root;
     }
 
-    if (self->options & TSK_SAMPLE_LISTS) {
-        tsk_tree_update_sample_lists(self, p, parent);
+    postorder_parent = TSK_NULL;
+    while (stack_top >= 0) {
+        u = stack[stack_top];
+        if (right_child[u] != TSK_NULL && u != postorder_parent) {
+            for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
+                stack_top++;
+                stack[stack_top] = v;
+            }
+        } else {
+            stack_top--;
+            postorder_parent = parent[u];
+            nodes[num_nodes] = u;
+            num_nodes++;
+        }
+    }
+    if (is_virtual_root) {
+        nodes[num_nodes] = root;
+        num_nodes++;
     }
+    *num_nodes_ret = num_nodes;
+out:
+    tsk_safe_free(stack);
+    return ret;
 }
 
-static void
-tsk_tree_insert_edge(tsk_tree_t *self, tsk_id_t p, tsk_id_t c, tsk_id_t edge_id)
+/* Balance/imbalance metrics */
+
+/* Result is a tsk_size_t value here because we could imagine the total
+ * depth overflowing a 32bit integer for a large tree. */
+int
+tsk_tree_sackin_index(const tsk_tree_t *self, tsk_size_t *result)
 {
-    tsk_id_t *restrict parent = self->parent;
-    tsk_size_t *restrict num_samples = self->num_samples;
-    tsk_size_t *restrict num_tracked_samples = self->num_tracked_samples;
-    tsk_id_t *restrict edge = self->edge;
-    const tsk_size_t root_threshold = self->root_threshold;
+    /* Keep the size of the stack elements to 8 bytes in total in the
+     * standard case. A tsk_id_t depth value is always safe, since
+     * depth counts the number of nodes encountered on a path.
+     */
+    struct stack_elem {
+        tsk_id_t node;
+        tsk_id_t depth;
+    };
+    int ret = 0;
+    const tsk_id_t *restrict right_child = self->right_child;
+    const tsk_id_t *restrict left_sib = self->left_sib;
+    struct stack_elem *stack
+        = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*stack));
+    int stack_top;
+    tsk_size_t total_depth;
     tsk_id_t u;
-    tsk_id_t path_end = TSK_NULL;
-    bool path_end_was_root = false;
-
-#define POTENTIAL_ROOT(U) (num_samples[U] >= root_threshold)
-
-    if (!(self->options & TSK_NO_SAMPLE_COUNTS)) {
-        u = p;
-        while (u != TSK_NULL) {
-            path_end = u;
-            path_end_was_root = POTENTIAL_ROOT(u);
-            num_samples[u] += num_samples[c];
-            num_tracked_samples[u] += num_tracked_samples[c];
-            u = parent[u];
-        }
+    struct stack_elem s = { .node = TSK_NULL, .depth = 0 };
 
-        if (POTENTIAL_ROOT(c)) {
-            tsk_tree_remove_root(self, c, parent);
-        }
-        if (POTENTIAL_ROOT(path_end) && !path_end_was_root) {
-            tsk_tree_insert_root(self, path_end, parent);
-        }
+    if (stack == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
     }
 
-    tsk_tree_insert_branch(self, p, c, parent);
-    self->num_edges++;
-    edge[c] = edge_id;
-
-    if (self->options & TSK_SAMPLE_LISTS) {
-        tsk_tree_update_sample_lists(self, p, parent);
+    stack_top = -1;
+    for (u = right_child[self->virtual_root]; u != TSK_NULL; u = left_sib[u]) {
+        stack_top++;
+        s.node = u;
+        stack[stack_top] = s;
+    }
+    total_depth = 0;
+    while (stack_top >= 0) {
+        s = stack[stack_top];
+        stack_top--;
+        u = right_child[s.node];
+        if (u == TSK_NULL) {
+            total_depth += (tsk_size_t) s.depth;
+        } else {
+            s.depth++;
+            while (u != TSK_NULL) {
+                stack_top++;
+                s.node = u;
+                stack[stack_top] = s;
+                u = left_sib[u];
+            }
+        }
     }
+    *result = total_depth;
+out:
+    tsk_safe_free(stack);
+    return ret;
 }
 
-static int
-tsk_tree_advance(tsk_tree_t *self, int direction, const double *restrict out_breakpoints,
-    const tsk_id_t *restrict out_order, tsk_id_t *out_index,
-    const double *restrict in_breakpoints, const tsk_id_t *restrict in_order,
-    tsk_id_t *in_index)
+int
+tsk_tree_colless_index(const tsk_tree_t *self, tsk_size_t *result)
 {
     int ret = 0;
-    const int direction_change = direction * (direction != self->direction);
-    tsk_id_t in = *in_index + direction_change;
-    tsk_id_t out = *out_index + direction_change;
-    tsk_id_t k;
-    const tsk_table_collection_t *tables = self->tree_sequence->tables;
-    const double sequence_length = tables->sequence_length;
-    const tsk_id_t num_edges = (tsk_id_t) tables->edges.num_rows;
-    const tsk_id_t *restrict edge_parent = tables->edges.parent;
-    const tsk_id_t *restrict edge_child = tables->edges.child;
-    double x;
+    const tsk_id_t *restrict right_child = self->right_child;
+    const tsk_id_t *restrict left_sib = self->left_sib;
+    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
+    tsk_id_t *num_leaves = tsk_calloc(self->num_nodes, sizeof(*num_leaves));
+    tsk_size_t j, num_nodes, total;
+    tsk_id_t num_children, u, v;
 
-    if (direction == TSK_DIR_FORWARD) {
-        x = self->interval.right;
-    } else {
-        x = self->interval.left;
+    if (nodes == NULL || num_leaves == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
     }
-    while (out >= 0 && out < num_edges && out_breakpoints[out_order[out]] == x) {
-        tsk_bug_assert(out < num_edges);
-        k = out_order[out];
-        out += direction;
-        tsk_tree_remove_edge(self, edge_parent[k], edge_child[k]);
+    if (tsk_tree_get_num_roots(self) != 1) {
+        ret = TSK_ERR_UNDEFINED_MULTIROOT;
+        goto out;
     }
-
-    while (in >= 0 && in < num_edges && in_breakpoints[in_order[in]] == x) {
-        k = in_order[in];
-        in += direction;
-        tsk_tree_insert_edge(self, edge_parent[k], edge_child[k], k);
+    ret = tsk_tree_postorder(self, nodes, &num_nodes);
+    if (ret != 0) {
+        goto out;
     }
 
-    self->direction = direction;
-    self->index = self->index + direction;
-    if (direction == TSK_DIR_FORWARD) {
-        self->interval.left = x;
-        self->interval.right = sequence_length;
-        if (out >= 0 && out < num_edges) {
-            self->interval.right
-                = TSK_MIN(self->interval.right, out_breakpoints[out_order[out]]);
-        }
-        if (in >= 0 && in < num_edges) {
-            self->interval.right
-                = TSK_MIN(self->interval.right, in_breakpoints[in_order[in]]);
-        }
-    } else {
-        self->interval.right = x;
-        self->interval.left = 0;
-        if (out >= 0 && out < num_edges) {
-            self->interval.left
-                = TSK_MAX(self->interval.left, out_breakpoints[out_order[out]]);
+    total = 0;
+    for (j = 0; j < num_nodes; j++) {
+        u = nodes[j];
+        /* Cheaper to compute this on the fly than to access the num_children array.
+         * since we're already iterating over the children. */
+        num_children = 0;
+        for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
+            num_children++;
+            num_leaves[u] += num_leaves[v];
         }
-        if (in >= 0 && in < num_edges) {
-            self->interval.left
-                = TSK_MAX(self->interval.left, in_breakpoints[in_order[in]]);
+        if (num_children == 0) {
+            num_leaves[u] = 1;
+        } else if (num_children == 2) {
+            v = right_child[u];
+            total += (tsk_size_t) llabs(num_leaves[v] - num_leaves[left_sib[v]]);
+        } else {
+            ret = TSK_ERR_UNDEFINED_NONBINARY;
+            goto out;
         }
     }
-    tsk_bug_assert(self->interval.left < self->interval.right);
-    *out_index = out;
-    *in_index = in;
-    if (tables->sites.num_rows > 0) {
-        self->sites = self->tree_sequence->tree_sites[self->index];
-        self->sites_length = self->tree_sequence->tree_sites_length[self->index];
-    }
-    ret = TSK_TREE_OK;
+    *result = total;
+out:
+    tsk_safe_free(nodes);
+    tsk_safe_free(num_leaves);
     return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_tree_first(tsk_tree_t *self)
+int
+tsk_tree_b1_index(const tsk_tree_t *self, double *result)
 {
-    int ret = TSK_TREE_OK;
-    tsk_table_collection_t *tables = self->tree_sequence->tables;
+    int ret = 0;
+    const tsk_id_t *restrict parent = self->parent;
+    const tsk_id_t *restrict right_child = self->right_child;
+    const tsk_id_t *restrict left_sib = self->left_sib;
+    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
+    tsk_size_t *max_path_length = tsk_calloc(self->num_nodes, sizeof(*max_path_length));
+    tsk_size_t j, num_nodes, mpl;
+    double total = 0.0;
+    tsk_id_t u, v;
 
-    self->interval.left = 0;
-    self->index = 0;
-    self->interval.right = tables->sequence_length;
-    self->sites = self->tree_sequence->tree_sites[0];
-    self->sites_length = self->tree_sequence->tree_sites_length[0];
+    if (nodes == NULL || max_path_length == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    ret = tsk_tree_postorder(self, nodes, &num_nodes);
+    if (ret != 0) {
+        goto out;
+    }
 
-    if (tables->edges.num_rows > 0) {
-        /* TODO this is redundant if this is the first usage of the tree. We
-         * should add a state machine here so we know what state the tree is
-         * in and can take the appropriate actions.
-         */
-        ret = tsk_tree_clear(self);
-        if (ret != 0) {
-            goto out;
+    for (j = 0; j < num_nodes; j++) {
+        u = nodes[j];
+        if (parent[u] != TSK_NULL && right_child[u] != TSK_NULL) {
+            mpl = 0;
+            for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
+                mpl = TSK_MAX(mpl, max_path_length[v]);
+            }
+            max_path_length[u] = mpl + 1;
+            total += 1 / (double) max_path_length[u];
         }
-        self->index = -1;
-        self->left_index = 0;
-        self->right_index = 0;
-        self->direction = TSK_DIR_FORWARD;
-        self->interval.right = 0;
-
-        ret = tsk_tree_advance(self, TSK_DIR_FORWARD, tables->edges.right,
-            tables->indexes.edge_removal_order, &self->right_index, tables->edges.left,
-            tables->indexes.edge_insertion_order, &self->left_index);
     }
+    *result = total;
 out:
+    tsk_safe_free(nodes);
+    tsk_safe_free(max_path_length);
     return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_tree_last(tsk_tree_t *self)
+static double
+general_log(double x, double base)
 {
-    int ret = TSK_TREE_OK;
-    const tsk_treeseq_t *ts = self->tree_sequence;
-    const tsk_table_collection_t *tables = ts->tables;
+    return log(x) / log(base);
+}
 
-    self->interval.left = 0;
-    self->interval.right = tables->sequence_length;
-    self->index = 0;
-    self->sites = ts->tree_sites[0];
-    self->sites_length = ts->tree_sites_length[0];
+int
+tsk_tree_b2_index(const tsk_tree_t *self, double base, double *result)
+{
+    struct stack_elem {
+        tsk_id_t node;
+        double path_product;
+    };
+    int ret = 0;
+    const tsk_id_t *restrict right_child = self->right_child;
+    const tsk_id_t *restrict left_sib = self->left_sib;
+    struct stack_elem *stack
+        = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*stack));
+    int stack_top;
+    double total_proba = 0;
+    double num_children;
+    tsk_id_t u;
+    struct stack_elem s = { .node = TSK_NULL, .path_product = 1 };
 
-    if (tables->edges.num_rows > 0) {
-        /* TODO this is redundant if this is the first usage of the tree. We
-         * should add a state machine here so we know what state the tree is
-         * in and can take the appropriate actions.
-         */
-        ret = tsk_tree_clear(self);
-        if (ret != 0) {
-            goto out;
-        }
-        self->index = (tsk_id_t) tsk_treeseq_get_num_trees(ts);
-        self->left_index = (tsk_id_t) tables->edges.num_rows - 1;
-        self->right_index = (tsk_id_t) tables->edges.num_rows - 1;
-        self->direction = TSK_DIR_REVERSE;
-        self->interval.left = tables->sequence_length;
-        self->interval.right = 0;
+    if (stack == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    if (tsk_tree_get_num_roots(self) != 1) {
+        ret = TSK_ERR_UNDEFINED_MULTIROOT;
+        goto out;
+    }
 
-        ret = tsk_tree_advance(self, TSK_DIR_REVERSE, tables->edges.left,
-            tables->indexes.edge_insertion_order, &self->left_index, tables->edges.right,
-            tables->indexes.edge_removal_order, &self->right_index);
+    stack_top = 0;
+    s.node = tsk_tree_get_left_root(self);
+    stack[stack_top] = s;
+
+    while (stack_top >= 0) {
+        s = stack[stack_top];
+        stack_top--;
+        u = right_child[s.node];
+        if (u == TSK_NULL) {
+            total_proba -= s.path_product * general_log(s.path_product, base);
+        } else {
+            num_children = 0;
+            for (; u != TSK_NULL; u = left_sib[u]) {
+                num_children++;
+            }
+            s.path_product *= 1 / num_children;
+            for (u = right_child[s.node]; u != TSK_NULL; u = left_sib[u]) {
+                stack_top++;
+                s.node = u;
+                stack[stack_top] = s;
+            }
+        }
     }
+    *result = total_proba;
 out:
+    tsk_safe_free(stack);
     return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_tree_next(tsk_tree_t *self)
+int
+tsk_tree_num_lineages(const tsk_tree_t *self, double t, tsk_size_t *result)
 {
     int ret = 0;
-    const tsk_treeseq_t *ts = self->tree_sequence;
-    const tsk_table_collection_t *tables = ts->tables;
-    tsk_id_t num_trees = (tsk_id_t) tsk_treeseq_get_num_trees(ts);
+    const tsk_id_t *restrict right_child = self->right_child;
+    const tsk_id_t *restrict left_sib = self->left_sib;
+    const double *restrict time = self->tree_sequence->tables->nodes.time;
+    tsk_id_t *stack = tsk_tree_alloc_node_stack(self);
+    tsk_size_t num_lineages = 0;
+    int stack_top;
+    tsk_id_t u, v;
+    double child_time, parent_time;
 
-    if (self->index == -1) {
-        ret = tsk_tree_first(self);
-    } else if (self->index < num_trees - 1) {
-        ret = tsk_tree_advance(self, TSK_DIR_FORWARD, tables->edges.right,
-            tables->indexes.edge_removal_order, &self->right_index, tables->edges.left,
-            tables->indexes.edge_insertion_order, &self->left_index);
-    } else {
-        ret = tsk_tree_clear(self);
+    if (stack == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
+    }
+    if (!tsk_isfinite(t)) {
+        ret = TSK_ERR_TIME_NONFINITE;
+        goto out;
+    }
+    /* Push the roots onto the stack */
+    stack_top = -1;
+    for (u = right_child[self->virtual_root]; u != TSK_NULL; u = left_sib[u]) {
+        stack_top++;
+        stack[stack_top] = u;
+    }
+
+    while (stack_top >= 0) {
+        u = stack[stack_top];
+        parent_time = time[u];
+        stack_top--;
+        for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
+            child_time = time[v];
+            /* Only traverse down the tree as far as we need to */
+            if (child_time > t) {
+                stack_top++;
+                stack[stack_top] = v;
+            } else if (t < parent_time) {
+                num_lineages++;
+            }
+        }
     }
+    *result = num_lineages;
+out:
+    tsk_safe_free(stack);
     return ret;
 }
 
-int TSK_WARN_UNUSED
-tsk_tree_prev(tsk_tree_t *self)
-{
-    int ret = 0;
-    const tsk_table_collection_t *tables = self->tree_sequence->tables;
+/* Parsimony methods */
 
-    if (self->index == -1) {
-        ret = tsk_tree_last(self);
-    } else if (self->index > 0) {
-        ret = tsk_tree_advance(self, TSK_DIR_REVERSE, tables->edges.left,
-            tables->indexes.edge_insertion_order, &self->left_index, tables->edges.right,
-            tables->indexes.edge_removal_order, &self->right_index);
-    } else {
-        ret = tsk_tree_clear(self);
-    }
-    return ret;
+static inline uint64_t
+set_bit(uint64_t value, int32_t bit)
+{
+    return value | (1ULL << bit);
 }
 
 static inline bool
-tsk_tree_position_in_interval(const tsk_tree_t *self, double x)
+bit_is_set(uint64_t value, int32_t bit)
 {
-    return self->interval.left <= x && x < self->interval.right;
+    return (value & (1ULL << bit)) != 0;
 }
 
-/* NOTE:
- *
- * Notes from Kevin Thornton:
+static inline int8_t
+get_smallest_set_bit(uint64_t v)
+{
+    /* This is an inefficient implementation, there are several better
+     * approaches. On GCC we can use
+     * return (uint8_t) (__builtin_ffsll((long long) v) - 1);
+     */
+    uint64_t t = 1;
+    int8_t r = 0;
+
+    assert(v != 0);
+    while ((v & t) == 0) {
+        t <<= 1;
+        r++;
+    }
+    return r;
+}
+
+#define HARTIGAN_MAX_ALLELES 64
+
+/* This interface is experimental. In the future, we should provide the option to
+ * use a general cost matrix, in which case we'll use the Sankoff algorithm. For
+ * now this is unused.
  *
- * This method inserts the edges for an arbitrary tree
- * in linear time and requires no additional memory.
+ * We should also vectorise the function so that several sites can be processed
+ * at once.
  *
- * During design, the following alternatives were tested
- * (in a combination of rust + C):
- * 1. Indexing edge insertion/removal locations by tree.
- *    The indexing can be done in O(n) time, giving O(1)
- *    access to the first edge in a tree. We can then add
- *    edges to the tree in O(e) time, where e is the number
- *    of edges. This apparoach requires O(n) additional memory
- *    and is only marginally faster than the implementation below.
- * 2. Building an interval tree mapping edge id -> span.
- *    This approach adds a lot of complexity and wasn't any faster
- *    than the indexing described above.
+ * The algorithm used here is Hartigan parsimony, "Minimum Mutation Fits to a
+ * Given Tree", Biometrics 1973.
  */
-static int
-tsk_tree_seek_from_null(tsk_tree_t *self, double x, tsk_flags_t TSK_UNUSED(options))
+int TSK_WARN_UNUSED
+tsk_tree_map_mutations(tsk_tree_t *self, int32_t *genotypes,
+    double *TSK_UNUSED(cost_matrix), tsk_flags_t options, int32_t *r_ancestral_state,
+    tsk_size_t *r_num_transitions, tsk_state_transition_t **r_transitions)
 {
     int ret = 0;
-    tsk_size_t edge;
-    tsk_id_t p, c, e, j, k, tree_index;
-    const double L = tsk_treeseq_get_sequence_length(self->tree_sequence);
-    const tsk_treeseq_t *treeseq = self->tree_sequence;
-    const tsk_table_collection_t *tables = treeseq->tables;
-    const tsk_id_t *restrict edge_parent = tables->edges.parent;
-    const tsk_id_t *restrict edge_child = tables->edges.child;
-    const tsk_size_t num_edges = tables->edges.num_rows;
-    const tsk_size_t num_trees = self->tree_sequence->num_trees;
-    const double *restrict edge_left = tables->edges.left;
-    const double *restrict edge_right = tables->edges.right;
-    const double *restrict breakpoints = treeseq->breakpoints;
-    const tsk_id_t *restrict insertion = tables->indexes.edge_insertion_order;
-    const tsk_id_t *restrict removal = tables->indexes.edge_removal_order;
-
-    // NOTE: it may be better to get the
-    // index first and then ask if we are
-    // searching in the first or last 1/2
-    // of trees.
-    j = -1;
-    if (x <= L / 2.0) {
-        for (edge = 0; edge < num_edges; edge++) {
-            e = insertion[edge];
-            if (edge_left[e] > x) {
-                j = (tsk_id_t) edge;
-                break;
-            }
-            if (x >= edge_left[e] && x < edge_right[e]) {
-                p = edge_parent[e];
-                c = edge_child[e];
-                tsk_tree_insert_edge(self, p, c, e);
-            }
-        }
-    } else {
-        for (edge = 0; edge < num_edges; edge++) {
-            e = removal[num_edges - edge - 1];
-            if (edge_right[e] < x) {
-                j = (tsk_id_t)(num_edges - edge - 1);
-                while (j < (tsk_id_t) num_edges && edge_left[insertion[j]] <= x) {
-                    j++;
-                }
-                break;
-            }
-            if (x >= edge_left[e] && x < edge_right[e]) {
-                p = edge_parent[e];
-                c = edge_child[e];
-                tsk_tree_insert_edge(self, p, c, e);
-            }
-        }
-    }
-
-    if (j == -1) {
-        j = 0;
-        while (j < (tsk_id_t) num_edges && edge_left[insertion[j]] <= x) {
-            j++;
-        }
-    }
-    k = 0;
-    while (k < (tsk_id_t) num_edges && edge_right[removal[k]] <= x) {
-        k++;
-    }
+    struct stack_elem {
+        tsk_id_t node;
+        tsk_id_t transition_parent;
+        int32_t state;
+    };
+    const tsk_size_t num_samples = self->tree_sequence->num_samples;
+    const tsk_id_t *restrict left_child = self->left_child;
+    const tsk_id_t *restrict right_sib = self->right_sib;
+    const tsk_size_t N = tsk_treeseq_get_num_nodes(self->tree_sequence);
+    const tsk_flags_t *restrict node_flags = self->tree_sequence->tables->nodes.flags;
+    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
+    /* Note: to use less memory here and to improve cache performance we should
+     * probably change to allocating exactly the number of nodes returned by
+     * a preorder traversal, and then lay the memory out in this order. So, we'd
+     * need a map from node ID to its index in the preorder traversal, but this
+     * is trivial to compute. Probably doesn't matter so much at the moment
+     * when we're doing a single site, but it would make a big difference if
+     * we were vectorising over lots of sites. */
+    uint64_t *restrict optimal_set = tsk_calloc(N + 1, sizeof(*optimal_set));
+    struct stack_elem *restrict preorder_stack
+        = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*preorder_stack));
+    tsk_id_t u, v;
+    /* The largest possible number of transitions is one over every sample */
+    tsk_state_transition_t *transitions = tsk_malloc(num_samples * sizeof(*transitions));
+    int32_t allele, ancestral_state;
+    int stack_top;
+    struct stack_elem s;
+    tsk_size_t j, num_transitions, max_allele_count, num_nodes;
+    tsk_size_t allele_count[HARTIGAN_MAX_ALLELES];
+    tsk_size_t non_missing = 0;
+    int32_t num_alleles = 0;
 
-    /* NOTE: tsk_search_sorted finds the first the first
-     * insertion locatiom >= the query point, which
-     * finds a RIGHT value for queries not at the left edge.
-     */
-    tree_index = (tsk_id_t) tsk_search_sorted(breakpoints, num_trees + 1, x);
-    if (breakpoints[tree_index] > x) {
-        tree_index--;
+    if (optimal_set == NULL || preorder_stack == NULL || transitions == NULL
+        || nodes == NULL) {
+        ret = TSK_ERR_NO_MEMORY;
+        goto out;
     }
-    self->index = tree_index;
-    self->interval.left = breakpoints[tree_index];
-    self->interval.right = breakpoints[tree_index + 1];
-    self->left_index = j;
-    self->right_index = k;
-    self->direction = TSK_DIR_FORWARD;
-    self->num_nodes = tables->nodes.num_rows;
-    if (tables->sites.num_rows > 0) {
-        self->sites = treeseq->tree_sites[self->index];
-        self->sites_length = treeseq->tree_sites_length[self->index];
+    for (j = 0; j < num_samples; j++) {
+        if (genotypes[j] >= HARTIGAN_MAX_ALLELES || genotypes[j] < TSK_MISSING_DATA) {
+            ret = TSK_ERR_BAD_GENOTYPE;
+            goto out;
+        }
+        u = self->tree_sequence->samples[j];
+        if (genotypes[j] == TSK_MISSING_DATA) {
+            /* All bits set */
+            optimal_set[u] = UINT64_MAX;
+        } else {
+            optimal_set[u] = set_bit(optimal_set[u], genotypes[j]);
+            num_alleles = TSK_MAX(genotypes[j], num_alleles);
+            non_missing++;
+        }
     }
 
-    return ret;
-}
-
-int TSK_WARN_UNUSED
-tsk_tree_seek_index(tsk_tree_t *self, tsk_id_t tree, tsk_flags_t options)
-{
-    int ret = 0;
-    double x;
-
-    if (tree < 0 || tree >= (tsk_id_t) self->tree_sequence->num_trees) {
-        ret = TSK_ERR_SEEK_OUT_OF_BOUNDS;
+    if (non_missing == 0) {
+        ret = TSK_ERR_GENOTYPES_ALL_MISSING;
         goto out;
     }
-    x = self->tree_sequence->breakpoints[tree];
-    ret = tsk_tree_seek(self, x, options);
-out:
-    return ret;
-}
+    num_alleles++;
 
-static int TSK_WARN_UNUSED
-tsk_tree_seek_linear(tsk_tree_t *self, double x, tsk_flags_t TSK_UNUSED(options))
-{
-    const double L = tsk_treeseq_get_sequence_length(self->tree_sequence);
-    const double t_l = self->interval.left;
-    const double t_r = self->interval.right;
-    int ret = 0;
-    double distance_left, distance_right;
+    ancestral_state = 0; /* keep compiler happy */
+    if (options & TSK_MM_FIXED_ANCESTRAL_STATE) {
+        ancestral_state = *r_ancestral_state;
+        if ((ancestral_state < 0) || (ancestral_state >= HARTIGAN_MAX_ALLELES)) {
+            ret = TSK_ERR_BAD_ANCESTRAL_STATE;
+            goto out;
+        } else if (ancestral_state >= num_alleles) {
+            num_alleles = (int32_t)(ancestral_state + 1);
+        }
+    }
 
-    if (x < t_l) {
-        /* |-----|-----|========|---------| */
-        /* 0     x    t_l      t_r        L */
-        distance_left = t_l - x;
-        distance_right = L - t_r + x;
-    } else {
-        /* |------|========|------|-------| */
-        /* 0     t_l      t_r     x       L */
-        distance_right = x - t_r;
-        distance_left = t_l + L - x;
+    ret = tsk_tree_postorder_from(self, self->virtual_root, nodes, &num_nodes);
+    if (ret != 0) {
+        goto out;
     }
-    if (distance_right <= distance_left) {
-        while (!tsk_tree_position_in_interval(self, x)) {
-            ret = tsk_tree_next(self);
-            if (ret < 0) {
-                goto out;
+    for (j = 0; j < num_nodes; j++) {
+        u = nodes[j];
+        tsk_memset(allele_count, 0, ((size_t) num_alleles) * sizeof(*allele_count));
+        for (v = left_child[u]; v != TSK_NULL; v = right_sib[v]) {
+            for (allele = 0; allele < num_alleles; allele++) {
+                allele_count[allele] += bit_is_set(optimal_set[v], allele);
             }
         }
-    } else {
-        while (!tsk_tree_position_in_interval(self, x)) {
-            ret = tsk_tree_prev(self);
-            if (ret < 0) {
-                goto out;
+        /* the virtual root has no flags defined */
+        if (u == (tsk_id_t) N || !(node_flags[u] & TSK_NODE_IS_SAMPLE)) {
+            max_allele_count = 0;
+            for (allele = 0; allele < num_alleles; allele++) {
+                max_allele_count = TSK_MAX(max_allele_count, allele_count[allele]);
+            }
+            for (allele = 0; allele < num_alleles; allele++) {
+                if (allele_count[allele] == max_allele_count) {
+                    optimal_set[u] = set_bit(optimal_set[u], allele);
+                }
             }
         }
     }
-    ret = 0;
-out:
-    return ret;
-}
-
-int TSK_WARN_UNUSED
-tsk_tree_seek(tsk_tree_t *self, double x, tsk_flags_t options)
-{
-    int ret = 0;
-    const double L = tsk_treeseq_get_sequence_length(self->tree_sequence);
-
-    if (x < 0 || x >= L) {
-        ret = TSK_ERR_SEEK_OUT_OF_BOUNDS;
-        goto out;
-    }
-
-    if (self->index == -1) {
-        ret = tsk_tree_seek_from_null(self, x, options);
+    if (!(options & TSK_MM_FIXED_ANCESTRAL_STATE)) {
+        ancestral_state = get_smallest_set_bit(optimal_set[self->virtual_root]);
     } else {
-        ret = tsk_tree_seek_linear(self, x, options);
+        optimal_set[self->virtual_root] = UINT64_MAX;
     }
 
-out:
-    return ret;
-}
-
-int TSK_WARN_UNUSED
-tsk_tree_clear(tsk_tree_t *self)
-{
-    int ret = 0;
-    tsk_size_t j;
-    tsk_id_t u;
-    const tsk_size_t N = self->num_nodes + 1;
-    const tsk_size_t num_samples = self->tree_sequence->num_samples;
-    const bool sample_counts = !(self->options & TSK_NO_SAMPLE_COUNTS);
-    const bool sample_lists = !!(self->options & TSK_SAMPLE_LISTS);
-    const tsk_flags_t *flags = self->tree_sequence->tables->nodes.flags;
+    num_transitions = 0;
 
-    self->interval.left = 0;
-    self->interval.right = 0;
-    self->num_edges = 0;
-    self->index = -1;
-    /* TODO we should profile this method to see if just doing a single loop over
-     * the nodes would be more efficient than multiple memsets.
-     */
-    tsk_memset(self->parent, 0xff, N * sizeof(*self->parent));
-    tsk_memset(self->left_child, 0xff, N * sizeof(*self->left_child));
-    tsk_memset(self->right_child, 0xff, N * sizeof(*self->right_child));
-    tsk_memset(self->left_sib, 0xff, N * sizeof(*self->left_sib));
-    tsk_memset(self->right_sib, 0xff, N * sizeof(*self->right_sib));
-    tsk_memset(self->num_children, 0, N * sizeof(*self->num_children));
-    tsk_memset(self->edge, 0xff, N * sizeof(*self->edge));
+    /* Do a preorder traversal */
+    preorder_stack[0].node = self->virtual_root;
+    preorder_stack[0].state = ancestral_state;
+    preorder_stack[0].transition_parent = TSK_NULL;
+    stack_top = 0;
+    while (stack_top >= 0) {
+        s = preorder_stack[stack_top];
+        stack_top--;
 
-    if (sample_counts) {
-        tsk_memset(self->num_samples, 0, N * sizeof(*self->num_samples));
-        /* We can't reset the tracked samples via memset because we don't
-         * know where the tracked samples are.
-         */
-        for (j = 0; j < self->num_nodes; j++) {
-            if (!(flags[j] & TSK_NODE_IS_SAMPLE)) {
-                self->num_tracked_samples[j] = 0;
-            }
+        if (!bit_is_set(optimal_set[s.node], s.state)) {
+            s.state = get_smallest_set_bit(optimal_set[s.node]);
+            transitions[num_transitions].node = s.node;
+            transitions[num_transitions].parent = s.transition_parent;
+            transitions[num_transitions].state = s.state;
+            s.transition_parent = (tsk_id_t) num_transitions;
+            num_transitions++;
+        }
+        for (v = left_child[s.node]; v != TSK_NULL; v = right_sib[v]) {
+            stack_top++;
+            s.node = v;
+            preorder_stack[stack_top] = s;
         }
-        /* The total tracked_samples gets set in set_tracked_samples */
-        self->num_samples[self->virtual_root] = num_samples;
     }
-    if (sample_lists) {
-        tsk_memset(self->left_sample, 0xff, N * sizeof(tsk_id_t));
-        tsk_memset(self->right_sample, 0xff, N * sizeof(tsk_id_t));
-        tsk_memset(self->next_sample, 0xff, num_samples * sizeof(tsk_id_t));
+
+    *r_transitions = transitions;
+    *r_num_transitions = num_transitions;
+    *r_ancestral_state = ancestral_state;
+    transitions = NULL;
+out:
+    tsk_safe_free(transitions);
+    /* Cannot safe_free because of 'restrict' */
+    if (optimal_set != NULL) {
+        free(optimal_set);
     }
-    /* Set the sample attributes */
-    for (j = 0; j < num_samples; j++) {
-        u = self->samples[j];
-        if (sample_counts) {
-            self->num_samples[u] = 1;
-        }
-        if (sample_lists) {
-            /* We are mapping to *indexes* into the list of samples here */
-            self->left_sample[u] = (tsk_id_t) j;
-            self->right_sample[u] = (tsk_id_t) j;
-        }
+    if (preorder_stack != NULL) {
+        free(preorder_stack);
     }
-    if (sample_counts && self->root_threshold == 1 && num_samples > 0) {
-        for (j = 0; j < num_samples; j++) {
-            /* Set initial roots */
-            if (self->root_threshold == 1) {
-                tsk_tree_insert_root(self, self->samples[j], self->parent);
-            }
-        }
+    if (nodes != NULL) {
+        free(nodes);
     }
     return ret;
 }
 
-tsk_size_t
-tsk_tree_get_size_bound(const tsk_tree_t *self)
+/* Compatibility shim for initialising the diff iterator from a tree sequence. We are
+ * using this function in a small number of places internally, so simplest to keep it
+ * until a more satisfactory "diff" API comes along.
+ */
+int TSK_WARN_UNUSED
+tsk_diff_iter_init_from_ts(
+    tsk_diff_iter_t *self, const tsk_treeseq_t *tree_sequence, tsk_flags_t options)
 {
-    tsk_size_t bound = 0;
-
-    if (self->tree_sequence != NULL) {
-        /* This is a safe upper bound which can be computed cheaply.
-         * We have at most n roots and each edge adds at most one new
-         * node to the tree. We also allow space for the virtual root,
-         * to simplify client code.
-         *
-         * In the common case of a binary tree with a single root, we have
-         * 2n - 1 nodes in total, and 2n - 2 edges. Therefore, we return
-         * 3n - 1, which is an over-estimate of 1/2 and we allocate
-         * 1.5 times as much memory as we need.
-         *
-         * Since tracking the exact number of nodes in the tree would require
-         * storing the number of nodes beneath every node and complicate
-         * the tree transition method, this seems like a good compromise
-         * and will result in less memory usage overall in nearly all cases.
-         */
-        bound = 1 + self->tree_sequence->num_samples + self->num_edges;
-    }
-    return bound;
+    return tsk_diff_iter_init(
+        self, tree_sequence->tables, (tsk_id_t) tree_sequence->num_trees, options);
 }
 
-/* Traversal orders */
-static tsk_id_t *
-tsk_tree_alloc_node_stack(const tsk_tree_t *self)
-{
-    return tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(tsk_id_t));
-}
+/* ======================================================== *
+ * KC Distance
+ * ======================================================== */
 
-int
-tsk_tree_preorder(const tsk_tree_t *self, tsk_id_t *nodes, tsk_size_t *num_nodes_ret)
-{
-    return tsk_tree_preorder_from(self, -1, nodes, num_nodes_ret);
-}
+typedef struct {
+    tsk_size_t *m;
+    double *M;
+    tsk_id_t n;
+    tsk_id_t N;
+} kc_vectors;
 
-int
-tsk_tree_preorder_from(
-    const tsk_tree_t *self, tsk_id_t root, tsk_id_t *nodes, tsk_size_t *num_nodes_ret)
+static int
+kc_vectors_alloc(kc_vectors *self, tsk_id_t n)
 {
     int ret = 0;
-    const tsk_id_t *restrict right_child = self->right_child;
-    const tsk_id_t *restrict left_sib = self->left_sib;
-    tsk_id_t *stack = tsk_tree_alloc_node_stack(self);
-    tsk_size_t num_nodes = 0;
-    tsk_id_t u, v;
-    int stack_top;
 
-    if (stack == NULL) {
+    self->n = n;
+    self->N = (n * (n - 1)) / 2;
+    self->m = tsk_calloc((size_t)(self->N + self->n), sizeof(*self->m));
+    self->M = tsk_calloc((size_t)(self->N + self->n), sizeof(*self->M));
+    if (self->m == NULL || self->M == NULL) {
         ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
 
-    if ((root == -1 || root == self->virtual_root)
-        && !tsk_tree_has_sample_counts(self)) {
-        ret = TSK_ERR_UNSUPPORTED_OPERATION;
-        goto out;
-    }
-    if (root == -1) {
-        stack_top = -1;
-        for (u = right_child[self->virtual_root]; u != TSK_NULL; u = left_sib[u]) {
-            stack_top++;
-            stack[stack_top] = u;
-        }
-    } else {
-        ret = tsk_tree_check_node(self, root);
-        if (ret != 0) {
-            goto out;
-        }
-        stack_top = 0;
-        stack[stack_top] = root;
-    }
-
-    while (stack_top >= 0) {
-        u = stack[stack_top];
-        stack_top--;
-        nodes[num_nodes] = u;
-        num_nodes++;
-        for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
-            stack_top++;
-            stack[stack_top] = v;
-        }
-    }
-    *num_nodes_ret = num_nodes;
 out:
-    tsk_safe_free(stack);
     return ret;
 }
 
-/* We could implement this using the preorder function, but since it's
- * going to be performance critical we want to avoid the overhead
- * of mallocing the intermediate node list (which will be bigger than
- * the number of samples). */
-int
-tsk_tree_preorder_samples_from(
-    const tsk_tree_t *self, tsk_id_t root, tsk_id_t *nodes, tsk_size_t *num_nodes_ret)
+static void
+kc_vectors_free(kc_vectors *self)
 {
-    int ret = 0;
-    const tsk_id_t *restrict right_child = self->right_child;
-    const tsk_id_t *restrict left_sib = self->left_sib;
-    const tsk_flags_t *restrict flags = self->tree_sequence->tables->nodes.flags;
-    tsk_id_t *stack = tsk_tree_alloc_node_stack(self);
-    tsk_size_t num_nodes = 0;
-    tsk_id_t u, v;
-    int stack_top;
+    tsk_safe_free(self->m);
+    tsk_safe_free(self->M);
+}
 
-    if (stack == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
-    }
+static inline void
+update_kc_vectors_single_sample(
+    const tsk_treeseq_t *ts, kc_vectors *kc_vecs, tsk_id_t u, double time)
+{
+    const tsk_id_t *sample_index_map = ts->sample_index_map;
+    tsk_id_t u_index = sample_index_map[u];
 
-    /* We could push the virtual_root onto the stack directly to simplify
-     * the code a little, but then we'd have to check put an extra check
-     * when looking up the flags array (which isn't defined for virtual_root).
-     */
-    if (root == -1 || root == self->virtual_root) {
-        if (!tsk_tree_has_sample_counts(self)) {
-            ret = TSK_ERR_UNSUPPORTED_OPERATION;
-            goto out;
-        }
-        stack_top = -1;
-        for (u = right_child[self->virtual_root]; u != TSK_NULL; u = left_sib[u]) {
-            stack_top++;
-            stack[stack_top] = u;
-        }
-    } else {
-        ret = tsk_tree_check_node(self, root);
-        if (ret != 0) {
-            goto out;
-        }
-        stack_top = 0;
-        stack[stack_top] = root;
-    }
+    kc_vecs->m[kc_vecs->N + u_index] = 1;
+    kc_vecs->M[kc_vecs->N + u_index] = time;
+}
 
-    while (stack_top >= 0) {
-        u = stack[stack_top];
-        stack_top--;
-        if (flags[u] & TSK_NODE_IS_SAMPLE) {
-            nodes[num_nodes] = u;
-            num_nodes++;
+static inline void
+update_kc_vectors_all_pairs(const tsk_tree_t *tree, kc_vectors *kc_vecs, tsk_id_t u,
+    tsk_id_t v, tsk_size_t depth, double time)
+{
+    tsk_id_t sample1_index, sample2_index, n1, n2, tmp, pair_index;
+    const tsk_id_t *restrict left_sample = tree->left_sample;
+    const tsk_id_t *restrict right_sample = tree->right_sample;
+    const tsk_id_t *restrict next_sample = tree->next_sample;
+    tsk_size_t *restrict kc_m = kc_vecs->m;
+    double *restrict kc_M = kc_vecs->M;
+
+    sample1_index = left_sample[u];
+    while (sample1_index != TSK_NULL) {
+        sample2_index = left_sample[v];
+        while (sample2_index != TSK_NULL) {
+            n1 = sample1_index;
+            n2 = sample2_index;
+            if (n1 > n2) {
+                tmp = n1;
+                n1 = n2;
+                n2 = tmp;
+            }
+
+            /* We spend ~40% of our time here because these accesses
+             * are not in order and gets very poor cache behavior */
+            pair_index = n2 - n1 - 1 + (-1 * n1 * (n1 - 2 * kc_vecs->n + 1)) / 2;
+            kc_m[pair_index] = depth;
+            kc_M[pair_index] = time;
+
+            if (sample2_index == right_sample[v]) {
+                break;
+            }
+            sample2_index = next_sample[sample2_index];
         }
-        for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
-            stack_top++;
-            stack[stack_top] = v;
+        if (sample1_index == right_sample[u]) {
+            break;
         }
+        sample1_index = next_sample[sample1_index];
     }
-    *num_nodes_ret = num_nodes;
-out:
-    tsk_safe_free(stack);
-    return ret;
 }
 
-int
-tsk_tree_postorder(const tsk_tree_t *self, tsk_id_t *nodes, tsk_size_t *num_nodes_ret)
-{
-    return tsk_tree_postorder_from(self, -1, nodes, num_nodes_ret);
-}
-int
-tsk_tree_postorder_from(
-    const tsk_tree_t *self, tsk_id_t root, tsk_id_t *nodes, tsk_size_t *num_nodes_ret)
+struct kc_stack_elmt {
+    tsk_id_t node;
+    tsk_size_t depth;
+};
+
+static int
+fill_kc_vectors(const tsk_tree_t *t, kc_vectors *kc_vecs)
 {
-    int ret = 0;
-    const tsk_id_t *restrict right_child = self->right_child;
-    const tsk_id_t *restrict left_sib = self->left_sib;
-    const tsk_id_t *restrict parent = self->parent;
-    tsk_id_t *stack = tsk_tree_alloc_node_stack(self);
-    tsk_size_t num_nodes = 0;
-    tsk_id_t u, v, postorder_parent;
     int stack_top;
-    bool is_virtual_root = root == self->virtual_root;
+    tsk_size_t depth;
+    double time;
+    const double *times;
+    struct kc_stack_elmt *stack;
+    tsk_id_t root, u, c1, c2;
+    int ret = 0;
+    const tsk_treeseq_t *ts = t->tree_sequence;
 
+    stack = tsk_malloc(tsk_tree_get_size_bound(t) * sizeof(*stack));
     if (stack == NULL) {
         ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
 
-    if (root == -1 || is_virtual_root) {
-        if (!tsk_tree_has_sample_counts(self)) {
-            ret = TSK_ERR_UNSUPPORTED_OPERATION;
-            goto out;
-        }
-        stack_top = -1;
-        for (u = right_child[self->virtual_root]; u != TSK_NULL; u = left_sib[u]) {
-            stack_top++;
-            stack[stack_top] = u;
-        }
-    } else {
-        ret = tsk_tree_check_node(self, root);
-        if (ret != 0) {
-            goto out;
-        }
+    times = t->tree_sequence->tables->nodes.time;
+
+    for (root = tsk_tree_get_left_root(t); root != TSK_NULL; root = t->right_sib[root]) {
         stack_top = 0;
-        stack[stack_top] = root;
-    }
+        stack[stack_top].node = root;
+        stack[stack_top].depth = 0;
+        while (stack_top >= 0) {
+            u = stack[stack_top].node;
+            depth = stack[stack_top].depth;
+            stack_top--;
 
-    postorder_parent = TSK_NULL;
-    while (stack_top >= 0) {
-        u = stack[stack_top];
-        if (right_child[u] != TSK_NULL && u != postorder_parent) {
-            for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
-                stack_top++;
-                stack[stack_top] = v;
+            if (tsk_tree_is_sample(t, u)) {
+                time = tsk_tree_get_branch_length_unsafe(t, u);
+                update_kc_vectors_single_sample(ts, kc_vecs, u, time);
+            }
+
+            /* Don't bother going deeper if there are no samples under this node */
+            if (t->left_sample[u] != TSK_NULL) {
+                for (c1 = t->left_child[u]; c1 != TSK_NULL; c1 = t->right_sib[c1]) {
+                    stack_top++;
+                    stack[stack_top].node = c1;
+                    stack[stack_top].depth = depth + 1;
+
+                    for (c2 = t->right_sib[c1]; c2 != TSK_NULL; c2 = t->right_sib[c2]) {
+                        time = times[root] - times[u];
+                        update_kc_vectors_all_pairs(t, kc_vecs, c1, c2, depth, time);
+                    }
+                }
             }
-        } else {
-            stack_top--;
-            postorder_parent = parent[u];
-            nodes[num_nodes] = u;
-            num_nodes++;
         }
     }
-    if (is_virtual_root) {
-        nodes[num_nodes] = root;
-        num_nodes++;
-    }
-    *num_nodes_ret = num_nodes;
+
 out:
     tsk_safe_free(stack);
     return ret;
 }
 
-/* Balance/imbalance metrics */
+static double
+norm_kc_vectors(kc_vectors *self, kc_vectors *other, double lambda)
+{
+    double vT1, vT2, distance_sum;
+    tsk_id_t i;
+
+    distance_sum = 0;
+    for (i = 0; i < self->n + self->N; i++) {
+        vT1 = ((double) self->m[i] * (1 - lambda)) + (lambda * self->M[i]);
+        vT2 = ((double) other->m[i] * (1 - lambda)) + (lambda * other->M[i]);
+        distance_sum += (vT1 - vT2) * (vT1 - vT2);
+    }
+
+    return sqrt(distance_sum);
+}
 
-/* Result is a tsk_size_t value here because we could imagine the total
- * depth overflowing a 32bit integer for a large tree. */
-int
-tsk_tree_sackin_index(const tsk_tree_t *self, tsk_size_t *result)
+static int
+check_kc_distance_tree_inputs(const tsk_tree_t *self)
 {
-    /* Keep the size of the stack elements to 8 bytes in total in the
-     * standard case. A tsk_id_t depth value is always safe, since
-     * depth counts the number of nodes encountered on a path.
-     */
-    struct stack_elem {
-        tsk_id_t node;
-        tsk_id_t depth;
-    };
+    tsk_id_t u, num_nodes, left_child;
     int ret = 0;
-    const tsk_id_t *restrict right_child = self->right_child;
-    const tsk_id_t *restrict left_sib = self->left_sib;
-    struct stack_elem *stack
-        = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*stack));
-    int stack_top;
-    tsk_size_t total_depth;
-    tsk_id_t u;
-    struct stack_elem s = { .node = TSK_NULL, .depth = 0 };
 
-    if (stack == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
+    if (tsk_tree_get_num_roots(self) != 1) {
+        ret = TSK_ERR_MULTIPLE_ROOTS;
         goto out;
     }
-
-    stack_top = -1;
-    for (u = right_child[self->virtual_root]; u != TSK_NULL; u = left_sib[u]) {
-        stack_top++;
-        s.node = u;
-        stack[stack_top] = s;
+    if (!tsk_tree_has_sample_lists(self)) {
+        ret = TSK_ERR_NO_SAMPLE_LISTS;
+        goto out;
     }
-    total_depth = 0;
-    while (stack_top >= 0) {
-        s = stack[stack_top];
-        stack_top--;
-        u = right_child[s.node];
-        if (u == TSK_NULL) {
-            total_depth += (tsk_size_t) s.depth;
-        } else {
-            s.depth++;
-            while (u != TSK_NULL) {
-                stack_top++;
-                s.node = u;
-                stack[stack_top] = s;
-                u = left_sib[u];
-            }
+
+    num_nodes = (tsk_id_t) tsk_treeseq_get_num_nodes(self->tree_sequence);
+    for (u = 0; u < num_nodes; u++) {
+        left_child = self->left_child[u];
+        if (left_child != TSK_NULL && left_child == self->right_child[u]) {
+            ret = TSK_ERR_UNARY_NODES;
+            goto out;
         }
     }
-    *result = total_depth;
 out:
-    tsk_safe_free(stack);
     return ret;
 }
 
-int
-tsk_tree_colless_index(const tsk_tree_t *self, tsk_size_t *result)
+static int
+check_kc_distance_samples_inputs(const tsk_treeseq_t *self, const tsk_treeseq_t *other)
 {
+    const tsk_id_t *samples, *other_samples;
+    tsk_id_t i, n;
     int ret = 0;
-    const tsk_id_t *restrict right_child = self->right_child;
-    const tsk_id_t *restrict left_sib = self->left_sib;
-    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
-    tsk_id_t *num_leaves = tsk_calloc(self->num_nodes, sizeof(*num_leaves));
-    tsk_size_t j, num_nodes, total;
-    tsk_id_t num_children, u, v;
 
-    if (nodes == NULL || num_leaves == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
-    }
-    if (tsk_tree_get_num_roots(self) != 1) {
-        ret = TSK_ERR_UNDEFINED_MULTIROOT;
-        goto out;
-    }
-    ret = tsk_tree_postorder(self, nodes, &num_nodes);
-    if (ret != 0) {
+    if (self->num_samples != other->num_samples) {
+        ret = TSK_ERR_SAMPLE_SIZE_MISMATCH;
         goto out;
     }
 
-    total = 0;
-    for (j = 0; j < num_nodes; j++) {
-        u = nodes[j];
-        /* Cheaper to compute this on the fly than to access the num_children array.
-         * since we're already iterating over the children. */
-        num_children = 0;
-        for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
-            num_children++;
-            num_leaves[u] += num_leaves[v];
-        }
-        if (num_children == 0) {
-            num_leaves[u] = 1;
-        } else if (num_children == 2) {
-            v = right_child[u];
-            total += (tsk_size_t) llabs(num_leaves[v] - num_leaves[left_sib[v]]);
-        } else {
-            ret = TSK_ERR_UNDEFINED_NONBINARY;
+    samples = self->samples;
+    other_samples = other->samples;
+    n = (tsk_id_t) self->num_samples;
+    for (i = 0; i < n; i++) {
+        if (samples[i] != other_samples[i]) {
+            ret = TSK_ERR_SAMPLES_NOT_EQUAL;
             goto out;
         }
     }
-    *result = total;
 out:
-    tsk_safe_free(nodes);
-    tsk_safe_free(num_leaves);
     return ret;
 }
 
 int
-tsk_tree_b1_index(const tsk_tree_t *self, double *result)
+tsk_tree_kc_distance(
+    const tsk_tree_t *self, const tsk_tree_t *other, double lambda, double *result)
 {
+    tsk_id_t n, i;
+    kc_vectors vecs[2];
+    const tsk_tree_t *trees[2] = { self, other };
     int ret = 0;
-    const tsk_id_t *restrict parent = self->parent;
-    const tsk_id_t *restrict right_child = self->right_child;
-    const tsk_id_t *restrict left_sib = self->left_sib;
-    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
-    tsk_size_t *max_path_length = tsk_calloc(self->num_nodes, sizeof(*max_path_length));
-    tsk_size_t j, num_nodes, mpl;
-    double total = 0.0;
-    tsk_id_t u, v;
 
-    if (nodes == NULL || max_path_length == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
+    for (i = 0; i < 2; i++) {
+        tsk_memset(&vecs[i], 0, sizeof(kc_vectors));
     }
-    ret = tsk_tree_postorder(self, nodes, &num_nodes);
+
+    ret = check_kc_distance_samples_inputs(self->tree_sequence, other->tree_sequence);
     if (ret != 0) {
         goto out;
     }
+    for (i = 0; i < 2; i++) {
+        ret = check_kc_distance_tree_inputs(trees[i]);
+        if (ret != 0) {
+            goto out;
+        }
+    }
 
-    for (j = 0; j < num_nodes; j++) {
-        u = nodes[j];
-        if (parent[u] != TSK_NULL && right_child[u] != TSK_NULL) {
-            mpl = 0;
-            for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
-                mpl = TSK_MAX(mpl, max_path_length[v]);
-            }
-            max_path_length[u] = mpl + 1;
-            total += 1 / (double) max_path_length[u];
+    n = (tsk_id_t) self->tree_sequence->num_samples;
+    for (i = 0; i < 2; i++) {
+        ret = kc_vectors_alloc(&vecs[i], n);
+        if (ret != 0) {
+            goto out;
+        }
+        ret = fill_kc_vectors(trees[i], &vecs[i]);
+        if (ret != 0) {
+            goto out;
         }
     }
-    *result = total;
+
+    *result = norm_kc_vectors(&vecs[0], &vecs[1], lambda);
 out:
-    tsk_safe_free(nodes);
-    tsk_safe_free(max_path_length);
+    for (i = 0; i < 2; i++) {
+        kc_vectors_free(&vecs[i]);
+    }
     return ret;
 }
 
-static double
-general_log(double x, double base)
-{
-    return log(x) / log(base);
-}
-
-int
-tsk_tree_b2_index(const tsk_tree_t *self, double base, double *result)
+static int
+check_kc_distance_tree_sequence_inputs(
+    const tsk_treeseq_t *self, const tsk_treeseq_t *other)
 {
-    struct stack_elem {
-        tsk_id_t node;
-        double path_product;
-    };
     int ret = 0;
-    const tsk_id_t *restrict right_child = self->right_child;
-    const tsk_id_t *restrict left_sib = self->left_sib;
-    struct stack_elem *stack
-        = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*stack));
-    int stack_top;
-    double total_proba = 0;
-    double num_children;
-    tsk_id_t u;
-    struct stack_elem s = { .node = TSK_NULL, .path_product = 1 };
 
-    if (stack == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
+    if (self->tables->sequence_length != other->tables->sequence_length) {
+        ret = TSK_ERR_SEQUENCE_LENGTH_MISMATCH;
         goto out;
     }
-    if (tsk_tree_get_num_roots(self) != 1) {
-        ret = TSK_ERR_UNDEFINED_MULTIROOT;
+
+    ret = check_kc_distance_samples_inputs(self, other);
+    if (ret != 0) {
         goto out;
     }
 
-    stack_top = 0;
-    s.node = tsk_tree_get_left_root(self);
-    stack[stack_top] = s;
-
-    while (stack_top >= 0) {
-        s = stack[stack_top];
-        stack_top--;
-        u = right_child[s.node];
-        if (u == TSK_NULL) {
-            total_proba -= s.path_product * general_log(s.path_product, base);
-        } else {
-            num_children = 0;
-            for (; u != TSK_NULL; u = left_sib[u]) {
-                num_children++;
-            }
-            s.path_product *= 1 / num_children;
-            for (u = right_child[s.node]; u != TSK_NULL; u = left_sib[u]) {
-                stack_top++;
-                s.node = u;
-                stack[stack_top] = s;
-            }
-        }
-    }
-    *result = total_proba;
 out:
-    tsk_safe_free(stack);
     return ret;
 }
 
-int
-tsk_tree_num_lineages(const tsk_tree_t *self, double t, tsk_size_t *result)
+static void
+update_kc_pair_with_sample(const tsk_tree_t *self, kc_vectors *kc, tsk_id_t sample,
+    tsk_size_t *depths, double root_time)
+{
+    tsk_id_t c, p, sib;
+    double time;
+    tsk_size_t depth;
+    double *times = self->tree_sequence->tables->nodes.time;
+
+    c = sample;
+    for (p = self->parent[sample]; p != TSK_NULL; p = self->parent[p]) {
+        time = root_time - times[p];
+        depth = depths[p];
+        for (sib = self->left_child[p]; sib != TSK_NULL; sib = self->right_sib[sib]) {
+            if (sib != c) {
+                update_kc_vectors_all_pairs(self, kc, sample, sib, depth, time);
+            }
+        }
+        c = p;
+    }
+}
+
+static int
+update_kc_subtree_state(
+    tsk_tree_t *t, kc_vectors *kc, tsk_id_t u, tsk_size_t *depths, double root_time)
 {
-    int ret = 0;
-    const tsk_id_t *restrict right_child = self->right_child;
-    const tsk_id_t *restrict left_sib = self->left_sib;
-    const double *restrict time = self->tree_sequence->tables->nodes.time;
-    tsk_id_t *stack = tsk_tree_alloc_node_stack(self);
-    tsk_size_t num_lineages = 0;
     int stack_top;
-    tsk_id_t u, v;
-    double child_time, parent_time;
+    tsk_id_t v, c;
+    tsk_id_t *stack = NULL;
+    int ret = 0;
 
+    stack = tsk_malloc(tsk_tree_get_size_bound(t) * sizeof(*stack));
     if (stack == NULL) {
         ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
-    if (!tsk_isfinite(t)) {
-        ret = TSK_ERR_TIME_NONFINITE;
-        goto out;
-    }
-    /* Push the roots onto the stack */
-    stack_top = -1;
-    for (u = right_child[self->virtual_root]; u != TSK_NULL; u = left_sib[u]) {
-        stack_top++;
-        stack[stack_top] = u;
-    }
 
+    stack_top = 0;
+    stack[stack_top] = u;
     while (stack_top >= 0) {
-        u = stack[stack_top];
-        parent_time = time[u];
+        v = stack[stack_top];
         stack_top--;
-        for (v = right_child[u]; v != TSK_NULL; v = left_sib[v]) {
-            child_time = time[v];
-            /* Only traverse down the tree as far as we need to */
-            if (child_time > t) {
+
+        if (tsk_tree_is_sample(t, v)) {
+            update_kc_pair_with_sample(t, kc, v, depths, root_time);
+        }
+        for (c = t->left_child[v]; c != TSK_NULL; c = t->right_sib[c]) {
+            if (depths[c] != 0) {
+                depths[c] = depths[v] + 1;
                 stack_top++;
-                stack[stack_top] = v;
-            } else if (t < parent_time) {
-                num_lineages++;
+                stack[stack_top] = c;
             }
         }
     }
-    *result = num_lineages;
+
 out:
     tsk_safe_free(stack);
     return ret;
 }
 
-/* Parsimony methods */
-
-static inline uint64_t
-set_bit(uint64_t value, int32_t bit)
+static int
+update_kc_incremental(
+    tsk_tree_t *tree, kc_vectors *kc, tsk_tree_position_t *tree_pos, tsk_size_t *depths)
 {
-    return value | (1ULL << bit);
-}
+    int ret = 0;
+    tsk_id_t u, v, e, j;
+    double root_time, time;
+    const double *restrict times = tree->tree_sequence->tables->nodes.time;
+    const tsk_id_t *restrict edges_child = tree->tree_sequence->tables->edges.child;
+    const tsk_id_t *restrict edges_parent = tree->tree_sequence->tables->edges.parent;
 
-static inline bool
-bit_is_set(uint64_t value, int32_t bit)
-{
-    return (value & (1ULL << bit)) != 0;
-}
+    tsk_bug_assert(tree_pos->index == tree->index);
+    tsk_bug_assert(tree_pos->interval.left == tree->interval.left);
+    tsk_bug_assert(tree_pos->interval.right == tree->interval.right);
 
-static inline int8_t
-get_smallest_set_bit(uint64_t v)
-{
-    /* This is an inefficient implementation, there are several better
-     * approaches. On GCC we can use
-     * return (uint8_t) (__builtin_ffsll((long long) v) - 1);
-     */
-    uint64_t t = 1;
-    int8_t r = 0;
+    /* Update state of detached subtrees */
+    for (j = tree_pos->out.stop - 1; j >= tree_pos->out.start; j--) {
+        e = tree_pos->out.order[j];
+        u = edges_child[e];
+        depths[u] = 0;
 
-    assert(v != 0);
-    while ((v & t) == 0) {
-        t <<= 1;
-        r++;
+        if (tree->parent[u] == TSK_NULL) {
+            root_time = times[tsk_tree_node_root(tree, u)];
+            ret = update_kc_subtree_state(tree, kc, u, depths, root_time);
+            if (ret != 0) {
+                goto out;
+            }
+        }
     }
-    return r;
-}
 
-#define HARTIGAN_MAX_ALLELES 64
+    /* Propagate state change down into reattached subtrees. */
+    for (j = tree_pos->in.stop - 1; j >= tree_pos->in.start; j--) {
+        e = tree_pos->in.order[j];
+        u = edges_child[e];
+        v = edges_parent[e];
 
-/* This interface is experimental. In the future, we should provide the option to
- * use a general cost matrix, in which case we'll use the Sankoff algorithm. For
- * now this is unused.
- *
- * We should also vectorise the function so that several sites can be processed
- * at once.
- *
- * The algorithm used here is Hartigan parsimony, "Minimum Mutation Fits to a
- * Given Tree", Biometrics 1973.
- */
-int TSK_WARN_UNUSED
-tsk_tree_map_mutations(tsk_tree_t *self, int32_t *genotypes,
-    double *TSK_UNUSED(cost_matrix), tsk_flags_t options, int32_t *r_ancestral_state,
-    tsk_size_t *r_num_transitions, tsk_state_transition_t **r_transitions)
-{
-    int ret = 0;
-    struct stack_elem {
-        tsk_id_t node;
-        tsk_id_t transition_parent;
-        int32_t state;
-    };
-    const tsk_size_t num_samples = self->tree_sequence->num_samples;
-    const tsk_id_t *restrict left_child = self->left_child;
-    const tsk_id_t *restrict right_sib = self->right_sib;
-    const tsk_size_t N = tsk_treeseq_get_num_nodes(self->tree_sequence);
-    const tsk_flags_t *restrict node_flags = self->tree_sequence->tables->nodes.flags;
-    tsk_id_t *nodes = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*nodes));
-    /* Note: to use less memory here and to improve cache performance we should
-     * probably change to allocating exactly the number of nodes returned by
-     * a preorder traversal, and then lay the memory out in this order. So, we'd
-     * need a map from node ID to its index in the preorder traversal, but this
-     * is trivial to compute. Probably doesn't matter so much at the moment
-     * when we're doing a single site, but it would make a big difference if
-     * we were vectorising over lots of sites. */
-    uint64_t *restrict optimal_set = tsk_calloc(N + 1, sizeof(*optimal_set));
-    struct stack_elem *restrict preorder_stack
-        = tsk_malloc(tsk_tree_get_size_bound(self) * sizeof(*preorder_stack));
-    tsk_id_t u, v;
-    /* The largest possible number of transitions is one over every sample */
-    tsk_state_transition_t *transitions = tsk_malloc(num_samples * sizeof(*transitions));
-    int32_t allele, ancestral_state;
-    int stack_top;
-    struct stack_elem s;
-    tsk_size_t j, num_transitions, max_allele_count, num_nodes;
-    tsk_size_t allele_count[HARTIGAN_MAX_ALLELES];
-    tsk_size_t non_missing = 0;
-    int32_t num_alleles = 0;
+        tsk_bug_assert(depths[u] == 0);
+        depths[u] = depths[v] + 1;
 
-    if (optimal_set == NULL || preorder_stack == NULL || transitions == NULL
-        || nodes == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
-    }
-    for (j = 0; j < num_samples; j++) {
-        if (genotypes[j] >= HARTIGAN_MAX_ALLELES || genotypes[j] < TSK_MISSING_DATA) {
-            ret = TSK_ERR_BAD_GENOTYPE;
+        root_time = times[tsk_tree_node_root(tree, u)];
+        ret = update_kc_subtree_state(tree, kc, u, depths, root_time);
+        if (ret != 0) {
             goto out;
         }
-        u = self->tree_sequence->samples[j];
-        if (genotypes[j] == TSK_MISSING_DATA) {
-            /* All bits set */
-            optimal_set[u] = UINT64_MAX;
-        } else {
-            optimal_set[u] = set_bit(optimal_set[u], genotypes[j]);
-            num_alleles = TSK_MAX(genotypes[j], num_alleles);
-            non_missing++;
+
+        if (tsk_tree_is_sample(tree, u)) {
+            time = tsk_tree_get_branch_length_unsafe(tree, u);
+            update_kc_vectors_single_sample(tree->tree_sequence, kc, u, time);
         }
     }
+out:
+    return ret;
+}
 
-    if (non_missing == 0) {
-        ret = TSK_ERR_GENOTYPES_ALL_MISSING;
-        goto out;
-    }
-    num_alleles++;
+int
+tsk_treeseq_kc_distance(const tsk_treeseq_t *self, const tsk_treeseq_t *other,
+    double lambda_, double *result)
+{
+    int i;
+    tsk_id_t n;
+    tsk_size_t num_nodes;
+    double left, span, total;
+    const tsk_treeseq_t *treeseqs[2] = { self, other };
+    tsk_tree_t trees[2];
+    kc_vectors kcs[2];
+    /* TODO the tree_pos here is redundant because we should be using this interally
+     * in the trees to do the advancing. Once we have converted the tree over to using
+     * tree_pos internally, we can get rid of these tree_pos variables and use
+     * the values stored in the trees themselves */
+    tsk_tree_position_t tree_pos[2];
+    tsk_size_t *depths[2];
+    int ret = 0;
 
-    ancestral_state = 0; /* keep compiler happy */
-    if (options & TSK_MM_FIXED_ANCESTRAL_STATE) {
-        ancestral_state = *r_ancestral_state;
-        if ((ancestral_state < 0) || (ancestral_state >= HARTIGAN_MAX_ALLELES)) {
-            ret = TSK_ERR_BAD_ANCESTRAL_STATE;
-            goto out;
-        } else if (ancestral_state >= num_alleles) {
-            num_alleles = (int32_t)(ancestral_state + 1);
-        }
+    for (i = 0; i < 2; i++) {
+        tsk_memset(&trees[i], 0, sizeof(trees[i]));
+        tsk_memset(&tree_pos[i], 0, sizeof(tree_pos[i]));
+        tsk_memset(&kcs[i], 0, sizeof(kcs[i]));
+        depths[i] = NULL;
     }
 
-    ret = tsk_tree_postorder_from(self, self->virtual_root, nodes, &num_nodes);
+    ret = check_kc_distance_tree_sequence_inputs(self, other);
     if (ret != 0) {
         goto out;
     }
-    for (j = 0; j < num_nodes; j++) {
-        u = nodes[j];
-        tsk_memset(allele_count, 0, ((size_t) num_alleles) * sizeof(*allele_count));
-        for (v = left_child[u]; v != TSK_NULL; v = right_sib[v]) {
-            for (allele = 0; allele < num_alleles; allele++) {
-                allele_count[allele] += bit_is_set(optimal_set[v], allele);
-            }
+
+    n = (tsk_id_t) self->num_samples;
+    for (i = 0; i < 2; i++) {
+        ret = tsk_tree_init(&trees[i], treeseqs[i], TSK_SAMPLE_LISTS);
+        if (ret != 0) {
+            goto out;
         }
-        /* the virtual root has no flags defined */
-        if (u == (tsk_id_t) N || !(node_flags[u] & TSK_NODE_IS_SAMPLE)) {
-            max_allele_count = 0;
-            for (allele = 0; allele < num_alleles; allele++) {
-                max_allele_count = TSK_MAX(max_allele_count, allele_count[allele]);
-            }
-            for (allele = 0; allele < num_alleles; allele++) {
-                if (allele_count[allele] == max_allele_count) {
-                    optimal_set[u] = set_bit(optimal_set[u], allele);
-                }
-            }
+        ret = tsk_tree_position_init(&tree_pos[i], treeseqs[i], 0);
+        if (ret != 0) {
+            goto out;
+        }
+        ret = kc_vectors_alloc(&kcs[i], n);
+        if (ret != 0) {
+            goto out;
+        }
+        num_nodes = tsk_treeseq_get_num_nodes(treeseqs[i]);
+        depths[i] = tsk_calloc(num_nodes, sizeof(*depths[i]));
+        if (depths[i] == NULL) {
+            ret = TSK_ERR_NO_MEMORY;
+            goto out;
         }
-    }
-    if (!(options & TSK_MM_FIXED_ANCESTRAL_STATE)) {
-        ancestral_state = get_smallest_set_bit(optimal_set[self->virtual_root]);
-    } else {
-        optimal_set[self->virtual_root] = UINT64_MAX;
     }
 
-    num_transitions = 0;
+    total = 0;
+    left = 0;
 
-    /* Do a preorder traversal */
-    preorder_stack[0].node = self->virtual_root;
-    preorder_stack[0].state = ancestral_state;
-    preorder_stack[0].transition_parent = TSK_NULL;
-    stack_top = 0;
-    while (stack_top >= 0) {
-        s = preorder_stack[stack_top];
-        stack_top--;
+    ret = tsk_tree_first(&trees[0]);
+    if (ret != TSK_TREE_OK) {
+        goto out;
+    }
+    ret = check_kc_distance_tree_inputs(&trees[0]);
+    if (ret != 0) {
+        goto out;
+    }
+    tsk_tree_position_next(&tree_pos[0]);
+    tsk_bug_assert(tree_pos[0].index == 0);
 
-        if (!bit_is_set(optimal_set[s.node], s.state)) {
-            s.state = get_smallest_set_bit(optimal_set[s.node]);
-            transitions[num_transitions].node = s.node;
-            transitions[num_transitions].parent = s.transition_parent;
-            transitions[num_transitions].state = s.state;
-            s.transition_parent = (tsk_id_t) num_transitions;
-            num_transitions++;
+    ret = update_kc_incremental(&trees[0], &kcs[0], &tree_pos[0], depths[0]);
+    if (ret != 0) {
+        goto out;
+    }
+    while ((ret = tsk_tree_next(&trees[1])) == TSK_TREE_OK) {
+        ret = check_kc_distance_tree_inputs(&trees[1]);
+        if (ret != 0) {
+            goto out;
+        }
+        tsk_tree_position_next(&tree_pos[1]);
+        tsk_bug_assert(tree_pos[1].index != -1);
+
+        ret = update_kc_incremental(&trees[1], &kcs[1], &tree_pos[1], depths[1]);
+        if (ret != 0) {
+            goto out;
         }
-        for (v = left_child[s.node]; v != TSK_NULL; v = right_sib[v]) {
-            stack_top++;
-            s.node = v;
-            preorder_stack[stack_top] = s;
+        tsk_bug_assert(trees[0].interval.left == tree_pos[0].interval.left);
+        tsk_bug_assert(trees[0].interval.right == tree_pos[0].interval.right);
+        tsk_bug_assert(trees[1].interval.left == tree_pos[1].interval.left);
+        tsk_bug_assert(trees[1].interval.right == tree_pos[1].interval.right);
+        while (trees[0].interval.right < trees[1].interval.right) {
+            span = trees[0].interval.right - left;
+            total += norm_kc_vectors(&kcs[0], &kcs[1], lambda_) * span;
+
+            left = trees[0].interval.right;
+            ret = tsk_tree_next(&trees[0]);
+            tsk_bug_assert(ret == TSK_TREE_OK);
+            ret = check_kc_distance_tree_inputs(&trees[0]);
+            if (ret != 0) {
+                goto out;
+            }
+            tsk_tree_position_next(&tree_pos[0]);
+            tsk_bug_assert(tree_pos[0].index != -1);
+            ret = update_kc_incremental(&trees[0], &kcs[0], &tree_pos[0], depths[0]);
+            if (ret != 0) {
+                goto out;
+            }
         }
+        span = trees[1].interval.right - left;
+        left = trees[1].interval.right;
+        total += norm_kc_vectors(&kcs[0], &kcs[1], lambda_) * span;
+    }
+    if (ret != 0) {
+        goto out;
     }
 
-    *r_transitions = transitions;
-    *r_num_transitions = num_transitions;
-    *r_ancestral_state = ancestral_state;
-    transitions = NULL;
+    *result = total / self->tables->sequence_length;
 out:
-    tsk_safe_free(transitions);
-    /* Cannot safe_free because of 'restrict' */
-    if (optimal_set != NULL) {
-        free(optimal_set);
-    }
-    if (preorder_stack != NULL) {
-        free(preorder_stack);
-    }
-    if (nodes != NULL) {
-        free(nodes);
+    for (i = 0; i < 2; i++) {
+        tsk_tree_free(&trees[i]);
+        tsk_tree_position_free(&tree_pos[i]);
+        kc_vectors_free(&kcs[i]);
+        tsk_safe_free(depths[i]);
     }
     return ret;
 }
 
-/* Compatibility shim for initialising the diff iterator from a tree sequence. We are
- * using this function in a small number of places internally, so simplest to keep it
- * until a more satisfactory "diff" API comes along.
+/*
+ * Divergence matrix
  */
-int TSK_WARN_UNUSED
-tsk_diff_iter_init_from_ts(
-    tsk_diff_iter_t *self, const tsk_treeseq_t *tree_sequence, tsk_flags_t options)
-{
-    return tsk_diff_iter_init(
-        self, tree_sequence->tables, (tsk_id_t) tree_sequence->num_trees, options);
-}
-
-/* ======================================================== *
- * KC Distance
- * ======================================================== */
 
 typedef struct {
-    tsk_size_t *m;
-    double *M;
-    tsk_id_t n;
-    tsk_id_t N;
-} kc_vectors;
+    /* Note it's a waste storing the triply linked tree here, but the code
+     * is written on the assumption of 1-based trees and the algorithm is
+     * frighteningly subtle, so it doesn't seem worth messing with it
+     * unless we really need to save some memory */
+    tsk_id_t *parent;
+    tsk_id_t *child;
+    tsk_id_t *sib;
+    tsk_id_t *lambda;
+    tsk_id_t *pi;
+    tsk_id_t *tau;
+    tsk_id_t *beta;
+    tsk_id_t *alpha;
+} sv_tables_t;
 
 static int
-kc_vectors_alloc(kc_vectors *self, tsk_id_t n)
+sv_tables_init(sv_tables_t *self, tsk_size_t n)
 {
     int ret = 0;
 
-    self->n = n;
-    self->N = (n * (n - 1)) / 2;
-    self->m = tsk_calloc((size_t)(self->N + self->n), sizeof(*self->m));
-    self->M = tsk_calloc((size_t)(self->N + self->n), sizeof(*self->M));
-    if (self->m == NULL || self->M == NULL) {
+    self->parent = tsk_malloc(n * sizeof(*self->parent));
+    self->child = tsk_malloc(n * sizeof(*self->child));
+    self->sib = tsk_malloc(n * sizeof(*self->sib));
+    self->pi = tsk_malloc(n * sizeof(*self->pi));
+    self->lambda = tsk_malloc(n * sizeof(*self->lambda));
+    self->tau = tsk_malloc(n * sizeof(*self->tau));
+    self->beta = tsk_malloc(n * sizeof(*self->beta));
+    self->alpha = tsk_malloc(n * sizeof(*self->alpha));
+    if (self->parent == NULL || self->child == NULL || self->sib == NULL
+        || self->lambda == NULL || self->tau == NULL || self->beta == NULL
+        || self->alpha == NULL) {
         ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
-
 out:
     return ret;
 }
 
-static void
-kc_vectors_free(kc_vectors *self)
+static int
+sv_tables_free(sv_tables_t *self)
 {
-    tsk_safe_free(self->m);
-    tsk_safe_free(self->M);
+    tsk_safe_free(self->parent);
+    tsk_safe_free(self->child);
+    tsk_safe_free(self->sib);
+    tsk_safe_free(self->lambda);
+    tsk_safe_free(self->pi);
+    tsk_safe_free(self->tau);
+    tsk_safe_free(self->beta);
+    tsk_safe_free(self->alpha);
+    return 0;
 }
-
-static inline void
-update_kc_vectors_single_sample(
-    const tsk_treeseq_t *ts, kc_vectors *kc_vecs, tsk_id_t u, double time)
+static void
+sv_tables_reset(sv_tables_t *self, tsk_tree_t *tree)
 {
-    const tsk_id_t *sample_index_map = ts->sample_index_map;
-    tsk_id_t u_index = sample_index_map[u];
-
-    kc_vecs->m[kc_vecs->N + u_index] = 1;
-    kc_vecs->M[kc_vecs->N + u_index] = time;
+    const tsk_size_t n = 1 + tree->num_nodes;
+    tsk_memset(self->parent, 0, n * sizeof(*self->parent));
+    tsk_memset(self->child, 0, n * sizeof(*self->child));
+    tsk_memset(self->sib, 0, n * sizeof(*self->sib));
+    tsk_memset(self->pi, 0, n * sizeof(*self->pi));
+    tsk_memset(self->lambda, 0, n * sizeof(*self->lambda));
+    tsk_memset(self->tau, 0, n * sizeof(*self->tau));
+    tsk_memset(self->beta, 0, n * sizeof(*self->beta));
+    tsk_memset(self->alpha, 0, n * sizeof(*self->alpha));
 }
 
-static inline void
-update_kc_vectors_all_pairs(const tsk_tree_t *tree, kc_vectors *kc_vecs, tsk_id_t u,
-    tsk_id_t v, tsk_size_t depth, double time)
+static void
+sv_tables_convert_tree(sv_tables_t *self, tsk_tree_t *tree)
 {
-    tsk_id_t sample1_index, sample2_index, n1, n2, tmp, pair_index;
-    const tsk_id_t *restrict left_sample = tree->left_sample;
-    const tsk_id_t *restrict right_sample = tree->right_sample;
-    const tsk_id_t *restrict next_sample = tree->next_sample;
-    tsk_size_t *restrict kc_m = kc_vecs->m;
-    double *restrict kc_M = kc_vecs->M;
+    const tsk_size_t n = 1 + tree->num_nodes;
+    const tsk_id_t *restrict tsk_parent = tree->parent;
+    tsk_id_t *restrict child = self->child;
+    tsk_id_t *restrict parent = self->parent;
+    tsk_id_t *restrict sib = self->sib;
+    tsk_size_t j;
+    tsk_id_t u, v;
 
-    sample1_index = left_sample[u];
-    while (sample1_index != TSK_NULL) {
-        sample2_index = left_sample[v];
-        while (sample2_index != TSK_NULL) {
-            n1 = sample1_index;
-            n2 = sample2_index;
-            if (n1 > n2) {
-                tmp = n1;
-                n1 = n2;
-                n2 = tmp;
-            }
+    for (j = 0; j < n - 1; j++) {
+        u = (tsk_id_t) j + 1;
+        v = tsk_parent[j] + 1;
+        sib[u] = child[v];
+        child[v] = u;
+        parent[u] = v;
+    }
+}
 
-            /* We spend ~40% of our time here because these accesses
-             * are not in order and gets very poor cache behavior */
-            pair_index = n2 - n1 - 1 + (-1 * n1 * (n1 - 2 * kc_vecs->n + 1)) / 2;
-            kc_m[pair_index] = depth;
-            kc_M[pair_index] = time;
+#define LAMBDA 0
 
-            if (sample2_index == right_sample[v]) {
+static void
+sv_tables_build_index(sv_tables_t *self)
+{
+    const tsk_id_t *restrict child = self->child;
+    const tsk_id_t *restrict parent = self->parent;
+    const tsk_id_t *restrict sib = self->sib;
+    tsk_id_t *restrict lambda = self->lambda;
+    tsk_id_t *restrict pi = self->pi;
+    tsk_id_t *restrict tau = self->tau;
+    tsk_id_t *restrict beta = self->beta;
+    tsk_id_t *restrict alpha = self->alpha;
+    tsk_id_t a, n, p, h;
+
+    p = child[LAMBDA];
+    n = 0;
+    lambda[0] = -1;
+    while (p != LAMBDA) {
+        while (true) {
+            n++;
+            pi[p] = n;
+            tau[n] = LAMBDA;
+            lambda[n] = 1 + lambda[n >> 1];
+            if (child[p] != LAMBDA) {
+                p = child[p];
+            } else {
                 break;
             }
-            sample2_index = next_sample[sample2_index];
         }
-        if (sample1_index == right_sample[u]) {
-            break;
+        beta[p] = n;
+        while (true) {
+            tau[beta[p]] = parent[p];
+            if (sib[p] != LAMBDA) {
+                p = sib[p];
+                break;
+            } else {
+                p = parent[p];
+                if (p != LAMBDA) {
+                    h = lambda[n & -pi[p]];
+                    beta[p] = ((n >> h) | 1) << h;
+                } else {
+                    break;
+                }
+            }
         }
-        sample1_index = next_sample[sample1_index];
-    }
-}
-
-struct kc_stack_elmt {
-    tsk_id_t node;
-    tsk_size_t depth;
-};
-
-static int
-fill_kc_vectors(const tsk_tree_t *t, kc_vectors *kc_vecs)
-{
-    int stack_top;
-    tsk_size_t depth;
-    double time;
-    const double *times;
-    struct kc_stack_elmt *stack;
-    tsk_id_t root, u, c1, c2;
-    int ret = 0;
-    const tsk_treeseq_t *ts = t->tree_sequence;
-
-    stack = tsk_malloc(tsk_tree_get_size_bound(t) * sizeof(*stack));
-    if (stack == NULL) {
-        ret = TSK_ERR_NO_MEMORY;
-        goto out;
     }
 
-    times = t->tree_sequence->tables->nodes.time;
-
-    for (root = tsk_tree_get_left_root(t); root != TSK_NULL; root = t->right_sib[root]) {
-        stack_top = 0;
-        stack[stack_top].node = root;
-        stack[stack_top].depth = 0;
-        while (stack_top >= 0) {
-            u = stack[stack_top].node;
-            depth = stack[stack_top].depth;
-            stack_top--;
-
-            if (tsk_tree_is_sample(t, u)) {
-                time = tsk_tree_get_branch_length_unsafe(t, u);
-                update_kc_vectors_single_sample(ts, kc_vecs, u, time);
+    /* Begin the second traversal */
+    lambda[0] = lambda[n];
+    pi[LAMBDA] = 0;
+    beta[LAMBDA] = 0;
+    alpha[LAMBDA] = 0;
+    p = child[LAMBDA];
+    while (p != LAMBDA) {
+        while (true) {
+            a = alpha[parent[p]] | (beta[p] & -beta[p]);
+            alpha[p] = a;
+            if (child[p] != LAMBDA) {
+                p = child[p];
+            } else {
+                break;
             }
-
-            /* Don't bother going deeper if there are no samples under this node */
-            if (t->left_sample[u] != TSK_NULL) {
-                for (c1 = t->left_child[u]; c1 != TSK_NULL; c1 = t->right_sib[c1]) {
-                    stack_top++;
-                    stack[stack_top].node = c1;
-                    stack[stack_top].depth = depth + 1;
-
-                    for (c2 = t->right_sib[c1]; c2 != TSK_NULL; c2 = t->right_sib[c2]) {
-                        time = times[root] - times[u];
-                        update_kc_vectors_all_pairs(t, kc_vecs, c1, c2, depth, time);
-                    }
+        }
+        while (true) {
+            if (sib[p] != LAMBDA) {
+                p = sib[p];
+                break;
+            } else {
+                p = parent[p];
+                if (p == LAMBDA) {
+                    break;
                 }
             }
         }
     }
-
-out:
-    tsk_safe_free(stack);
-    return ret;
 }
 
-static double
-norm_kc_vectors(kc_vectors *self, kc_vectors *other, double lambda)
+static void
+sv_tables_build(sv_tables_t *self, tsk_tree_t *tree)
 {
-    double vT1, vT2, distance_sum;
-    tsk_id_t i;
-
-    distance_sum = 0;
-    for (i = 0; i < self->n + self->N; i++) {
-        vT1 = ((double) self->m[i] * (1 - lambda)) + (lambda * self->M[i]);
-        vT2 = ((double) other->m[i] * (1 - lambda)) + (lambda * other->M[i]);
-        distance_sum += (vT1 - vT2) * (vT1 - vT2);
-    }
-
-    return sqrt(distance_sum);
+    sv_tables_reset(self, tree);
+    sv_tables_convert_tree(self, tree);
+    sv_tables_build_index(self);
 }
 
-static int
-check_kc_distance_tree_inputs(const tsk_tree_t *self)
+static tsk_id_t
+sv_tables_mrca_one_based(const sv_tables_t *self, tsk_id_t x, tsk_id_t y)
 {
-    tsk_id_t u, num_nodes, left_child;
-    int ret = 0;
+    const tsk_id_t *restrict lambda = self->lambda;
+    const tsk_id_t *restrict pi = self->pi;
+    const tsk_id_t *restrict tau = self->tau;
+    const tsk_id_t *restrict beta = self->beta;
+    const tsk_id_t *restrict alpha = self->alpha;
+    tsk_id_t h, k, xhat, yhat, ell, j, z;
 
-    if (tsk_tree_get_num_roots(self) != 1) {
-        ret = TSK_ERR_MULTIPLE_ROOTS;
-        goto out;
+    if (beta[x] <= beta[y]) {
+        h = lambda[beta[y] & -beta[x]];
+    } else {
+        h = lambda[beta[x] & -beta[y]];
     }
-    if (!tsk_tree_has_sample_lists(self)) {
-        ret = TSK_ERR_NO_SAMPLE_LISTS;
-        goto out;
+    k = alpha[x] & alpha[y] & -(1 << h);
+    h = lambda[k & -k];
+    j = ((beta[x] >> h) | 1) << h;
+    if (j == beta[x]) {
+        xhat = x;
+    } else {
+        ell = lambda[alpha[x] & ((1 << h) - 1)];
+        xhat = tau[((beta[x] >> ell) | 1) << ell];
     }
-
-    num_nodes = (tsk_id_t) tsk_treeseq_get_num_nodes(self->tree_sequence);
-    for (u = 0; u < num_nodes; u++) {
-        left_child = self->left_child[u];
-        if (left_child != TSK_NULL && left_child == self->right_child[u]) {
-            ret = TSK_ERR_UNARY_NODES;
-            goto out;
-        }
+    if (j == beta[y]) {
+        yhat = y;
+    } else {
+        ell = lambda[alpha[y] & ((1 << h) - 1)];
+        yhat = tau[((beta[y] >> ell) | 1) << ell];
     }
-out:
-    return ret;
+    if (pi[xhat] <= pi[yhat]) {
+        z = xhat;
+    } else {
+        z = yhat;
+    }
+    return z;
+}
+
+static tsk_id_t
+sv_tables_mrca(const sv_tables_t *self, tsk_id_t x, tsk_id_t y)
+{
+    /* Convert to 1-based indexes and back */
+    return sv_tables_mrca_one_based(self, x + 1, y + 1) - 1;
 }
 
 static int
-check_kc_distance_samples_inputs(const tsk_treeseq_t *self, const tsk_treeseq_t *other)
+tsk_treeseq_check_node_bounds(
+    const tsk_treeseq_t *self, tsk_size_t num_nodes, const tsk_id_t *nodes)
 {
-    const tsk_id_t *samples, *other_samples;
-    tsk_id_t i, n;
     int ret = 0;
+    tsk_size_t j;
+    tsk_id_t u;
+    const tsk_id_t N = (tsk_id_t) self->tables->nodes.num_rows;
 
-    if (self->num_samples != other->num_samples) {
-        ret = TSK_ERR_SAMPLE_SIZE_MISMATCH;
-        goto out;
-    }
-
-    samples = self->samples;
-    other_samples = other->samples;
-    n = (tsk_id_t) self->num_samples;
-    for (i = 0; i < n; i++) {
-        if (samples[i] != other_samples[i]) {
-            ret = TSK_ERR_SAMPLES_NOT_EQUAL;
+    for (j = 0; j < num_nodes; j++) {
+        u = nodes[j];
+        if (u < 0 || u >= N) {
+            ret = TSK_ERR_NODE_OUT_OF_BOUNDS;
             goto out;
         }
     }
@@ -5710,302 +7379,285 @@ out:
     return ret;
 }
 
-int
-tsk_tree_kc_distance(
-    const tsk_tree_t *self, const tsk_tree_t *other, double lambda, double *result)
+static int
+tsk_treeseq_divergence_matrix_branch(const tsk_treeseq_t *self, tsk_size_t num_samples,
+    const tsk_id_t *restrict samples, tsk_size_t num_windows,
+    const double *restrict windows, tsk_flags_t options, double *restrict result)
 {
-    tsk_id_t n, i;
-    kc_vectors vecs[2];
-    const tsk_tree_t *trees[2] = { self, other };
     int ret = 0;
+    tsk_tree_t tree;
+    const double *restrict nodes_time = self->tables->nodes.time;
+    const tsk_size_t n = num_samples;
+    tsk_size_t i, j, k;
+    tsk_id_t u, v, w, u_root, v_root;
+    double tu, tv, d, span, left, right, span_left, span_right;
+    double *restrict D;
+    sv_tables_t sv;
 
-    for (i = 0; i < 2; i++) {
-        tsk_memset(&vecs[i], 0, sizeof(kc_vectors));
+    memset(&sv, 0, sizeof(sv));
+    ret = tsk_tree_init(&tree, self, 0);
+    if (ret != 0) {
+        goto out;
     }
-
-    ret = check_kc_distance_samples_inputs(self->tree_sequence, other->tree_sequence);
+    ret = sv_tables_init(&sv, self->tables->nodes.num_rows + 1);
     if (ret != 0) {
         goto out;
     }
-    for (i = 0; i < 2; i++) {
-        ret = check_kc_distance_tree_inputs(trees[i]);
-        if (ret != 0) {
-            goto out;
-        }
+
+    if (self->time_uncalibrated && !(options & TSK_STAT_ALLOW_TIME_UNCALIBRATED)) {
+        ret = TSK_ERR_TIME_UNCALIBRATED;
+        goto out;
     }
 
-    n = (tsk_id_t) self->tree_sequence->num_samples;
-    for (i = 0; i < 2; i++) {
-        ret = kc_vectors_alloc(&vecs[i], n);
+    for (i = 0; i < num_windows; i++) {
+        left = windows[i];
+        right = windows[i + 1];
+        D = result + i * n * n;
+        ret = tsk_tree_seek(&tree, left, 0);
         if (ret != 0) {
             goto out;
         }
-        ret = fill_kc_vectors(trees[i], &vecs[i]);
-        if (ret != 0) {
-            goto out;
+        while (tree.interval.left < right && tree.index != -1) {
+            span_left = TSK_MAX(tree.interval.left, left);
+            span_right = TSK_MIN(tree.interval.right, right);
+            span = span_right - span_left;
+            sv_tables_build(&sv, &tree);
+            for (j = 0; j < n; j++) {
+                u = samples[j];
+                for (k = j + 1; k < n; k++) {
+                    v = samples[k];
+                    w = sv_tables_mrca(&sv, u, v);
+                    if (w != TSK_NULL) {
+                        u_root = w;
+                        v_root = w;
+                    } else {
+                        /* Slow path - only happens for nodes in disconnected
+                         * subtrees in a tree with multiple roots */
+                        u_root = tsk_tree_get_node_root(&tree, u);
+                        v_root = tsk_tree_get_node_root(&tree, v);
+                    }
+                    tu = nodes_time[u_root] - nodes_time[u];
+                    tv = nodes_time[v_root] - nodes_time[v];
+                    d = (tu + tv) * span;
+                    D[j * n + k] += d;
+                }
+            }
+            ret = tsk_tree_next(&tree);
+            if (ret < 0) {
+                goto out;
+            }
         }
     }
-
-    *result = norm_kc_vectors(&vecs[0], &vecs[1], lambda);
-out:
-    for (i = 0; i < 2; i++) {
-        kc_vectors_free(&vecs[i]);
-    }
-    return ret;
-}
-
-static int
-check_kc_distance_tree_sequence_inputs(
-    const tsk_treeseq_t *self, const tsk_treeseq_t *other)
-{
-    int ret = 0;
-
-    if (self->tables->sequence_length != other->tables->sequence_length) {
-        ret = TSK_ERR_SEQUENCE_LENGTH_MISMATCH;
-        goto out;
-    }
-
-    ret = check_kc_distance_samples_inputs(self, other);
-    if (ret != 0) {
-        goto out;
-    }
-
+    ret = 0;
 out:
+    tsk_tree_free(&tree);
+    sv_tables_free(&sv);
     return ret;
 }
 
-static void
-update_kc_pair_with_sample(const tsk_tree_t *self, kc_vectors *kc, tsk_id_t sample,
-    tsk_size_t *depths, double root_time)
+static tsk_size_t
+count_mutations_on_path(tsk_id_t u, tsk_id_t v, const tsk_id_t *restrict parent,
+    const double *restrict time, const tsk_size_t *restrict mutations_per_node)
 {
-    tsk_id_t c, p, sib;
-    double time;
-    tsk_size_t depth;
-    double *times = self->tree_sequence->tables->nodes.time;
+    double tu, tv;
+    tsk_size_t count = 0;
 
-    c = sample;
-    for (p = self->parent[sample]; p != TSK_NULL; p = self->parent[p]) {
-        time = root_time - times[p];
-        depth = depths[p];
-        for (sib = self->left_child[p]; sib != TSK_NULL; sib = self->right_sib[sib]) {
-            if (sib != c) {
-                update_kc_vectors_all_pairs(self, kc, sample, sib, depth, time);
+    tu = time[u];
+    tv = time[v];
+    while (u != v) {
+        if (tu < tv) {
+            count += mutations_per_node[u];
+            u = parent[u];
+            if (u == TSK_NULL) {
+                break;
+            }
+            tu = time[u];
+        } else {
+            count += mutations_per_node[v];
+            v = parent[v];
+            if (v == TSK_NULL) {
+                break;
             }
+            tv = time[v];
+        }
+    }
+    if (u != v) {
+        while (u != TSK_NULL) {
+            count += mutations_per_node[u];
+            u = parent[u];
+        }
+        while (v != TSK_NULL) {
+            count += mutations_per_node[v];
+            v = parent[v];
         }
-        c = p;
     }
+    return count;
 }
 
 static int
-update_kc_subtree_state(
-    tsk_tree_t *t, kc_vectors *kc, tsk_id_t u, tsk_size_t *depths, double root_time)
+tsk_treeseq_divergence_matrix_site(const tsk_treeseq_t *self, tsk_size_t num_samples,
+    const tsk_id_t *restrict samples, tsk_size_t num_windows,
+    const double *restrict windows, tsk_flags_t TSK_UNUSED(options),
+    double *restrict result)
 {
-    int stack_top;
-    tsk_id_t v, c;
-    tsk_id_t *stack = NULL;
     int ret = 0;
+    tsk_tree_t tree;
+    const tsk_size_t n = num_samples;
+    const tsk_size_t num_nodes = self->tables->nodes.num_rows;
+    const double *restrict nodes_time = self->tables->nodes.time;
+    tsk_size_t i, j, k, tree_site, tree_mut;
+    tsk_site_t site;
+    tsk_mutation_t mut;
+    tsk_id_t u, v;
+    double left, right, span_left, span_right;
+    double *restrict D;
+    tsk_size_t *mutations_per_node = tsk_malloc(num_nodes * sizeof(*mutations_per_node));
 
-    stack = tsk_malloc(tsk_tree_get_size_bound(t) * sizeof(*stack));
-    if (stack == NULL) {
+    ret = tsk_tree_init(&tree, self, 0);
+    if (ret != 0) {
+        goto out;
+    }
+    if (mutations_per_node == NULL) {
         ret = TSK_ERR_NO_MEMORY;
         goto out;
     }
 
-    stack_top = 0;
-    stack[stack_top] = u;
-    while (stack_top >= 0) {
-        v = stack[stack_top];
-        stack_top--;
-
-        if (tsk_tree_is_sample(t, v)) {
-            update_kc_pair_with_sample(t, kc, v, depths, root_time);
+    for (i = 0; i < num_windows; i++) {
+        left = windows[i];
+        right = windows[i + 1];
+        D = result + i * n * n;
+        ret = tsk_tree_seek(&tree, left, 0);
+        if (ret != 0) {
+            goto out;
         }
-        for (c = t->left_child[v]; c != TSK_NULL; c = t->right_sib[c]) {
-            if (depths[c] != 0) {
-                depths[c] = depths[v] + 1;
-                stack_top++;
-                stack[stack_top] = c;
+        while (tree.interval.left < right && tree.index != -1) {
+            span_left = TSK_MAX(tree.interval.left, left);
+            span_right = TSK_MIN(tree.interval.right, right);
+
+            /* NOTE: we could avoid this full memset across all nodes by doing
+             * the same loops again and decrementing at the end of the main
+             * tree-loop. It's probably not worth it though, because of the
+             * overwhelming O(n^2) below */
+            tsk_memset(mutations_per_node, 0, num_nodes * sizeof(*mutations_per_node));
+            for (tree_site = 0; tree_site < tree.sites_length; tree_site++) {
+                site = tree.sites[tree_site];
+                if (span_left <= site.position && site.position < span_right) {
+                    for (tree_mut = 0; tree_mut < site.mutations_length; tree_mut++) {
+                        mut = site.mutations[tree_mut];
+                        mutations_per_node[mut.node]++;
+                    }
+                }
+            }
+
+            for (j = 0; j < n; j++) {
+                u = samples[j];
+                for (k = j + 1; k < n; k++) {
+                    v = samples[k];
+                    D[j * n + k] += (double) count_mutations_on_path(
+                        u, v, tree.parent, nodes_time, mutations_per_node);
+                }
+            }
+            ret = tsk_tree_next(&tree);
+            if (ret < 0) {
+                goto out;
             }
         }
     }
-
+    ret = 0;
 out:
-    tsk_safe_free(stack);
+    tsk_tree_free(&tree);
+    tsk_safe_free(mutations_per_node);
     return ret;
 }
 
-static int
-update_kc_incremental(tsk_tree_t *self, kc_vectors *kc, tsk_edge_list_t *edges_out,
-    tsk_edge_list_t *edges_in, tsk_size_t *depths)
+static void
+fill_lower_triangle(
+    double *restrict result, const tsk_size_t n, const tsk_size_t num_windows)
 {
-    int ret = 0;
-    tsk_edge_list_node_t *record;
-    tsk_edge_t *e;
-    tsk_id_t u;
-    double root_time, time;
-    const double *times = self->tree_sequence->tables->nodes.time;
-
-    /* Update state of detached subtrees */
-    for (record = edges_out->tail; record != NULL; record = record->prev) {
-        e = &record->edge;
-        u = e->child;
-        depths[u] = 0;
-
-        if (self->parent[u] == TSK_NULL) {
-            root_time = times[tsk_tree_node_root(self, u)];
-            ret = update_kc_subtree_state(self, kc, u, depths, root_time);
-            if (ret != 0) {
-                goto out;
+    tsk_size_t i, j, k;
+    double *restrict D;
+
+    /* TODO there's probably a better striding pattern that could be used here */
+    for (i = 0; i < num_windows; i++) {
+        D = result + i * n * n;
+        for (j = 0; j < n; j++) {
+            for (k = j + 1; k < n; k++) {
+                D[k * n + j] = D[j * n + k];
             }
         }
     }
-
-    /* Propagate state change down into reattached subtrees. */
-    for (record = edges_in->tail; record != NULL; record = record->prev) {
-        e = &record->edge;
-        u = e->child;
-
-        tsk_bug_assert(depths[e->child] == 0);
-        depths[u] = depths[e->parent] + 1;
-
-        root_time = times[tsk_tree_node_root(self, u)];
-        ret = update_kc_subtree_state(self, kc, u, depths, root_time);
-        if (ret != 0) {
-            goto out;
-        }
-
-        if (tsk_tree_is_sample(self, u)) {
-            time = tsk_tree_get_branch_length_unsafe(self, u);
-            update_kc_vectors_single_sample(self->tree_sequence, kc, u, time);
-        }
-    }
-
-out:
-    return ret;
 }
 
 int
-tsk_treeseq_kc_distance(const tsk_treeseq_t *self, const tsk_treeseq_t *other,
-    double lambda_, double *result)
+tsk_treeseq_divergence_matrix(const tsk_treeseq_t *self, tsk_size_t num_samples,
+    const tsk_id_t *samples_in, tsk_size_t num_windows, const double *windows,
+    tsk_flags_t options, double *result)
 {
-    int i;
-    tsk_id_t n;
-    tsk_size_t num_nodes;
-    double left, span, total;
-    const tsk_treeseq_t *treeseqs[2] = { self, other };
-    tsk_tree_t trees[2];
-    kc_vectors kcs[2];
-    tsk_diff_iter_t diff_iters[2];
-    tsk_edge_list_t edges_out[2];
-    tsk_edge_list_t edges_in[2];
-    tsk_size_t *depths[2];
-    double t0_left, t0_right, t1_left, t1_right;
     int ret = 0;
+    const tsk_id_t *samples = self->samples;
+    tsk_size_t n = self->num_samples;
+    const double default_windows[] = { 0, self->tables->sequence_length };
+    bool stat_site = !!(options & TSK_STAT_SITE);
+    bool stat_branch = !!(options & TSK_STAT_BRANCH);
+    bool stat_node = !!(options & TSK_STAT_NODE);
 
-    for (i = 0; i < 2; i++) {
-        tsk_memset(&trees[i], 0, sizeof(trees[i]));
-        tsk_memset(&diff_iters[i], 0, sizeof(diff_iters[i]));
-        tsk_memset(&kcs[i], 0, sizeof(kcs[i]));
-        tsk_memset(&edges_out[i], 0, sizeof(edges_out[i]));
-        tsk_memset(&edges_in[i], 0, sizeof(edges_in[i]));
-        depths[i] = NULL;
-    }
-
-    ret = check_kc_distance_tree_sequence_inputs(self, other);
-    if (ret != 0) {
+    if (stat_node) {
+        ret = TSK_ERR_UNSUPPORTED_STAT_MODE;
         goto out;
     }
-
-    n = (tsk_id_t) self->num_samples;
-    for (i = 0; i < 2; i++) {
-        ret = tsk_tree_init(&trees[i], treeseqs[i], TSK_SAMPLE_LISTS);
-        if (ret != 0) {
-            goto out;
-        }
-        ret = tsk_diff_iter_init_from_ts(&diff_iters[i], treeseqs[i], false);
-        if (ret != 0) {
-            goto out;
-        }
-        ret = kc_vectors_alloc(&kcs[i], n);
-        if (ret != 0) {
-            goto out;
-        }
-        num_nodes = tsk_treeseq_get_num_nodes(treeseqs[i]);
-        depths[i] = tsk_calloc(num_nodes, sizeof(*depths[i]));
-        if (depths[i] == NULL) {
-            ret = TSK_ERR_NO_MEMORY;
-            goto out;
-        }
+    /* If no mode is specified, we default to site mode */
+    if (!(stat_site || stat_branch)) {
+        stat_site = true;
     }
-
-    total = 0;
-    left = 0;
-
-    ret = tsk_tree_first(&trees[0]);
-    if (ret != TSK_TREE_OK) {
+    /* It's an error to specify more than one mode */
+    if (stat_site + stat_branch > 1) {
+        ret = TSK_ERR_MULTIPLE_STAT_MODES;
         goto out;
     }
-    ret = check_kc_distance_tree_inputs(&trees[0]);
-    if (ret != 0) {
+
+    if (options & TSK_STAT_POLARISED) {
+        ret = TSK_ERR_STAT_POLARISED_UNSUPPORTED;
         goto out;
     }
-    ret = tsk_diff_iter_next(
-        &diff_iters[0], &t0_left, &t0_right, &edges_out[0], &edges_in[0]);
-    tsk_bug_assert(ret == TSK_TREE_OK);
-    ret = update_kc_incremental(
-        &trees[0], &kcs[0], &edges_out[0], &edges_in[0], depths[0]);
-    if (ret != 0) {
+    if (options & TSK_STAT_SPAN_NORMALISE) {
+        ret = TSK_ERR_STAT_SPAN_NORMALISE_UNSUPPORTED;
         goto out;
     }
-    while ((ret = tsk_tree_next(&trees[1])) == TSK_TREE_OK) {
-        ret = check_kc_distance_tree_inputs(&trees[1]);
+
+    if (windows == NULL) {
+        num_windows = 1;
+        windows = default_windows;
+    } else {
+        ret = tsk_treeseq_check_windows(self, num_windows, windows, 0);
         if (ret != 0) {
             goto out;
         }
-        ret = tsk_diff_iter_next(
-            &diff_iters[1], &t1_left, &t1_right, &edges_out[1], &edges_in[1]);
-        tsk_bug_assert(ret == TSK_TREE_OK);
+    }
 
-        ret = update_kc_incremental(
-            &trees[1], &kcs[1], &edges_out[1], &edges_in[1], depths[1]);
+    if (samples_in != NULL) {
+        samples = samples_in;
+        n = num_samples;
+        ret = tsk_treeseq_check_node_bounds(self, n, samples);
         if (ret != 0) {
             goto out;
         }
-        while (t0_right < t1_right) {
-            span = t0_right - left;
-            total += norm_kc_vectors(&kcs[0], &kcs[1], lambda_) * span;
+    }
 
-            left = t0_right;
-            ret = tsk_tree_next(&trees[0]);
-            tsk_bug_assert(ret == TSK_TREE_OK);
-            ret = check_kc_distance_tree_inputs(&trees[0]);
-            if (ret != 0) {
-                goto out;
-            }
-            ret = tsk_diff_iter_next(
-                &diff_iters[0], &t0_left, &t0_right, &edges_out[0], &edges_in[0]);
-            tsk_bug_assert(ret == TSK_TREE_OK);
-            ret = update_kc_incremental(
-                &trees[0], &kcs[0], &edges_out[0], &edges_in[0], depths[0]);
-            if (ret != 0) {
-                goto out;
-            }
-        }
-        span = t1_right - left;
-        left = t1_right;
-        total += norm_kc_vectors(&kcs[0], &kcs[1], lambda_) * span;
+    tsk_memset(result, 0, num_windows * n * n * sizeof(*result));
+
+    if (stat_branch) {
+        ret = tsk_treeseq_divergence_matrix_branch(
+            self, n, samples, num_windows, windows, options, result);
+    } else {
+        tsk_bug_assert(stat_site);
+        ret = tsk_treeseq_divergence_matrix_site(
+            self, n, samples, num_windows, windows, options, result);
     }
     if (ret != 0) {
         goto out;
     }
+    fill_lower_triangle(result, n, num_windows);
 
-    *result = total / self->tables->sequence_length;
 out:
-    for (i = 0; i < 2; i++) {
-        tsk_tree_free(&trees[i]);
-        tsk_diff_iter_free(&diff_iters[i]);
-        kc_vectors_free(&kcs[i]);
-        tsk_safe_free(depths[i]);
-    }
     return ret;
 }
diff --git a/tskit/trees.h b/tskit/trees.h
index efe9980..a503b3e 100644
--- a/tskit/trees.h
+++ b/tskit/trees.h
@@ -919,6 +919,15 @@ typedef int general_stat_func_t(tsk_size_t state_dim, const double *state,
 int tsk_treeseq_general_stat(const tsk_treeseq_t *self, tsk_size_t K, const double *W,
     tsk_size_t M, general_stat_func_t *f, void *f_params, tsk_size_t num_windows,
     const double *windows, tsk_flags_t options, double *result);
+// TODO: expose this externally?
+/* int tsk_treeseq_two_locus_general_stat(const tsk_treeseq_t *self, */
+/*     tsk_size_t num_sample_sets, const tsk_size_t *sample_set_sizes, */
+/*     const tsk_id_t *sample_sets, tsk_size_t result_dim, const tsk_id_t *set_indexes,
+ */
+/*     general_stat_func_t *f, norm_func_t *norm_f, tsk_size_t num_left_windows, */
+/*     const double *left_windows, tsk_size_t num_right_windows, */
+/*     const double *right_windows, tsk_flags_t options, tsk_size_t num_result, */
+/*     double *result); */
 
 /* One way weighted stats */
 
@@ -943,6 +952,17 @@ int tsk_treeseq_trait_linear_model(const tsk_treeseq_t *self, tsk_size_t num_wei
     const double *weights, tsk_size_t num_covariates, const double *covariates,
     tsk_size_t num_windows, const double *windows, tsk_flags_t options, double *result);
 
+/* Two way weighted stats with covariates */
+
+typedef int two_way_weighted_method(const tsk_treeseq_t *self, tsk_size_t num_weights,
+    const double *weights, tsk_size_t num_index_tuples, const tsk_id_t *index_tuples,
+    tsk_size_t num_windows, const double *windows, double *result, tsk_flags_t options);
+
+int tsk_treeseq_genetic_relatedness_weighted(const tsk_treeseq_t *self,
+    tsk_size_t num_weights, const double *weights, tsk_size_t num_index_tuples,
+    const tsk_id_t *index_tuples, tsk_size_t num_windows, const double *windows,
+    double *result, tsk_flags_t options);
+
 /* One way sample set stats */
 
 typedef int one_way_sample_stat_method(const tsk_treeseq_t *self,
@@ -987,6 +1007,42 @@ int tsk_treeseq_genetic_relatedness(const tsk_treeseq_t *self,
     const tsk_id_t *index_tuples, tsk_size_t num_windows, const double *windows,
     tsk_flags_t options, double *result);
 
+int tsk_treeseq_D(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result);
+int tsk_treeseq_D2(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result);
+int tsk_treeseq_r2(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result);
+int tsk_treeseq_D_prime(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result);
+int tsk_treeseq_r(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result);
+int tsk_treeseq_Dz(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result);
+int tsk_treeseq_pi2(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
+    const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
+    tsk_size_t num_left_windows, const double *left_windows,
+    tsk_size_t num_right_windows, const double *right_windows, tsk_flags_t options,
+    tsk_size_t *result_size, double **result);
+
 /* Three way sample set stats */
 int tsk_treeseq_Y3(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
     const tsk_size_t *sample_set_sizes, const tsk_id_t *sample_sets,
@@ -1003,6 +1059,10 @@ int tsk_treeseq_f4(const tsk_treeseq_t *self, tsk_size_t num_sample_sets,
     tsk_size_t num_index_tuples, const tsk_id_t *index_tuples, tsk_size_t num_windows,
     const double *windows, tsk_flags_t options, double *result);
 
+int tsk_treeseq_divergence_matrix(const tsk_treeseq_t *self, tsk_size_t num_samples,
+    const tsk_id_t *samples, tsk_size_t num_windows, const double *windows,
+    tsk_flags_t options, double *result);
+
 /****************************************************************************/
 /* Tree */
 /****************************************************************************/
@@ -1724,6 +1784,40 @@ bool tsk_tree_equals(const tsk_tree_t *self, const tsk_tree_t *other);
 int tsk_diff_iter_init_from_ts(
     tsk_diff_iter_t *self, const tsk_treeseq_t *tree_sequence, tsk_flags_t options);
 
+/* Temporarily putting this here to avoid problems with doxygen. Will need to
+ * move up the file later when it gets incorporated into the tsk_tree_t object.
+ */
+typedef struct {
+    tsk_id_t index;
+    struct {
+        double left;
+        double right;
+    } interval;
+    struct {
+        tsk_id_t start;
+        tsk_id_t stop;
+        const tsk_id_t *order;
+    } in;
+    struct {
+        tsk_id_t start;
+        tsk_id_t stop;
+        const tsk_id_t *order;
+    } out;
+    tsk_id_t left_current_index;
+    tsk_id_t right_current_index;
+    int direction;
+    const tsk_treeseq_t *tree_sequence;
+} tsk_tree_position_t;
+
+int tsk_tree_position_init(
+    tsk_tree_position_t *self, const tsk_treeseq_t *tree_sequence, tsk_flags_t options);
+int tsk_tree_position_free(tsk_tree_position_t *self);
+int tsk_tree_position_print_state(const tsk_tree_position_t *self, FILE *out);
+bool tsk_tree_position_next(tsk_tree_position_t *self);
+bool tsk_tree_position_prev(tsk_tree_position_t *self);
+int tsk_tree_position_seek_forward(tsk_tree_position_t *self, tsk_id_t index);
+int tsk_tree_position_seek_backward(tsk_tree_position_t *self, tsk_id_t index);
+
 #ifdef __cplusplus
 }
 #endif
