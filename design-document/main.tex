\documentclass[12pt]{article}

\usepackage[tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in]{geometry}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{cite}
\usepackage{amsmath}
\usepackage[bb=dsserif]{mathalpha}
\usepackage{svg}
\usepackage{relsize}
\usepackage{float}

\newcommand{\ccode}[1]{\mintinline{C}{#1}}
\usepackage[linesnumbered,lined,commentsnumbered]{algorithm2e}

\title{Two Locus General Statistics in tskit}
\author{Lloyd Kirk, Ragsdale Lab}

\begin{document}

\maketitle

\section{Background}

The intention of this document is to describe the changes to tskit in order to
provide a generalized framework for computing two-locus statistics for branches
and sites.

Some of the design proposal is taken from
\href{https://github.com/tskit-dev/tskit/pull/432}{GH-432} There has been a bit
of discussion on \href{https://github.com/tskit-dev/tskit/issues/1900}{GH-1900}
as well.

\section{Goal/Scope}

Ultimately, we intend to deprecate the LD calculator that is currently
implemented in tskit and implement a general framework for two-locus
statistics. This framework will create an interface for implementing new summary
statistics and implement the following features:

\begin{itemize}
  \item Statistics for sites with more than 1 mutation (multiallelic sites)
  \item Polarization, where applicable
  \item Branch Statistics
  \item LD Stats beyond $r^{2}$
\end{itemize}

\section{Implementation}
We have been trying to follow the general design pattern laid out in the C
api. Most of the initial design documentation will focus on creating the
necessary C interfaces to consume from the python api.

Some of this documentation is based on my (LKâ€™s) interpretation of the design
patterns in the existing code. I have no insight into how things might change
apart from the scattered TODOs in the code. In short, please feel free to
correct my assumptions/understandings.

\subsection{Outer Layer}

For each summary function we intend to implement, we will have an outer wrapper
for that function. For example, for the $r^2$ statistic, we will have a
\ccode{r2_summary_func} and a corresponding \ccode{tsk_treeseq_r2}. These
wrappers will call into \ccode{tsk_treeseq_sample_count_stat}, which will check
our sample sets and produce a matrix of weights.

After these generic preparations (which will remain untouched for our purposes),
the code will call into \ccode{tsk_treeseq_general_stat}, which is the main
entrypoint for computing stats from tree sequences. Within
\ccode{tsk_treeseq_general_stat}, we will add some more conditionals in the form
of \ccode{tsk_flags_t}.

\begin{minted}{c}
  bool stat_two_site = !!(options & TSK_STAT_TWO_SITE);
  bool stat_two_branch = !!(options & TSK_STAT_TWO_BRANCH);
\end{minted}

These flags would dispatch our entrypoints for computing two site/branch
statistics, allowing us to use the same entrypoint function for all statistics.

\subsection{Two Site Statistics}

\subsubsection{Node counting to compare pairs of sites}\label{section:node_counting}

We are considering two algorithms for traversing the trees and storing haplotype
counts. One is more CPU intensive and the other is more memory intensive. Here,
I will outline both for consideration:

% https://mirror.mwt.me/ctan/macros/latex/contrib/algorithm2e/doc/algorithm2e.pdf
\paragraph{Option 1 (memory intensive)}
\mbox{} \\
\begin{algorithm}[H]
  \SetArgSty{textnormal}

  \emph{Loop over all trees trees, computing their state and storing in a matrix} \\
  state = calloc (num\_nodes $\ast$ num\_trees, sizeof ($\ast$ double))
  
  \For{tree\_index = 0 \KwTo{} num\_trees}{

    count\_edges\_under\_nodes (tree, \&state) \\

  }
  \emph{Compute two locus statistics for all combinations of sites (with
replacement)} \\
  sites\_subloop\_start = 0
  \For{site\_index\_left = 0 \KwTo{} num\_sites\_left}{
    \For{site\_index\_right = sites\_subloop\_start \KwTo{} num\_sites\_right}{
      compute\_general\_stat\_two\_site\_result (site\_index\_left, site\_index\_right, state) \\
    }
    sites\_subloop\_start++ \\
  }

\end{algorithm}

Using this strategy, we will end up with memory scaling of $\mathcal{O}(n \times
m)$, where $n$ is the number of edges in the tree sequence and $m$ is the number
of trees. The computational complexity should be roughly $\mathcal{O}(\binom{m}{2})$
where $m$ is the number of sites.

\paragraph{Option 2 (CPU intensive)}
\mbox{} \\
\begin{algorithm}[H]
  \SetArgSty{textnormal}

  \emph{Loop over pairs of trees and compute statistics after computing the left
  and right state for each tree pair} \\
  subloop\_start = 0 \\
  
  \For{tree\_index\_left = 0 \KwTo{} num\_trees}{

    \emph{Count edges on the left tree} \\
    count\_edges\_under\_nodes (left\_tree, \&left\_state) \\

    \For{tree\_index\_right = subloop\_start \KwTo{} num\_trees\_right}{

      \emph{Count edges on the right tree} \\
      count\_edges\_under\_nodes (right\_tree, \&right\_state) \\

      \emph{Compute two locus statistics for all combinations of sites within
        left and right tree (with replacement)} \\
      sites\_subloop\_start = 0
      \For{site\_index\_left = 0 \KwTo{} num\_sites\_left}{
        \For{site\_index\_right = sites\_subloop\_start \KwTo{} num\_sites\_right}{
          compute\_general\_stat\_two\_site\_result (site\_index\_left, site\_index\_right, left\_state, right\_state) \\
        }
        sites\_subloop\_start++ \\
      }


    }
    tree\_index\_right++ \\
  }
\end{algorithm}

In this approach, we end up with memory scaling of $\mathcal{O}(2 \times n)$,
where $n$ is the number of edges in a given tree. The computational scaling of
this approach is roughly $\mathcal{O}(\binom{m}{2} \times \binom{n}{2})$ where
$m$ is the number of sites and $n$ is the number of trees.

Without profiling, I am not sure how these approaches behave under different
topologies, but I would lean towards \textbf{Option 1} unless there are strict
memory requirements for tskit. In any case, comparing these two algorithms would
not be difficult. I'm also open to suggestions here.

\subsubsection{Two-Site General Stats Interface}
We will provide a similar interface to computing
\ccode{tsk_treeseq_site_general_stat}, with a different tree traversal algorithm
(see Section~\ref{section:node_counting}), providing haplotype counts instead of
site counts (see Section~\ref{section:hap_counting}). In our implementation, we
will use \ccode{get_allele_weights} to compute the allele counts for our left
and right site. We will then pass the allele states for the lefthand site and
the righthand site into \ccode{compute_general_stat_two_site_result} (described
in Section~\ref{section:computing_results}).

\begin{minted}{c}
static int
tsk_treeseq_two_site_general_stat(
	const tsk_treeseq_t *self,
	tsk_size_t state_dim,
	const double *sample_weights,
	tsk_size_t result_dim,
	general_stat_func_t *f,
	void *f_params,  // We can use sample_count_stat_params_t
	tsk_size_t num_windows,
	const double *windows,
	tsk_flags_t options,
	double *result
)
\end{minted}

\subsection{Computing results}\label{section:computing_results}

The two site result function will accept the allele states from two sites as
parameters. This means that we can avoid running \ccode{get_allele_weights}
multiple times for a single site. Our two site results function will compute the
counts of haplotypes for a given pair of sites and pass these haplotype counts
to our summary functions.

\begin{minted}{c}
static int
compute_general_stat_two_site_result(
	double *site_a_allele_states,
	double *site_b_allele_states,
        tsk_size_t num_a_alleles,
        tsk_size_t num_b_alleles,
	tsk_size_t allele_state_dim,
	tsk_size_t result_dim,
	general_stat_func_t *f,
	void *f_params,
	double *total_weight,
	bool polarised,
	double *result,
)
\end{minted}

\subsubsection{Haplotype Counting Algorithm}\label{section:hap_counting}

We use pairs of 1-d row vectors (allele\_states in the previous section) to
describe the terminal allelic state in a given pair of sites. For example, if
we're given a tree sequence like the one shown in Figure~\ref{fig:example_tree},
we will loop over the combinations of sites and compare them in pairs: (0, 0),
(0, 1), (1, 1). In the portion of the loop where we're comparing site 0 and site
1, the lefthand vector will be $\left(\begin{array}{cccccccc}2 & 2 & 3 & 3 & 1 &
1 & 1 & 1 \\\end{array}\right)$ and the righthand vector will be
$\left(\begin{array}{cccccccc} 1 & 1 & 1 & 1 & 2 & 2 & 2 & 0
\\\end{array}\right)$. When we compute the haplotype counts for the comparison
of site 0 and site 1, we get a matrix with dimensions
n\_alleles\_A$\times$n\_alleles\_B. In our case 4$\times$3. The resulting
haplotype count matrix for our example is:

\[
  \left(
    \begin{array}{ccc}
      0 & 0 & 0 \\
      1 & 0 & 3 \\
      0 & 2 & 0 \\
      0 & 2 & 0 \\
    \end{array}
  \right)
\]

To produce these counts, we address the haplotype matrix with the enumerated
allelic state as the x and y coordinate and increment the count by one for each
that we encounter (very similar to the algorithm in the python prototype).
\
\begin{figure}[H]
    \centering
    % \includesvg[width=\textwidth]{figure1.svg}
    % \includesvg[width=\linewidth,inkscapelatex=false,pretex=\relscale{0.4}]{figure1.svg}
    \includesvg[width=\linewidth,inkscapelatex=false]{figure1.svg}
    \caption{
      \textbf{An example of a tree sequence used to compute two-locus statistics.}
      The left tree has one site with four states and the right tree has one
      site with three states.
    }
\label{fig:example_tree}
\end{figure}



\section{Summary Functions}

Table~\ref{table:summary_functions} provides an overview of the summary
functions that we intend to implement as site and branch statistics. The
normalization strategy is described in further detail in~\ref{section:normalization}.

\begin{table}[H]
  \begin{tabular}{llll} Statistic & Polarization & Normalization & Equation\\

    \hline $D$ & Polarized & Total & $D = f_{ab} - f_{a}f_{b}$ \\

    $D^{\prime}$ & Polarized & Haplotype Weighted & $D^{\prime} =
\frac{D}{D_{max}}$ \\

    $D^{2}$ & Unpolarized & Total & $D^{2} = D^{2}$ \\

    $D_{z}$ & Unpolarized & Total & $D_{z} = D (1 - 2 f_{a})(1-2f_{b})$ \\

    $\pi_{2}$ & Unpolarized & Total & $\pi_{2} = f_{a}f_{b}(1-f_{a})(1-f_{b})$
\\

    $r$ & Polarized & Haplotype Weighted & $r =
\frac{D}{\sqrt{f_{a}f_{b}(1-f_{a})(1-f_{b})}}$ \\

    $r^{2}$ & Unpolarized & Haplotype Weighted & $r^{2} =
\frac{D^{2}}{f_{a}f_{b}(1-f_{a})(1-f_{b})}$ \\
  \end{tabular}
\label{table:summary_functions}
\end{table}
Where $D_{max}$ is defined as:

\[
  D_{max} = 
  \begin{cases}
    \min\{f_{a}(1-f_{b}),f_{b}(1-f_{b})\} & \text{if~}D>=0 \\
    \min\{f_{a}f_{b},(1-f_{b})(1-f_{b})\} & \text{otherwise}
  \end{cases}
\]

\subsection{Summary Function Signature}
Two locus statistics need to know the number of AB, Ab, and aB haplotypes. They
also need to know the total number of haplotypes being considered in order to
properly convert the counts of each haplotype to proportions.
\begin{minted}{c}
static int
summary_func(int w_AB, int w_Ab, int w_aB, int n)
\end{minted}

\begin{minted}{c}
two_site_summary_func(
	tsk_size_t state_dim,
	const double *state,
	tsk_size_t TSK_UNUSED(result_dim),
	double *result,
	void *params
)
\end{minted}

\subsection{Normalization} \label{section:normalization}
In our testing of summary functions, we found that the appropriate normalization
procedure can vary depending on the summary function. We've settled on two
normalization procedures: ``Haplotype Weighted'' and ``Total''.

\subsubsection{Hapltype Weighted}
In the ``Haplotype Weighted'' normalization method, we weight the statistics by
the frequency of its haplotype. This is necessary in ratio statistics, such as
$D^{\prime}$, $r$ and $r^{2}$.
\[
  \sum_{i=1}^{n}\sum_{j=1}^{m}p(A_{i}B_{j})F_{ij}
\]
where $F$ is the summary function and $p(A_{i}B_{j})$ is the frequency of
haplotype $A_{i}B_{j}$. This method can be found
in~\cite{zhao2007evaluation}. We apply this 
\subsubsection{Total}
In the ``Total'' normalization method, we simply divide by the number of
haplotypes that we've visited. If we're using a non-ratio statistic, this is
likely the desired normalization stategy.
\[
  \frac{1}{(n-\mathbb{1}_{p}) (m-\mathbb{1}_{p})}\sum_{i=1}^{n}\sum_{j=1}^{m}F_{ij}
\]
where $\mathbb{1}_{p}$ is an indicator function conditioned on whether or not
our statistic is polarized, $n$ is the number of alleles in site $a$, and $m$ is
the number of alleles in site $b$.

\subsection{Evaluation}
To ensure the correctness of our implementation, we have devised a number of
test scenarios that will produce data at the theoretical limits of the
statistics we've implemented. Note that our validation is not exhaustive, but it
is a reasonable starting point for the purposes of verifying the correctness of
our normalization strategy and will be useful for our C implementation.

\subsubsection{Test cases}
Table~\ref{table:test_cases} enumerates the various test cases that we are using
to validate the correctness of our metrics. The subsequent sections refer to
test cases by name. Each test case is a two-site state matrix with 8-9 samples.

\begin{table}[H]
  \centering
  \begin{tabular}{lc} Name & $\left(\begin{array}{cc} Site A \\ Site B
                                     \\ \end{array}\right)$ \\

    \hline
    Correlated & $\left(\begin{array}{ccccccccc}
                          0 & 1 & 1 & 0 & 2 & 2 & 1 & 0 & 1 \\
                          1 & 2 & 2 & 1 & 0 & 0 & 2 & 1 & 2 \\
                        \end{array}\right)$ \\
    Uncorrelated & $\left(\begin{array}{ccccccccc}
                            0 & 0 & 0 & 1 & 1 & 1 & 2 & 2 & 2 \\
                            0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 & 2 \\
                          \end{array}\right)$ \\
    Correlated Biallelic & $\left(\begin{array}{cccccccc}
                                    0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
                                    0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
                                  \end{array}\right)$ \\
    Uncorrelated Biallelic & $\left(\begin{array}{cccccccc}
                                      0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
                                      1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 \\
                                    \end{array}\right)$ \\
    Repulsion Biallelic & $\left(\begin{array}{cccccccc}
                                   0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
                                   1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\
                                 \end{array}\right)$ \\
  \end{tabular}
  \caption{
    \textbf{Test cases for validating statistics.}
    In each case, we have an A and B site, representing the two sites under
    consideration for computaiton of our statistics.
  }
  \label{table:test_cases}
\end{table}

\subsubsection{Polarized}
We'll begin with the polarized statistics. $D$ and $D^{\prime}$ sum to zero when
they are unpolarized, so we are only providing a polarized method to compute
them. The correctness of polarized $D$ is best verified with bi-allelic
sites. We can use the unpolarized statistics to verify the correctness of $D$ in
multi-allelic scenarios. These results tell us that our normalization strategy
is correct and that D has been properly implemented.

\begin{table}[H]
  \begin{tabular}{lc} Name & Result \\
    \hline
    Correlated Biallelic & $\left(\begin{array}{cc}
                                    0.25 & 0.25 \\
                                    0.25 & 0.25 \\
                                  \end{array}\right)$ \\
    Uncorrelated Biallelic & $\left(\begin{array}{cc}
                                      0.25 & 0.0 \\
                                      0.0 & 0.25 \\
                                    \end{array}\right)$ \\
    Repulsion Biallelic & $\left(\begin{array}{cc}
                                    0.25 & -0.25 \\
                                    -0.25 & 0.25 \\
                                 \end{array}\right)$ \\
    Correlated (unpolarized) & $\left(\begin{array}{cc}
                                        0.0 & 0.0 \\
                                        0.0 & 0.0 \\
                                      \end{array}\right)$ \\
  \end{tabular}
  \caption{
    \textbf{Validation results for $D$}
    All results are polarized unless marked unpolarized.
  }
\end{table}

\begin{table}[H]
  \begin{tabular}{lc} Name & Result \\
    \hline
    Correlated Biallelic & $\left(\begin{array}{cc}
                                    0.5 & 0.5 \\
                                    0.5 & 0.5 \\
                                  \end{array}\right)$ \\
    Uncorrelated Biallelic & $\left(\begin{array}{cc}
                                      0.5 & 0.0 \\
                                      0.0 & 0.5 \\
                                    \end{array}\right)$ \\
    Repulsion Biallelic & $\left(\begin{array}{cc}
                                    0.5 & 0.0 \\
                                    0.0 & 0.5 \\
                                 \end{array}\right)$ \\
    Correlated (unpolarized) & $\left(\begin{array}{cc}
                                        1.0 & 1.0 \\
                                        1.0 & 1.0 \\
                                      \end{array}\right)$ \\
    Unorrelated (unpolarized) & $\left(\begin{array}{cc}
                                         1.0 & 0.0 \\
                                         0.0 & 1.0 \\
                                       \end{array}\right)$ \\
  \end{tabular}
  \caption{
    \textbf{Validation results for $r$.}
    All results are polarized unless marked unpolarized.
  }
\end{table}

\bibliographystyle{plain}
\bibliography{references}

\end{document}